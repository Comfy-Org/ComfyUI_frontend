// Vue 3 Composition API .cursorrules

// Vue 3 Composition API best practices
const vue3CompositionApiBestPractices = [
  'Use setup() function for component logic',
  'Utilize ref and reactive for reactive state',
  'Implement computed properties with computed()',
  'Use watch and watchEffect for side effects',
  'Implement lifecycle hooks with onMounted, onUpdated, etc.',
  'Utilize provide/inject for dependency injection',
  'Use Vue 3.5 props destructuring instead of defining a single props variable',
  'Use useAsyncState instead of async onMounted hooks',
  'Implement proper cleanup in components (cancel debounced functions, pending requests, clear maps, etc.)',
  'Use proper function type syntax for defineEmits instead of type literals with only a call signature',
  'Use VueUse composables for common tasks (event listeners, timeouts, caching, resize observers, etc.)',
  'Use useBreakpoints and breakpointsTailwind for creating responsive components',
  'Use watchDebounced, watchIgnorable, watchThrottled, watchAtMost, etc. for granular reactivity control',
  'Use syncRef for two-way binding with refs'
]

// Folder structure
const folderStructure = `
src/
  components/
  constants/
  composables/
  views/
  stores/
  services/
  App.vue
  main.ts
`

// Tailwind CSS best practices
const tailwindCssBestPractices = [
  'Use Tailwind CSS for styling',
  'Implement responsive design with Tailwind CSS',
  'Use inline Tailwind instead of CSS in <style> blocks',
  'Use the dark-theme: prefix for styles that depend on the theme',
  'Use rem units instead of static px values',
  'Refer to the tailwind.config.js to ensure all utility classes exist'
]

// PrimeVue best practices
const primeVueBestPractices = [
  'Use Popover component instead of OverlayPanel',
  'Use PrimeVue passthrough (pt) for styling sub-components',
  'Use ProgressSpinner for loading states'
]

// Component design best practices
const componentDesignBestPractices = [
  'Use slots for reusable template sections instead of repeating code',
  'Use NoResultsPlaceholder from components/common/ folder for empty states',
  'Always handle loading, error, and empty states'
]

// Internationalization best practices
const i18nBestPractices = [
  'Use the i18n function ($t) for all user-facing text',
  'Add all translation keys to the appropriate locale files (main.json, etc.)',
  'Provide fallback text for missing translations'
]

// Lodash best practices
const lodashBestPractices = [
  'Use lodash for utility functions',
  'Use lodash debounce for debouncing functions',
  'Use lodash memoize for expensive pure functions',
  'Use lodash merge for complex merge operations',
  'Use lodash throttle for throttling functions'
]

// Additional instructions
const additionalInstructions = `
1. Leverage VueUse functions for performance-enhancing styles
2. Use lodash for utility functions
3. Use TypeScript for type safety
4. Implement proper props and emits definitions
5. Utilize Vue 3's Teleport component when needed
6. Use Suspense for async components
7. Implement proper error handling
8. Follow Vue 3 style guide and naming conventions
9. Use Vite for fast development and building
`
