/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get information about the calling user. */
        get: operations["getUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Search for customers
         * @description Search for customers by email, name, Stripe ID, or Metronome ID.
         */
        get: operations["searchCustomers"];
        put?: never;
        /**
         * Create a new customer
         * @description Creates a new customer using the provided token. No request body is needed as user information is extracted from the token.
         */
        post: operations["createCustomer"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get authenticated customer details
         * @description Returns details about the currently authenticated customer based on their JWT token.
         */
        get: operations["getAuthenticatedCustomer"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/{customer_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a customer by ID
         * @description Returns details about a customer by their ID.
         */
        get: operations["getCustomerById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/api-keys": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all API keys for a customer */
        get: operations["listCustomerAPIKeys"];
        put?: never;
        /** Create a new API key for a customer */
        post: operations["createCustomerAPIKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/api-keys/{api_key_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete an API key for a customer */
        delete: operations["deleteCustomerAPIKey"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/credit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Initiates a Credit Purchase. */
        post: operations["InitiateCreditPurchase"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/billing": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Access customer billing portal
         * @description Creates a session for the customer to access their billing portal where they can manage subscriptions, payment methods, and view invoices.
         */
        post: operations["AccessBillingPortal"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/cloud-subscription-checkout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create cloud subscription checkout session
         * @description Creates a cloud subscription checkout session for $20/month with automatic billing
         */
        post: operations["createCloudSubscriptionCheckout"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/cloud-subscription-checkout/{tier}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create cloud subscription checkout session for a specific tier
         * @description Creates a cloud subscription checkout session for a specific subscription tier (standard, creator, or pro) with automatic billing
         */
        post: operations["createCloudSubscriptionCheckoutTier"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/cloud-subscription-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Check cloud subscription status
         * @description Check if the customer has an active cloud subscription
         */
        get: operations["GetCloudSubscriptionStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/verify-api-key": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Verify a ComfyUI API key and return customer details
         * @description Validates a ComfyUI API key and returns the associated customer information.
         *     This endpoint is used by cloud.comfy.org to authenticate users via API keys
         *     instead of Firebase tokens.
         */
        post: operations["VerifyApiKey"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/customers/{customer_id}/cloud-subscription-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Admin check cloud subscription status
         * @description Allows an admin to inspect a specific customer's cloud subscription status.
         */
        get: operations["GetAdminCustomerCloudSubscriptionStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/usage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Get customer's usage
         * @description Returns the customer's as a dashboard URL.
         */
        post: operations["GetCustomerUsage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/balance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get customer's remaining balance
         * @description Returns the customer's current remaining balance in microamount and its currency, with separate breakdowns for prepaid commits and cloud credits.
         */
        get: operations["GetCustomerBalance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/{customer_id}/balance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get customer's remaining balance by ID
         * @description Returns the specified customer's current remaining balance in microamount and its currency, with separate breakdowns for prepaid commits and cloud credits.
         */
        get: operations["GetCustomerBalanceById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/{customer_id}/usage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Track usage for a customer (Admin only)
         * @description Manually track usage for a customer in Metronome. This endpoint is for admin use to record usage events.
         */
        post: operations["TrackCustomerUsage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/storage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Store a resource for a customer
         * @description Store a resource for a customer. Resource will have a 24 hour expiry. The signed URL will be generated for the specified file path.
         */
        post: operations["createCustomerStorageResource"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/{customer_id}/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get events related to customer */
        get: operations["GetCustomerEventsById"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get events related to customer */
        get: operations["GetCustomerEvents"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/upload-artifact": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Receive artifacts (output files) from the ComfyUI GitHub Action
         * @description Receive artifacts (output files) from the ComfyUI GitHub Action
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": {
                        /** @description Repository name */
                        repo: string;
                        /** @description Unique identifier for the job */
                        job_id: string;
                        /** @description Unique identifier for the run */
                        run_id: string;
                        /** @description Operating system used in the run */
                        os: string;
                        /** @description Cuda version. */
                        cuda_version?: string;
                        /** @description The name of the bucket where the output files are stored */
                        bucket_name?: string;
                        /** @description A comma separated string that contains GCS path(s) to output files. eg. gs://bucket-name/output, gs://bucket-name/output2 */
                        output_files_gcs_paths?: string;
                        /** @description The path to ComfyUI logs. eg. gs://bucket-name/logs */
                        comfy_logs_gcs_path?: string;
                        /** @description The flags used in the comfy run */
                        comfy_run_flags?: string;
                        commit_hash: string;
                        /** @description The time of the commit in the format of "YYYY-MM-DDTHH:MM:SSZ" (2016-10-10T00:00:00Z) */
                        commit_time: string;
                        /** @description The commit message */
                        commit_message: string;
                        /** @description The name of the workflow */
                        workflow_name: string;
                        branch_name: string;
                        /**
                         * Format: int64
                         * @description The start time of the job as a Unix timestamp.
                         */
                        start_time: number;
                        /**
                         * Format: int64
                         * @description The end time of the job as a Unix timestamp.
                         */
                        end_time: number;
                        /** @description The average amount of VRAM used in the run. */
                        avg_vram?: number;
                        /** @description The peak amount of VRAM used in the run. */
                        peak_vram?: number;
                        /** @description The pull request number */
                        pr_number: string;
                        /** @description The author of the commit */
                        author: string;
                        /** @description The user who triggered the job */
                        job_trigger_user: string;
                        /** @description The python version used in the run */
                        python_version: string;
                        /** @description The pytorch version used in the run */
                        pytorch_version?: string;
                        machine_stats?: components["schemas"]["MachineStats"];
                        status: components["schemas"]["WorkflowRunStatus"];
                    };
                };
            };
            responses: {
                /** @description Successfully received the artifact details */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            message?: string;
                        };
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gitcommit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve CI data for a given commit
         * @description Returns all runs, jobs, job results, and storage files associated with a given commit.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The ID of the commit to fetch data for. */
                    commitId?: string;
                    /** @description The operating system to filter the CI data by. */
                    operatingSystem?: string;
                    /** @description The name of the workflow to filter the CI data by. */
                    workflowName?: string;
                    /** @description The branch of the gitcommit to filter the CI data by. */
                    branch?: string;
                    /** @description The page number to retrieve. */
                    page?: number;
                    /** @description The number of items to include per page. */
                    pageSize?: number;
                    /** @description The repo to filter by. */
                    repoName?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An object containing runs, jobs, job results, and storage files */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            jobResults?: components["schemas"]["ActionJobResult"][];
                            totalNumberOfPages?: number;
                        };
                    };
                };
                /** @description Commit not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gitcommitsummary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a summary of git commits
         * @description Returns a summary of git commits, including status, start time, and end time.
         */
        get: {
            parameters: {
                query?: {
                    /** @description The repository name to filter the git commits by. */
                    repoName?: string;
                    /** @description The branch name to filter the git commits by. */
                    branchName?: string;
                    /** @description The page number to retrieve. */
                    page?: number;
                    /** @description The number of items to include per page. */
                    pageSize?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully retrieved git commit summaries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            commitSummaries?: components["schemas"]["GitCommitSummary"][];
                            totalNumberOfPages?: number;
                        };
                    };
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            message?: string;
                        };
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/workflowresult/{workflowResultId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve a specific commit by ID */
        get: operations["getWorkflowResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/branch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve all distinct branches for a given repo
         * @description Returns all branches for a given repo.
         */
        get: {
            parameters: {
                query: {
                    /** @description The repo to filter by. */
                    repo_name: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description An array of branches */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            branches?: string[];
                        };
                    };
                };
                /** @description Repo not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/publishers/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve all publishers for a given user */
        get: operations["listPublishersForUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve permissions the user has for a given publisher */
        get: operations["getPermissionOnPublisher"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Validate if a publisher username is available
         * @description Checks if the publisher username is already taken.
         */
        get: operations["validatePublisher"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve all publishers */
        get: operations["listPublishers"];
        put?: never;
        /** Create a new publisher */
        post: operations["createPublisher"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve a publisher by ID */
        get: operations["getPublisher"];
        /** Update a publisher */
        put: operations["updatePublisher"];
        post?: never;
        /** Delete a publisher */
        delete: operations["deletePublisher"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/ban": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Ban a publisher */
        post: operations["BanPublisher"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/{nodeId}/claim-my-node": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Claim nodeId into publisherId for the authenticated publisher
         * @description This endpoint allows a publisher to claim an unclaimed node that they own the repo, which is identified by the nodeId. The unclaimed node's repository must be owned by the authenticated user.
         */
        post: operations["claimMyNode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/v2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve all nodes */
        get: operations["listNodesForPublisherV2"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve all nodes */
        get: operations["listNodesForPublisher"];
        put?: never;
        /** Create a new custom node */
        post: operations["createNode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/{nodeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Update a specific node */
        put: operations["updateNode"];
        post?: never;
        /** Delete a specific node */
        delete: operations["deleteNode"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/{nodeId}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve permissions the user has for a given publisher */
        get: operations["getPermissionOnPublisherNodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/{nodeId}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Publish a new version of a node */
        post: operations["publishNodeVersion"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/{nodeId}/versions/{versionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Update changelog and deprecation status of a node version
         * @description Update only the changelog and deprecated status of a specific version of a node.
         */
        put: operations["updateNodeVersion"];
        post?: never;
        /** Unpublish (delete) a specific version of a node */
        delete: operations["deleteNodeVersion"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/nodes/{nodeId}/ban": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Ban a publisher's Node */
        post: operations["BanPublisherNode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/tokens": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve all personal access tokens for a publisher */
        get: operations["listPersonalAccessTokens"];
        put?: never;
        /** Create a new personal access token */
        post: operations["createPersonalAccessToken"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/publishers/{publisherId}/tokens/{tokenId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a specific personal access token */
        delete: operations["deletePersonalAccessToken"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieves a list of nodes
         * @description Returns a paginated list of nodes across all publishers.
         */
        get: operations["searchNodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/reindex": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reindex all nodes for searching. */
        post: operations["reindexNodes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/update-github-stars": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Update GitHub stars for nodes */
        post: operations["updateGithubStars"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieves a list of nodes
         * @description Returns a paginated list of nodes across all publishers.
         */
        get: operations["listAllNodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comfy-nodes/{comfyNodeName}/node": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a node by ComfyUI node name
         * @description Returns the node that contains a ComfyUI node with the specified name
         */
        get: operations["getNodeByComfyNodeName"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a specific node by ID
         * @description Returns the details of a specific node.
         */
        get: operations["getNode"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/reviews": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Add review to a specific version of a node */
        post: operations["postNodeReview"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/install": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a node version to be installed.
         * @description Retrieves the node data for installation, either the latest or a specific version.
         */
        get: operations["installNode"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/translations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Node Translations */
        post: operations["CreateNodeTranslations"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all versions of a node */
        get: operations["listNodeVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/versions/{versionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve a specific version of a node */
        get: operations["getNodeVersion"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/bulk/nodes/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Retrieve multiple node versions in a single request */
        post: operations["getBulkNodeVersions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List all node versions given some filters. */
        get: operations["listAllNodeVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a new custom node using admin priviledge */
        post: operations["adminCreateNode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/nodes/{nodeId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Admin Update Node
         * @description Only admins can update a node with admin privileges.
         */
        put: operations["adminUpdateNode"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/admin/nodes/{nodeId}/versions/{versionNumber}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Admin Update Node Version Status
         * @description Only admins can approve a node version.
         */
        put: operations["adminUpdateNodeVersion"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/admin/coupons": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all coupons
         * @description Retrieves a list of all coupons from Stripe. Only admins can list coupons.
         */
        get: operations["listCoupons"];
        put?: never;
        /**
         * Create a new Stripe coupon
         * @description Creates a new coupon in Stripe. Only admins can create coupons.
         */
        post: operations["createCoupon"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/admin/coupons/{coupon_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a specific coupon
         * @description Retrieves details of a specific coupon from Stripe. Only admins can view coupons.
         */
        get: operations["getCoupon"];
        put?: never;
        post?: never;
        /**
         * Delete a coupon
         * @description Deletes a coupon in Stripe. Only admins can delete coupons.
         */
        delete: operations["deleteCoupon"];
        options?: never;
        head?: never;
        /**
         * Update a coupon
         * @description Updates a coupon in Stripe. Only admins can update coupons.
         */
        patch: operations["updateCoupon"];
        trace?: never;
    };
    "/customers/admin/promo-codes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all promotional codes
         * @description Retrieves a list of all promotional codes from Stripe. Only admins can list promo codes.
         */
        get: operations["listPromoCodes"];
        put?: never;
        /**
         * Generate a new Stripe promotional code
         * @description Creates a new unique promotional code in Stripe for the specified coupon. Only admins can generate promo codes.
         */
        post: operations["createPromoCode"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customers/admin/promo-codes/{promo_code_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a specific promotional code
         * @description Retrieves details of a specific promotional code from Stripe. Only admins can view promo codes.
         */
        get: operations["getPromoCode"];
        put?: never;
        post?: never;
        /**
         * Deactivate a promotional code
         * @description Deactivates a promotional code in Stripe. Only admins can deactivate promo codes.
         */
        delete: operations["deletePromoCode"];
        options?: never;
        head?: never;
        /**
         * Update a promotional code
         * @description Updates a promotional code in Stripe. Only admins can update promo codes.
         */
        patch: operations["updatePromoCode"];
        trace?: never;
    };
    "/releases": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get release notes
         * @description Fetch release notes from Strapi with caching
         */
        get: operations["getReleaseNotes"];
        put?: never;
        /**
         * Process Github release webhook
         * @description Webhook endpoint to process Github release events and generate release notes
         */
        post: operations["processReleaseWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/security-scan": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Security Scan
         * @description Pull all pending node versions and conduct security scans.
         */
        get: operations["securityScan"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/versions/{version}/comfy-nodes": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                version: string;
            };
            cookie?: never;
        };
        /** list comfy-nodes for node version */
        get: operations["ListComfyNodes"];
        put?: never;
        /** create comfy-nodes for certain node */
        post: operations["CreateComfyNodes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/nodes/{nodeId}/versions/{version}/comfy-nodes/{comfyNodeName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** get specify comfy-node based on its id */
        get: operations["GetComfyNode"];
        /** Update a specific comfy-node */
        put: operations["UpdateComfyNode"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comfy-nodes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** list all comfy-nodes */
        get: operations["ListAllComfyNodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/comfy-nodes/backfill": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** trigger comfy nodes backfill */
        post: operations["ComfyNodesBackfill"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/dummy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Dummy proxy
         * @description Dummy proxy endpoint that returns a simple string
         */
        post: operations["dummyProxy"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/minimax/video_generation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to Minimax for video generation
         * @description Forwards video generation requests to Minimax's API and returns the task ID for asynchronous processing.
         */
        post: operations["minimaxVideoGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/minimax/query/video_generation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Query status of a Minimax video generation task
         * @description Proxies a request to Minimax to check the status of a video generation task
         */
        get: operations["getMinimaxVideoGeneration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/minimax/files/retrieve": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Retrieve download URL for a Minimax file
         * @description Proxies a request to Minimax to get the download URL for a file
         */
        post: operations["retrieveMinimaxFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ideogram/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to Ideogram for image generation
         * @description Forwards image generation requests to Ideogram's API and returns the results.
         */
        post: operations["ideogramGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ideogram/ideogram-v3/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to Ideogram for image generation
         * @description Forwards image generation requests to Ideogram's API and returns the results.
         */
        post: operations["ideogramV3Generate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ideogram/ideogram-v3/edit": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to Ideogram for image editing
         * @description Forwards image editing requests to Ideogram's API and returns the results.
         */
        post: operations["ideogramV3Edit"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ideogram/ideogram-v3/remix": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Remix an image using a prompt */
        post: operations["ideogramV3Remix"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ideogram/ideogram-v3/reframe": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reframe an image to a chosen resolution */
        post: operations["ideogramV3Reframe"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ideogram/ideogram-v3/replace-background": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Replace background of an image using a prompt */
        post: operations["ideogramV3ReplaceBackground"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/account/costs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Resource Package Information */
        get: operations["klingQueryResourcePackages"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/text2video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Task List */
        get: operations["klingText2VideoQueryTaskList"];
        put?: never;
        /** KlingAI Create Video from Text */
        post: operations["klingCreateVideoFromText"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/text2video/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Task */
        get: operations["klingText2VideoQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/image2video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Image2Video Task List */
        get: operations["klingImage2VideoQueryTaskList"];
        put?: never;
        /** KlingAI Create Video from Image */
        post: operations["klingCreateVideoFromImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/image2video/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Image2Video Task */
        get: operations["klingImage2VideoQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/video-extend": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Video-Extend Task List */
        get: operations["klingVideoExtendQueryTaskList"];
        put?: never;
        /** KlingAI Extend Video Duration */
        post: operations["klingExtendVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/video-extend/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Video-Extend Task */
        get: operations["klingVideoExtendQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/lip-sync": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Lip-Sync Task List */
        get: operations["klingLipSyncQueryTaskList"];
        put?: never;
        /** KlingAI Create Lip-Sync Video */
        post: operations["klingCreateLipSyncVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/lip-sync/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Lip-Sync Task */
        get: operations["klingLipSyncQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/effects": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Video Effects Task List */
        get: operations["klingVideoEffectsQueryTaskList"];
        put?: never;
        /** KlingAI Create Video Effects Task */
        post: operations["klingCreateVideoEffects"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/effects/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Video Effects Task */
        get: operations["klingVideoEffectsQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/omni-video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** KlingAI Create Omni-Video Task */
        post: operations["klingCreateOmniVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/videos/omni-video/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Omni-Video Task */
        get: operations["klingOmniVideoQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/images/generations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Image Generation Task List */
        get: operations["klingImageGenerationsQueryTaskList"];
        put?: never;
        /** KlingAI Create Image Generation Task */
        post: operations["klingCreateImageGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/images/generations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Image Generation Task */
        get: operations["klingImageGenerationsQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/images/omni-image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** KlingAI Create Omni-Image Task */
        post: operations["klingCreateOmniImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/images/omni-image/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Omni-Image Task */
        get: operations["klingOmniImageQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/images/kolors-virtual-try-on": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Virtual Try-On Task List */
        get: operations["klingVirtualTryOnQueryTaskList"];
        put?: never;
        /** KlingAI Create Virtual Try-On Task */
        post: operations["klingCreateVirtualTryOn"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/kling/v1/images/kolors-virtual-try-on/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** KlingAI Query Single Virtual Try-On Task */
        get: operations["klingVirtualTryOnQuerySingleTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ltx/v1/text-to-video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * LTX Video Generate Video from Text
         * @description Generate a video from a text prompt using LTX Video AI models
         */
        post: operations["ltxCreateVideoFromText"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/ltx/v1/image-to-video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * LTX Video Generate Video from Image
         * @description Transform a static image into a dynamic video using LTX Video AI models
         */
        post: operations["ltxCreateVideoFromImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-kontext-pro/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to BFL Flux Kontext Pro for image editing
         * @description Forwards image editing requests to BFL's Flux Kontext Pro API and returns the results.
         */
        post: operations["bflFluxKontextProGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-kontext-max/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to BFL Flux Kontext Max for image editing
         * @description Forwards image editing requests to BFL's Flux Kontext Max API and returns the results.
         */
        post: operations["bflFluxKontextMaxGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-pro-1.1/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to BFL Flux Pro 1.1 for image generation
         * @description Forwards image generation requests to BFL's Flux Pro 1.1 API and returns the results.
         */
        post: operations["bflFluxPro1_1Generate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-pro-1.1-ultra/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to BFL Flux Pro 1.1 Ultra for image generation
         * @description Forwards image generation requests to BFL's Flux Pro 1.1 Ultra API and returns the results.
         */
        post: operations["bflFluxProGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-2-pro/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to BFL Flux 2 Pro for image generation
         * @description Forwards image generation requests to BFL's Flux 2 Pro API and returns the results. Supports image-to-image generation with up to 5 input images.
         */
        post: operations["bflFlux2ProGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-2-max/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to BFL Flux 2 Max for image generation
         * @description Forwards image generation requests to BFL's Flux 2 Max API and returns the results. Supports image-to-image generation with up to 8 input images.
         */
        post: operations["bflFlux2MaxGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-pro-1.0-expand/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Expand an image by adding pixels on any side.
         * @description Submits an image expansion task that adds the specified number of pixels to any combination of sides (top, bottom, left, right) while maintaining context.
         */
        post: operations["BFLExpand_v1_flux_pro_1_0_expand_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-pro-1.0-fill/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate an image with FLUX.1 Fill [pro] using an input image and mask.
         * @description Submits an image generation task with the FLUX.1 Fill [pro] model using an input image and mask. Mask can be applied to alpha channel or submitted as a separate image.
         */
        post: operations["BFLFill_v1_flux_pro_1_0_fill_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-pro-1.0-canny/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate an image with FLUX.1 Canny [pro] using a control image.
         * @description Submits an image generation task with FLUX.1 Canny [pro].
         */
        post: operations["BFLPro_canny_v1_flux_pro_1_0_canny_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/bfl/flux-pro-1.0-depth/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate an image with FLUX.1 Depth [pro] using a control image.
         * @description Submits an image generation task with FLUX.1 Depth [pro].
         */
        post: operations["BFLPro_depth_v1_flux_pro_1_0_depth_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/luma/generations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create a generation
         * @description Initiate a new generation with the provided prompt
         */
        post: operations["lumaCreateGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/luma/generations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get a generation
         * @description Retrieve details of a specific generation by its ID
         */
        get: operations["lumaGetGeneration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/luma/generations/image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate an image
         * @description Generate an image with the provided prompt
         */
        post: operations["lumaGenerateImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pixverse/video/text/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate video from text prompt. */
        post: operations["PixverseGenerateTextVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pixverse/video/img/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate video from image. */
        post: operations["PixverseGenerateImageVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pixverse/video/transition/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate transition video between two images. */
        post: operations["PixverseGenerateTransitionVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pixverse/image/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Upload an image to the server. */
        post: operations["PixverseUploadImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pixverse/video/result/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the result of a video generation. */
        get: operations["PixverseGetVideoResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook/metronome/zero-balance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** receive alert on remaining balance is 0 */
        post: operations["metronomeZeroBalance"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook/stripe/invoice-status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Handle Stripe invoice.paid webhook event */
        post: operations["StripeInvoiceStatus"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/webhook/stripe/subscription": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Handle Stripe subscription webhook events */
        post: operations["StripeSubscriptionWebhook"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/image_generation": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Proxy request to Recraft for image generation
         * @description Forwards image generation requests to Recraft's API and returns the generated images.
         */
        post: operations["recraftImageGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/vectorize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Vectorize an image */
        post: operations["recraftVectorize"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/crispUpscale": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Upscale an image */
        post: operations["recraftCrispUpscale"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/removeBackground": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Remove background from an image */
        post: operations["recraftRemoveBackground"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/imageToImage": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate image from image and prompt */
        post: operations["RecraftImageToImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/inpaint": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Inpaint Image */
        post: operations["RecraftInpaintImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/replaceBackground": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Replace Background */
        post: operations["RecraftReplaceBackground"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/recraft/images/creativeUpscale": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Creative Upscale */
        post: operations["RecraftCreativeUpscale"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/runway/image_to_video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Runway Image to Video Generation
         * @description Converts an image to a video using Runway's API
         */
        post: operations["runwayImageToVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/runway/tasks/{task_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Runway Task Status
         * @description Get the status and output of a Runway task
         */
        get: operations["runwayGetTaskStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/runway/text_to_image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Runway Text to Image Generation
         * @description Generates an image from text using Runway's API
         */
        post: operations["runwayTextToImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/veo/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate a video from a text prompt and optional image. Deprecated. Use /proxy/veo/{modelId}/generate instead. */
        post: operations["veoGenerate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/veo/poll": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Poll the status of a Veo prediction operation. Deprecated. Use /proxy/veo/{modelId}/generate instead. */
        post: operations["veoPoll"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/veo/{modelId}/generate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate a video from a text prompt and optional image */
        post: operations["veoGenerateNew"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/veo/{modelId}/poll": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Poll the status of a Veo prediction operation */
        post: operations["veoPollNew"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/v1/responses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["createOpenAIResponse"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/v1/responses/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieves a model response with the given ID. */
        get: operations["getOpenAIResponse"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/images/generations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate an image using OpenAI's models */
        post: operations["openAIGenerateImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/images/edits": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Edit an image using OpenAI's DALL-E model */
        post: operations["openAIEditImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/v1/videos": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a video using OpenAI's Sora model */
        post: operations["openAICreateVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/v1/videos/{video_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve a video */
        get: operations["openAIGetVideo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/openai/v1/videos/{video_id}/content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Download video content */
        get: operations["openAIDownloadVideoContent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/pikadditions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate Pikadditions */
        post: operations["PikaGenerate_pikadditions_generate_pikadditions_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/pikaswaps": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Pikaswaps
         * @description Exactly one of `modifyRegionMask` and `modifyRegionRoi` must be provided.
         */
        post: operations["PikaGenerate_pikaswaps_generate_pikaswaps_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/pikaffects": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Generate Pikaffects
         * @description Generate a video with a specific Pikaffect. Supported Pikaffects: Cake-ify, Crumble, Crush, Decapitate, Deflate, Dissolve, Explode, Eye-pop, Inflate, Levitate, Melt, Peel, Poke, Squish, Ta-da, Tear
         */
        post: operations["PikaGenerate_pikaffects_generate_pikaffects_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/2.2/t2v": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate 2 2 T2V */
        post: operations["PikaGenerate_2_2_t2v_generate_2_2_t2v_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/2.2/pikaframes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate 2 2 Keyframe */
        post: operations["PikaGenerate_2_2_keyframe_generate_2_2_pikaframes_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/2.2/pikascenes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate 2 2 C2V */
        post: operations["PikaGenerate_2_2_c2v_generate_2_2_pikascenes_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/generate/2.2/i2v": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate 2 2 I2V */
        post: operations["PikaGenerate_2_2_i2v_generate_2_2_i2v_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/pika/videos/{video_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Video */
        get: operations["PikaGet_video_videos__video_id__get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/stable-image/generate/ultra": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stable Image Ultra
         * @description Our most advanced text to image generation service, Stable Image Ultra creates the highest quality images with unprecedented prompt understanding. Ultra excels in typography, complex compositions, dynamic lighting, vibrant hues, and overall cohesion and structure of an art piece. Made from the most advanced models, including Stable Diffusion 3.5, Ultra offers the best of the Stable Diffusion ecosystem. ### Try it out Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=yXhs626oZdr1) ### How to use Please invoke this endpoint with a `POST` request. The headers of the request must include an API key in the `authorization` field. The body of the request must be `multipart/form-data`.  The accept header should be set to one of the following: - `image/*` to receive the image in the format specified by the `output_format` parameter. - `application/json` to receive the image in the format specified by the `output_format` parameter, but encoded to base64 in a JSON response. The only required parameter is the `prompt` field, which should contain the text prompt for the image generation. The body of the request should include: - `prompt` - text to generate the image from The body may optionally include: - `image` - the image to use as the starting point for the generation - `strength` - controls how much influence the `image` parameter has on the output image - `aspect_ratio` - the aspect ratio of the output image - `negative_prompt` - keywords of what you **do not** wish to see in the output image - `seed` - the randomness seed to use for the generation - `output_format` - the the format of the output image > **Note:** for the full list of optional parameters, please see the request schema below. ### Output The resolution of the generated image will be 1 megapixel. The default resolution is 1024x1024. ### Credits The Ultra service uses 8 credits per successful result. You will not be charged for failed results.
         */
        post: operations["StabilityImageGenrationUltra"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/stable-image/generate/sd3": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stable Diffusion 3.5
         * @description Generate using Stable Diffusion 3.5 models, Stability AI latest base model:
         *
         *     - **Stable Diffusion 3.5 Large**: At 8 billion parameters, with superior quality and
         *
         *
         *
         *       prompt adherence, this base model is the most powerful in the Stable Diffusion
         *       family. This model is ideal for professional use cases at 1 megapixel resolution.
         *
         *     - **Stable Diffusion 3.5 Large Turbo**: A distilled version of Stable Diffusion 3.5 Large.
         *
         *
         *
         *       SD3.5 Large Turbo generates high-quality images with exceptional prompt adherence
         *       in just 4 steps, making it considerably faster than Stable Diffusion 3.5 Large.
         *
         *     - **Stable Diffusion 3.5 Medium**: With 2.5 billion parameters, the model delivers an
         *
         *
         *
         *       optimal balance between prompt accuracy and image quality, making it an efficient
         *       choice for fast high-performance image generation.
         *
         *     Read more about the model capabilities [here](https://stability.ai/news/introducing-stable-diffusion-3-5).
         *
         *     As of April 17, 2025, we have deprecated the Stable Diffusion 3.0 APIs and will be automatically
         *     re-routing calls to Stable Diffusion 3.0 models to Stable Diffusion 3.5 APIs at no extra cost.
         *     You can read more in the [release notes](/docs/release-notes#api-deprecation-notice).
         *
         *     ### Try it out
         *     Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/SD3_API.ipynb)
         *
         *     ### How to use
         *     Please invoke this endpoint with a `POST` request.
         *
         *     The headers of the request must include an API key in the `authorization` field. The body of the request must be
         *     `multipart/form-data`.  The accept header should be set to one of the following:
         *     - `image/*` to receive the image in the format specified by the `output_format` parameter.
         *     - `application/json` to receive the image encoded as base64 in a JSON response.
         *
         *     #### **Generating with a prompt**
         *     Commonly referred to as **text-to-image**, this mode generates an image from text alone. While the only required
         *     parameter is the `prompt`, it also supports an `aspect_ratio` parameter which can be used to control the
         *     aspect ratio of the generated image.
         *
         *     #### **Generating with a prompt *and* an image**
         *     Commonly referred to as **image-to-image**, this mode also generates an image from text but uses an existing image as the
         *     starting point. The required parameters are:
         *     - `prompt` - text to generate the image from
         *     - `image` - the image to use as the starting point for the generation
         *     - `strength` - controls how much influence the `image` parameter has on the output image
         *     - `mode` - must be set to `image-to-image`
         *
         *     > **Note:** maximum request size is 10MiB.
         *
         *     #### **Optional Parameters:**
         *     Both modes support the following optional parameters:
         *     - `model` - the model to use (SD3.5 Large, SD3.5 Large Turbo, SD3.5 Medium)
         *     - `output_format` - the the format of the output image
         *     - `seed` - the randomness seed to use for the generation
         *     - `negative_prompt` - keywords of what you **do not** wish to see in the output image
         *     - `cfg_scale` - controls how strictly the diffusion process adheres to the prompt text
         *     - `style_preset` - guides the image model towards a particular style
         *
         *     > **Note:** for more details about these parameters please see the request schema below.
         *
         *     ### Output
         *     The resolution of the generated image will be 1MP. The default resolution is 1024x1024.
         *
         *     ### Credits
         *     - **SD 3.5 Large**: Flat rate of 6.5 credits per successful generation.
         *     - **SD 3.5 Large Turbo**: Flat rate of 4 credits per successful generation.
         *     - **SD 3.5 Medium**: Flat rate of 3.5 credits per successful generation.
         *
         *     As always, you will not be charged for failed generations.
         */
        post: operations["StabilityImageGenrationSD3"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/stable-image/upscale/conservative": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Conservative
         * @description Takes images between 64x64 and 1 megapixel and upscales them all the way to 4K resolution. Put more generally, it can upscale images ~20-40x times while preserving all aspects. Conservative Upscale minimizes alterations to the image and should not be used to reimagine an image.
         *
         *     ### Try it out
         *     Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=t1Q4w2uvvza0)
         *
         *     ### How to use
         *
         *     Please invoke this endpoint with a `POST` request.
         *
         *     The headers of the request must include an API key in the `authorization` field. The body of the request must be
         *     `multipart/form-data`, and the `accept` header should be set to one of the following:
         *
         *
         *
         *       - `image/*` to receive the image in the format specified by the `output_format` parameter.
         *       - `application/json` to receive the image encoded as base64 in a JSON response.
         *
         *     The body of the request must include:
         *     - `image`
         *     - `prompt`
         *
         *     Optionally, the body of the request may also include:
         *     - `negative_prompt`
         *     - `seed`
         *     - `output_format`
         *     - `creativity`
         *
         *     > **Note:** for more details about these parameters please see the request schema below.
         *
         *     ### Output
         *     The resolution of the generated image will be 4 megapixels.
         *
         *     ### Credits
         *     Flat rate of 25 credits per successful generation.  You will not be charged for failed generations.
         */
        post: operations["StabilityImageGenrationUpscaleConservative"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/stable-image/upscale/creative": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Creative Upscale (async)
         * @description Takes images between 64x64 and 1 megapixel and upscales them all the way to **4K** resolution.  Put more
         *     generally, it can upscale images ~20-40x times while preserving, and often enhancing, quality.
         *     Creative Upscale **works best on highly degraded images and is not for photos of 1mp or above** as it performs
         *     heavy reimagining (controlled by creativity scale).
         *
         *     ### Try it out
         *     Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=QXxi9tfI425t)
         *
         *
         *     ### How to use
         *     Please invoke this endpoint with a `POST` request.
         *
         *     The headers of the request must include an API key in the `authorization` field. The body of the request must be
         *     `multipart/form-data`.
         *
         *     The body of the request should include:
         *     - `image`
         *     - `prompt`
         *
         *     The body may optionally include:
         *     - `seed`
         *     - `negative_prompt`
         *     - `output_format`
         *     - `creativity`
         *     - `style_preset`
         *
         *     > **Note:** for more details about these parameters please see the request schema below.
         *
         *     ### Results
         *     After invoking this endpoint with the required parameters, use the `id` in the response to poll for results at the
         *     [results/{id} endpoint](#tag/Results/paths/~1v2beta~1results~1%7Bid%7D/get).  Rate-limiting or other errors may occur if you poll more than once every 10 seconds.
         *
         *     ### Credits
         *     Flat rate of 25 credits per successful generation.  You will not be charged for failed generations.
         */
        post: operations["StabilityImageGenrationUpscaleCreative"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/stable-image/upscale/fast": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Fast
         * @description Our Fast Upscaler service enhances image resolution by 4x using predictive and generative AI. This lightweight and fast service (processing in ~1 second) is ideal for enhancing the quality of compressed images, making it suitable for social media posts and other applications.
         *
         *     ### Try it out
         *     Grab your [API key](https://platform.stability.ai/account/keys) and head over to [![Open Google Colab](https://platform.stability.ai/svg/google-colab.svg)](https://colab.research.google.com/github/stability-ai/stability-sdk/blob/main/nbs/Stable_Image_API_Public.ipynb#scrollTo=t1Q4w2uvvza0)
         *
         *     ### How to use
         *
         *     Please invoke this endpoint with a `POST` request.
         *
         *     The headers of the request must include an API key in the `authorization` field. The body of the request must be
         *     `multipart/form-data`, and the `accept` header should be set to one of the following:
         *
         *
         *
         *       - `image/*` to receive the image in the format specified by the `output_format` parameter.
         *       - `application/json` to receive the image encoded as base64 in a JSON response.
         *
         *     The body of the request must include:
         *     - `image`
         *
         *     Optionally, the body of the request may also include:
         *     - `output_format`
         *
         *     > **Note:** for more details about these parameters please see the request schema below.
         *
         *     ### Output
         *     The resolution of the generated image is 4 times that of the input image with a maximum size of 16 megapixels.
         *
         *     ### Credits
         *     Flat rate of 1 credit per successful generation. You will not be charged for failed generations.
         */
        post: operations["StabilityImageGenerationUpscaleFast"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/results/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Result
         * @description Get the result of a generation
         */
        get: operations["StabilityGetResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/audio/stable-audio-2/text-to-audio": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Proxy request to Stable Audio 2.5 for text-to-audio generation */
        post: operations["stableAudio25TextToAudio"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/audio/stable-audio-2/audio-to-audio": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Proxy request to Stable Audio for audio-to-audio transformation */
        post: operations["stableAudio25AudioToAudio"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/stability/v2beta/audio/stable-audio-2/inpaint": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Proxy request to Stable Audio 2.5 for audio inpainting */
        post: operations["stableAudio25Inpaint"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vertexai/gemini/{model}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate content using a specified model. */
        post: operations["GeminiGenerateContent"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vertexai/imagen/{model}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description image generation model */
                model: "imagen-3.0-generate-002" | "imagen-3.0-generate-001" | "imagen-3.0-fast-generate-001" | "imagegeneration@006" | "imagegeneration@005" | "imagegeneration@002";
            };
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Generate images from a text prompt */
        post: operations["ImagenGenerateImages"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/tripo/v2/openapi/task/{task_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Task Status */
        get: operations["tripoGetTask"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/tripo/v2/openapi/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Upload File for 3D Generation */
        post: operations["tripoUploadFile"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/tripo/v2/openapi/task": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create 3D Generation Task */
        post: operations["tripoCreateTask"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/tripo/v2/openapi/user/balance": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Query Account Balance */
        get: operations["tripoGetBalance"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/rodin/api/v2/rodin": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create 3D generate Task using Rodin API. */
        post: operations["rodinGenerate3DAsset"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/rodin/api/v2/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Check Rodin 3D Generate Status. */
        post: operations["rodinCheckStatus"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/rodin/api/v2/download": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Get rodin 3D Assets download list. */
        post: operations["rodinDownload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/prompts/{prompt_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get Prompt Details */
        get: operations["MoonvalleyGetPrompt"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/prompts/text-to-video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Text to Video Prompt */
        post: operations["MoonvalleyTextToVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/prompts/text-to-image": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Text to Image Prompt */
        post: operations["MoonvalleyTextToImage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/prompts/image-to-video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Image to Video Prompt */
        post: operations["MoonvalleyImageToVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/prompts/video-to-video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create Video to Video Prompt */
        post: operations["MoonvalleyVideoToVideo"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/prompts/video-to-video/resize": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Resize a video */
        post: operations["MoonvalleyVideoToVideoResize"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/moonvalley/uploads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Upload Files */
        post: operations["MoonvalleyUpload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vidu/img2video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["ViduImg2Video"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vidu/reference2video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["ViduReference2Video"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vidu/start-end2video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["ViduStartEnd2Video"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vidu/text2video": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["ViduText2Video"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/vidu/tasks/{id}/creations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["ViduGetCreations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/byteplus/api/v3/images/generations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["byteplusImageGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/byteplus/api/v3/contents/generations/tasks": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["byteplusVideoGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/byteplus/api/v3/contents/generations/tasks/{task_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["byteplusVideoGenerationQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/wan/api/v1/services/aigc/video-generation/video-synthesis": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["wanVideoGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/wan/api/v1/services/aigc/text2image/image-synthesis": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["wanImageGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/wan/api/v1/services/aigc/image2image/image-synthesis": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["wanImage2ImageGeneration"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/wan/api/v1/tasks/{task_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["wanTaskQueryProxy"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/topaz/image/v1/enhance-gen/async": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["topazEnhanceGenAsync"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/topaz/image/v1/status/{process_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["topazGetStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/topaz/image/v1/download/{process_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["topazDownloadResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/topaz/video/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post: operations["topazVideoCreate"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/proxy/topaz/video/{request_id}/accept": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch: operations["topazVideoAccept"];
        trace?: never;
    };
    "/proxy/topaz/video/{request_id}/complete-upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Complete Video Upload
         * @description Send metadata of the multi-part uploads to complete the upload and begin processing the video.
         *
         *     Optionally include the MD5 hash of the source video file to validate successful upload before processing.
         */
        patch: operations["topazVideoCompleteUpload"];
        trace?: never;
    };
    "/proxy/topaz/video/{request_id}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get: operations["topazVideoGetStatus"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/features": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get server feature flags
         * @description Returns the server's feature capabilities
         */
        get: operations["getFeatures"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description The subscription tier level
         * @enum {string}
         */
        SubscriptionTier: "STANDARD" | "CREATOR" | "PRO" | "FOUNDERS_EDITION";
        /**
         * @description The subscription billing duration
         * @enum {string}
         */
        SubscriptionDuration: "MONTHLY" | "ANNUAL";
        FeaturesResponse: {
            /**
             * @description The conversion rate for partner nodes
             * @example 0.5
             */
            partner_node_conversion_rate: number;
        };
        ClaimMyNodeRequest: {
            /** @description GitHub token to verify if the user owns the repo of the node */
            GH_TOKEN: string;
        };
        BulkNodeVersionsRequest: {
            /** @description List of node ID and version pairs to retrieve */
            node_versions: components["schemas"]["NodeVersionIdentifier"][];
        };
        NodeVersionIdentifier: {
            /** @description The unique identifier of the node */
            node_id: string;
            /** @description The version of the node */
            version: string;
        };
        BulkNodeVersionsResponse: {
            /** @description List of retrieved node versions with their status */
            node_versions: components["schemas"]["BulkNodeVersionResult"][];
        };
        BulkNodeVersionResult: {
            /** @description The node and version identifier */
            identifier: components["schemas"]["NodeVersionIdentifier"];
            /**
             * @description Status of the retrieval operation
             * @enum {string}
             */
            status: "success" | "not_found" | "error";
            /** @description The retrieved node version data (only present if status is success) */
            node_version?: components["schemas"]["NodeVersion"];
            /** @description Error message if retrieval failed (only present if status is error) */
            error_message?: string;
        };
        PersonalAccessToken: {
            /**
             * Format: uuid
             * @description Unique identifier for the GitCommit
             */
            id?: string;
            /** @description Required. The name of the token. Can be a simple description. */
            name?: string;
            /** @description Optional. A more detailed description of the token's intended use. */
            description?: string;
            /**
             * Format: date-time
             * @description [Output Only]The date and time the token was created.
             */
            createdAt?: string;
            /** @description [Output Only]. The personal access token. Only returned during creation. */
            token?: string;
        };
        GitCommit: {
            /**
             * Format: uuid
             * @description Unique identifier for the GitCommit
             */
            id?: string;
            /** @description The hash of the commit */
            commit_hash?: string;
            /** @description The name of the commit */
            commit_name?: string;
            /** @description The branch where the commit was made */
            branch_name?: string;
            /** @description The author of the commit */
            author?: string;
            /**
             * Format: date-time
             * @description The timestamp when the commit was made
             */
            timestamp?: string;
        };
        GitCommitSummary: {
            /** @description The hash of the commit */
            commit_hash?: string;
            /** @description The name of the commit */
            commit_name?: string;
            /** @description The branch where the commit was made */
            branch_name?: string;
            /** @description The author of the commit */
            author?: string;
            /**
             * Format: date-time
             * @description The timestamp when the commit was made
             */
            timestamp?: string;
            /** @description A map of operating system to status pairs */
            status_summary?: {
                [key: string]: string;
            };
        };
        User: {
            /** @description The unique id for this user. */
            id?: string;
            /** @description The email address for this user. */
            email?: string;
            /** @description The name for this user. */
            name?: string;
            /** @description Indicates if the user is approved. */
            isApproved?: boolean;
            /** @description Indicates if the user has admin privileges. */
            isAdmin?: boolean;
        };
        PublisherUser: {
            /** @description The unique id for this user. */
            id?: string;
            /** @description The email address for this user. */
            email?: string;
            /** @description The name for this user. */
            name?: string;
        };
        ErrorResponse: {
            error: string;
            message: string;
        };
        CreateCouponRequest: {
            /** @description Name of the coupon displayed to customers */
            name?: string;
            /**
             * Format: double
             * @description Percent off discount (0-100)
             */
            percent_off?: number;
            /** @description Amount off in cents */
            amount_off?: number;
            /**
             * @description Currency for amount_off (required if amount_off is set)
             * @enum {string}
             */
            currency?: "usd";
            /**
             * @description How long the coupon lasts
             * @default once
             * @enum {string}
             */
            duration: "once" | "repeating" | "forever";
            /** @description Required if duration is repeating */
            duration_in_months?: number;
            /** @description Maximum number of times this coupon can be redeemed */
            max_redemptions?: number;
            /**
             * Format: int64
             * @description Unix timestamp specifying the last time at which the coupon can be redeemed
             */
            redeem_by?: number;
            /** @description Set of key-value pairs for storing additional information */
            metadata?: {
                [key: string]: string;
            };
        };
        UpdateCouponRequest: {
            /** @description Name of the coupon displayed to customers */
            name?: string;
            /** @description Set of key-value pairs for storing additional information */
            metadata?: {
                [key: string]: string;
            };
        };
        CouponResponse: {
            /** @description The Stripe coupon ID */
            id: string;
            /** @description Name of the coupon displayed to customers */
            name?: string;
            /**
             * Format: double
             * @description Percent off discount (0-100)
             */
            percent_off?: number;
            /** @description Amount off in cents */
            amount_off?: number;
            /** @description Currency for amount_off */
            currency?: string;
            /**
             * @description How long the coupon lasts
             * @enum {string}
             */
            duration: "once" | "repeating" | "forever";
            /** @description Number of months for repeating coupons */
            duration_in_months?: number;
            /** @description Maximum number of times this coupon can be redeemed */
            max_redemptions?: number;
            /** @description Number of times this coupon has been redeemed */
            times_redeemed?: number;
            /**
             * Format: int64
             * @description Unix timestamp specifying the last time at which the coupon can be redeemed
             */
            redeem_by?: number;
            /** @description Whether the coupon can still be redeemed */
            valid: boolean;
            /** @description Set of key-value pairs for storing additional information */
            metadata?: {
                [key: string]: string;
            };
        };
        CreatePromoCodeRequest: {
            /** @description The Stripe coupon ID to create the promotional code for */
            coupon_id: string;
            /**
             * @description Number of days until the promotion code expires
             * @default 30
             */
            expire_days: number;
            /** @description Maximum number of times this code can be redeemed */
            max_redemptions?: number;
        };
        UpdatePromoCodeRequest: {
            /** @description Whether the promo code is active */
            active?: boolean;
            /** @description Set of key-value pairs for storing additional information */
            metadata?: {
                [key: string]: string;
            };
        };
        PromoCodeResponse: {
            /** @description The Stripe promotion code ID */
            id: string;
            /** @description The generated promotional code */
            code: string;
            /** @description The Stripe coupon ID associated with this promo code */
            coupon_id: string;
            /** @description Whether the promo code is currently active */
            active: boolean;
            /**
             * Format: int64
             * @description Unix timestamp when the promo code expires
             */
            expires_at?: number;
            /** @description Maximum number of times this code can be redeemed */
            max_redemptions?: number;
            /** @description Number of times this code has been redeemed */
            times_redeemed?: number;
            /** @description Set of key-value pairs for storing additional information */
            metadata?: {
                [key: string]: string;
            };
        };
        RunwayTextToImageRequest: {
            /** @description Text prompt for the image generation */
            promptText: string;
            /**
             * @description Model to use for generation
             * @enum {string}
             */
            model: "gen4_image";
            /** @description The resolution (aspect ratio) of the output image */
            ratio: components["schemas"]["RunwayTextToImageAspectRatioEnum"];
            /** @description Array of reference images to guide the generation */
            referenceImages?: {
                /** @description A HTTPS URL or data URI containing an encoded image */
                uri?: string;
            }[];
        };
        ActionJobResult: {
            /**
             * Format: uuid
             * @description Unique identifier for the job result
             */
            id?: string;
            /** @description Name of the workflow */
            workflow_name?: string;
            /** @description Operating system used */
            operating_system?: string;
            /** @description PyTorch version used */
            python_version?: string;
            /** @description PyTorch version used */
            pytorch_version?: string;
            /** @description Identifier of the run this result belongs to */
            action_run_id?: string;
            /** @description Identifier of the job this result belongs to */
            action_job_id?: string;
            /** @description CUDA version used */
            cuda_version?: string;
            /** @description Name of the relevant git branch */
            branch_name?: string;
            /** @description The hash of the commit */
            commit_hash?: string;
            /** @description The ID of the commit */
            commit_id?: string;
            /**
             * Format: int64
             * @description The Unix timestamp when the commit was made
             */
            commit_time?: number;
            /** @description The message of the commit */
            commit_message?: string;
            /** @description The comfy run flags. E.g. `--low-vram` */
            comfy_run_flags?: string;
            /** @description The repository name */
            git_repo?: string;
            /** @description The pull request number */
            pr_number?: string;
            /**
             * Format: int64
             * @description The start time of the job as a Unix timestamp.
             */
            start_time?: number;
            /**
             * Format: int64
             * @description The end time of the job as a Unix timestamp.
             */
            end_time?: number;
            /** @description The average VRAM used by the job */
            avg_vram?: number;
            /** @description The peak VRAM used by the job */
            peak_vram?: number;
            /** @description The user who triggered the job. */
            job_trigger_user?: string;
            /** @description The author of the commit */
            author?: string;
            machine_stats?: components["schemas"]["MachineStats"];
            status?: components["schemas"]["WorkflowRunStatus"];
            storage_file?: components["schemas"]["StorageFile"];
        };
        StorageFile: {
            /**
             * Format: uuid
             * @description Unique identifier for the storage file
             */
            id?: string;
            /** @description Path to the file in storage */
            file_path?: string;
            /** @description Public URL */
            public_url?: string;
        };
        Publisher: {
            name?: string;
            /** @description The unique identifier for the publisher. It's akin to a username. Should be lowercase. */
            id?: string;
            description?: string;
            website?: string;
            support?: string;
            source_code_repo?: string;
            /** @description URL to the publisher's logo. */
            logo?: string;
            /**
             * Format: date-time
             * @description The date and time the publisher was created.
             */
            createdAt?: string;
            /** @description A list of members in the publisher. */
            members?: components["schemas"]["PublisherMember"][];
            /** @description The status of the publisher. */
            status?: components["schemas"]["PublisherStatus"];
        };
        PublisherMember: {
            /** @description The unique identifier for the publisher member. */
            id?: string;
            /** @description The user associated with this publisher member. */
            user?: components["schemas"]["PublisherUser"];
            /** @description The role of the user in the publisher. */
            role?: string;
        };
        Node: {
            /** @description The unique identifier of the node. */
            id?: string;
            /** @description The display name of the node. */
            name?: string;
            /**
             * @deprecated
             * @description DEPRECATED: The category of the node. Use 'tags' field instead. This field will be removed in a future version.
             */
            category?: string;
            description?: string;
            author?: string;
            /** @description The path to the LICENSE file in the node's repository. */
            license?: string;
            /** @description URL to the node's icon. */
            icon?: string;
            /** @description URL to the node's repository. */
            repository?: string;
            tags?: string[];
            /** @description Admin-only tags for security warnings and admin metadata */
            tags_admin?: string[];
            /** @description List of operating systems that this node supports */
            supported_os?: string[];
            /** @description List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
            supported_accelerators?: string[];
            /** @description Supported versions of ComfyUI */
            supported_comfyui_version?: string;
            /** @description Supported versions of ComfyUI frontend */
            supported_comfyui_frontend_version?: string;
            /** @description The latest version of the node. */
            latest_version?: components["schemas"]["NodeVersion"];
            /** @description The average rating of the node. */
            rating?: number;
            /** @description The number of downloads of the node. */
            downloads?: number;
            /** @description The publisher of the node. */
            publisher?: components["schemas"]["Publisher"];
            /** @description The status of the node. */
            status?: components["schemas"]["NodeStatus"];
            /** @description The status detail of the node. */
            status_detail?: string;
            /** @description Translations of node metadata in different languages. */
            translations?: {
                [key: string]: {
                    [key: string]: unknown;
                };
            };
            /** @description A numerical value representing the node's search ranking, used for sorting search results. */
            search_ranking?: number;
            /** @description A list of Comfy node names that are preempted by this node. */
            preempted_comfy_node_names?: string[];
            /** @description URL to the node's banner. */
            banner_url?: string;
            /** @description Number of stars on the GitHub repository. */
            github_stars?: number;
            /**
             * Format: date-time
             * @description The date and time when the node was created
             */
            created_at?: string;
        };
        NodeVersion: {
            id?: string;
            /** @description The version identifier, following semantic versioning. Must be unique for the node. */
            version?: string;
            /**
             * Format: date-time
             * @description The date and time the version was created.
             */
            createdAt?: string;
            /** @description Summary of changes made in this version */
            changelog?: string;
            /** @description A list of pip dependencies required by the node. */
            dependencies?: string[];
            /** @description [Output Only] URL to download this version of the node */
            downloadUrl?: string;
            /** @description Indicates if this version is deprecated. */
            deprecated?: boolean;
            /** @description The status of the node version. */
            status?: components["schemas"]["NodeVersionStatus"];
            status_reason?: string;
            tags?: string[];
            /** @description Admin-only tags for security warnings and admin metadata */
            tags_admin?: string[];
            /** @description The unique identifier of the node. */
            node_id?: string;
            /** @description The status of comfy node extraction process. */
            comfy_node_extract_status?: string;
            /** @description Supported versions of ComfyUI */
            supported_comfyui_version?: string;
            /** @description Supported versions of ComfyUI frontend */
            supported_comfyui_frontend_version?: string;
            /** @description List of operating systems that this node supports */
            supported_os?: string[];
            /** @description List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
            supported_accelerators?: string[];
        };
        ComfyNode: {
            /** @description Unique identifier for the node */
            comfy_node_name?: string;
            /** @description UI category where the node is listed, used for grouping nodes. */
            category?: string;
            /** @description Brief description of the node's functionality or purpose. */
            description?: string;
            /** @description Defines input parameters */
            input_types?: string;
            /** @description Indicates if the node is deprecated. Deprecated nodes are hidden in the UI. */
            deprecated?: boolean;
            /** @description Indicates if the node is experimental, subject to changes or removal. */
            experimental?: boolean;
            /** @description Boolean values indicating if each output is a list. */
            output_is_list?: boolean[];
            /** @description Names of the outputs for clarity in workflows. */
            return_names?: string;
            /** @description Specifies the types of outputs produced by the node. */
            return_types?: string;
            /** @description Name of the entry-point function to execute the node. */
            function?: string;
            /** @description The policy associated with the comfy node. */
            policy?: components["schemas"]["ComfyNodePolicy"];
        };
        ComfyNodeCloudBuildInfo: {
            project_id?: string;
            project_number?: string;
            location?: string;
            build_id?: string;
        };
        Error: {
            /** @description A clear and concise description of the error. */
            message?: string;
            /** @description Optional detailed information about the error or hints for resolving it. */
            details?: string[];
        };
        NodeVersionUpdateRequest: {
            /** @description The changelog describing the version changes. */
            changelog?: string;
            /** @description Whether the version is deprecated. */
            deprecated?: boolean;
        };
        /** @enum {string} */
        NodeStatus: "NodeStatusActive" | "NodeStatusDeleted" | "NodeStatusBanned";
        /** @enum {string} */
        ComfyNodePolicy: "ComfyNodePolicyActive" | "ComfyNodePolicyBanned" | "ComfyNodePolicyLocalOnly";
        ComfyNodeUpdateRequest: {
            /** @description UI category where the node is listed, used for grouping nodes. */
            category?: string;
            /** @description Brief description of the node's functionality or purpose. */
            description?: string;
            /** @description Defines input parameters */
            input_types?: string;
            /** @description Indicates if the node is deprecated. Deprecated nodes are hidden in the UI. */
            deprecated?: boolean;
            /** @description Indicates if the node is experimental, subject to changes or removal. */
            experimental?: boolean;
            /** @description Boolean values indicating if each output is a list. */
            output_is_list?: boolean[];
            /** @description Names of the outputs for clarity in workflows. */
            return_names?: string;
            /** @description Specifies the types of outputs produced by the node. */
            return_types?: string;
            /** @description Name of the entry-point function to execute the node. */
            function?: string;
            /** @description The policy associated with the comfy node. */
            policy?: components["schemas"]["ComfyNodePolicy"];
        };
        /** @enum {string} */
        NodeVersionStatus: "NodeVersionStatusActive" | "NodeVersionStatusDeleted" | "NodeVersionStatusBanned" | "NodeVersionStatusPending" | "NodeVersionStatusFlagged";
        /** @enum {string} */
        PublisherStatus: "PublisherStatusActive" | "PublisherStatusBanned";
        /** @enum {string} */
        WorkflowRunStatus: "WorkflowRunStatusStarted" | "WorkflowRunStatusFailed" | "WorkflowRunStatusCompleted";
        MachineStats: {
            /** @description Name of the machine. */
            machine_name?: string;
            /** @description The operating system version. eg. Ubuntu Linux 20.04 */
            os_version?: string;
            /** @description The GPU type. eg. NVIDIA Tesla K80 */
            gpu_type?: string;
            /** @description Total CPU on the machine. */
            cpu_capacity?: string;
            /** @description Initial CPU available before the job starts. */
            initial_cpu?: string;
            /** @description Total memory on the machine. */
            memory_capacity?: string;
            /** @description Initial RAM available before the job starts. */
            initial_ram?: string;
            /** @description Time series of VRAM usage. */
            vram_time_series?: Record<string, never>;
            /** @description Total disk capacity on the machine. */
            disk_capacity?: string;
            /** @description Initial disk available before the job starts. */
            initial_disk?: string;
            /** @description The pip freeze output */
            pip_freeze?: string;
        };
        Customer: {
            /** @description The firebase UID of the user */
            id: string;
            /** @description The email address for this user */
            email?: string;
            /** @description The name for this user */
            name?: string;
            /**
             * Format: date-time
             * @description The date and time the user was created
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description The date and time the user was last updated
             */
            updatedAt?: string;
            /** @description Whether the user is an admin */
            is_admin?: boolean;
            /** @description The Stripe customer ID */
            stripe_id?: string;
            /** @description The Metronome customer ID */
            metronome_id?: string;
            /** @description Whether the user has funds */
            has_fund?: boolean;
        };
        CustomerAdmin: {
            /** @description The firebase UID of the user */
            id: string;
            /** @description The email address for this user */
            email?: string;
            /** @description The name for this user */
            name?: string;
            /**
             * Format: date-time
             * @description The date and time the user was created
             */
            createdAt?: string;
            /**
             * Format: date-time
             * @description The date and time the user was last updated
             */
            updatedAt?: string;
            /** @description Whether the user is an admin */
            is_admin?: boolean;
            /** @description The Stripe customer ID */
            stripe_id?: string;
            /** @description The Metronome customer ID */
            metronome_id?: string;
            /** @description Whether the user has funds */
            has_fund?: boolean;
            /** @description Whether the customer has an active cloud subscription */
            cloud_subscription_is_active?: boolean;
            /** @description The active subscription ID if one exists */
            cloud_subscription_subscription_id?: string | null;
            /**
             * Format: date-time
             * @description The next renewal date for the subscription (ISO 8601 format)
             */
            cloud_subscription_renewal_date?: string | null;
            /**
             * Format: date-time
             * @description The date when the subscription is set to end (ISO 8601 format)
             */
            cloud_subscription_end_date?: string | null;
        };
        AuditLog: {
            /** @description the type of the event */
            event_type?: string;
            /** @description the id of the event */
            event_id?: string;
            /** @description data related to the event */
            params?: {
                [key: string]: unknown;
            };
            /**
             * Format: date-time
             * @description The date and time the event was created
             */
            createdAt?: string;
        };
        IdeogramV3Request: {
            /** @description The text prompt for image generation */
            prompt: string;
            /** @description Seed value for reproducible generation */
            seed?: number;
            /**
             * @description Image resolution in format WxH
             * @example 1280x800
             */
            resolution?: string;
            /**
             * @description Aspect ratio in format WxH
             * @example 1x3
             */
            aspect_ratio?: string;
            rendering_speed: components["schemas"]["RenderingSpeed"];
            /**
             * @description Whether to enable magic prompt enhancement
             * @enum {string}
             */
            magic_prompt?: "ON" | "OFF";
            /** @description Text prompt specifying what to avoid in the generation */
            negative_prompt?: string;
            /** @description Number of images to generate */
            num_images?: number;
            color_palette?: {
                /**
                 * @description Name of the color palette
                 * @example PASTEL
                 */
                name: string;
            };
            /** @description Array of style codes in hexadecimal format */
            style_codes?: string[];
            style_type?: components["schemas"]["IdeogramStyleType"];
            /** @description Array of reference image URLs or identifiers */
            style_reference_images?: string[];
            /** @description Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
            character_reference_images?: string[];
            /** @description Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
            character_reference_images_mask?: string[];
        };
        IdeogramV3EditRequest: {
            /**
             * Format: binary
             * @description The image being edited (max size 10MB); only JPEG, WebP and PNG formats are supported at this time.
             */
            image?: string;
            /**
             * Format: binary
             * @description A black and white image of the same size as the image being edited (max size 10MB). Black regions in the mask should match up with the regions of the image that you would like to edit; only JPEG, WebP and PNG formats are supported at this time.
             */
            mask?: string;
            /** @description The prompt used to describe the edited result. */
            prompt: string;
            /** @description Determine if MagicPrompt should be used in generating the request or not. */
            magic_prompt?: string;
            /** @description The number of images to generate. */
            num_images?: number;
            /** @description Random seed. Set for reproducible generation. */
            seed?: number;
            rendering_speed: components["schemas"]["RenderingSpeed"];
            style_type?: components["schemas"]["IdeogramStyleType"];
            /** @description A color palette for generation, must EITHER be specified via one of the presets (name) or explicitly via hexadecimal representations of the color with optional weights (members). Not supported by V_1, V_1_TURBO, V_2A and V_2A_TURBO models. */
            color_palette?: components["schemas"]["IdeogramColorPalette"];
            /** @description A list of 8 character hexadecimal codes representing the style of the image. Cannot be used in conjunction with style_reference_images or style_type. */
            style_codes?: string[];
            /** @description A set of images to use as style references (maximum total size 10MB across all style references). The images should be in JPEG, PNG or WebP format. */
            style_reference_images?: string[];
            /** @description Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
            character_reference_images?: string[];
            /** @description Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
            character_reference_images_mask?: string[];
        };
        /** @description A color palette specification that can either use a preset name or explicit color definitions with weights */
        IdeogramColorPalette: {
            /** @description Name of the preset color palette */
            name: string;
        } | {
            /** @description Array of color definitions with optional weights */
            members: {
                /** @description Hexadecimal color code */
                color?: string;
                /** @description Optional weight for the color (0-1) */
                weight?: number;
            }[];
        };
        /** @description Parameters for the Ideogram generation proxy request. Based on Ideogram's API. */
        IdeogramGenerateRequest: {
            /** @description The image generation request parameters. */
            image_request: {
                /** @description Required. The prompt to use to generate the image. */
                prompt: string;
                /** @description Optional. The aspect ratio (e.g., 'ASPECT_16_9', 'ASPECT_1_1'). Cannot be used with resolution. Defaults to 'ASPECT_1_1' if unspecified. */
                aspect_ratio?: string;
                /** @description The model used (e.g., 'V_2', 'V_2A_TURBO') */
                model: string;
                /** @description Optional. MagicPrompt usage ('AUTO', 'ON', 'OFF'). */
                magic_prompt_option?: string;
                /**
                 * Format: int64
                 * @description Optional. A number between 0 and 2147483647.
                 */
                seed?: number;
                /** @description Optional. Style type ('AUTO', 'GENERAL', 'REALISTIC', 'DESIGN', 'RENDER_3D', 'ANIME'). Only for models V_2 and above. */
                style_type?: string;
                /** @description Optional. Description of what to exclude. Only for V_1, V_1_TURBO, V_2, V_2_TURBO. */
                negative_prompt?: string;
                /**
                 * @description Optional. Number of images to generate (1-8). Defaults to 1.
                 * @default 1
                 */
                num_images: number;
                /** @description Optional. Resolution (e.g., 'RESOLUTION_1024_1024'). Only for model V_2. Cannot be used with aspect_ratio. */
                resolution?: string;
                /** @description Optional. Color palette object. Only for V_2, V_2_TURBO. */
                color_palette?: {
                    [key: string]: unknown;
                };
            };
        };
        /** @description Response from the Ideogram image generation API. */
        IdeogramGenerateResponse: {
            /**
             * Format: date-time
             * @description Timestamp when the generation was created.
             */
            created?: string;
            /** @description Array of generated image information. */
            data?: {
                /** @description The prompt used to generate this image. */
                prompt?: string;
                /** @description The resolution of the generated image (e.g., '1024x1024'). */
                resolution?: string;
                /** @description Indicates whether the image is considered safe. */
                is_image_safe?: boolean;
                /** @description The seed value used for this generation. */
                seed?: number;
                /** @description URL to the generated image. */
                url?: string;
                /** @description The style type used for generation (e.g., 'REALISTIC', 'ANIME'). */
                style_type?: string;
            }[];
        };
        IdeogramV3RemixRequest: {
            /** Format: binary */
            image?: string;
            prompt: string;
            /** @default 50 */
            image_weight: number;
            seed?: number;
            resolution?: string;
            aspect_ratio?: string;
            rendering_speed?: components["schemas"]["RenderingSpeed"];
            /** @enum {string} */
            magic_prompt?: "AUTO" | "ON" | "OFF";
            negative_prompt?: string;
            num_images?: number;
            color_palette?: Record<string, never>;
            style_codes?: string[];
            style_type?: components["schemas"]["IdeogramStyleType"];
            style_reference_images?: string[];
            /** @description Generations with character reference are subject to the character reference pricing. A set of images to use as character references (maximum total size 10MB across all character references), currently only supports 1 character reference image. The images should be in JPEG, PNG or WebP format. */
            character_reference_images?: string[];
            /** @description Optional masks for character reference images. When provided, must match the number of character_reference_images. Each mask should be a grayscale image of the same dimensions as the corresponding character reference image. The images should be in JPEG, PNG or WebP format. */
            character_reference_images_mask?: string[];
        };
        IdeogramV3IdeogramResponse: {
            /** Format: date-time */
            created?: string;
            data?: {
                prompt?: string;
                resolution?: string;
                is_image_safe?: boolean;
                seed?: number;
                url?: string;
                style_type?: string;
            }[];
        };
        IdeogramV3ReframeRequest: {
            /** Format: binary */
            image?: string;
            resolution: string;
            num_images?: number;
            seed?: number;
            rendering_speed?: components["schemas"]["RenderingSpeed"];
            color_palette?: Record<string, never>;
            style_codes?: string[];
            style_reference_images?: string[];
        };
        IdeogramV3ReplaceBackgroundRequest: {
            /** Format: binary */
            image?: string;
            prompt: string;
            /** @enum {string} */
            magic_prompt?: "AUTO" | "ON" | "OFF";
            num_images?: number;
            seed?: number;
            rendering_speed?: components["schemas"]["RenderingSpeed"];
            color_palette?: Record<string, never>;
            style_codes?: string[];
            style_reference_images?: string[];
        };
        /**
         * @description Task Status
         * @enum {string}
         */
        KlingTaskStatus: "submitted" | "processing" | "succeed" | "failed";
        /**
         * @description Model Name
         * @default kling-v1
         * @enum {string}
         */
        KlingTextToVideoModelName: "kling-v1" | "kling-v1-5" | "kling-v1-6" | "kling-v2-master" | "kling-v2-1-master" | "kling-v2-5-turbo" | "kling-v2-6";
        /**
         * @description Model Name
         * @default kling-v2-master
         * @enum {string}
         */
        KlingVideoGenModelName: "kling-v1" | "kling-v1-5" | "kling-v1-6" | "kling-v2-master" | "kling-v2-1" | "kling-v2-1-master" | "kling-v2-5-turbo" | "kling-v2-6";
        /**
         * @description Video generation mode. std: Standard Mode, which is cost-effective. pro: Professional Mode, generates videos with longer duration but higher quality output.
         * @default std
         * @enum {string}
         */
        KlingVideoGenMode: "std" | "pro";
        /**
         * @description Video aspect ratio
         * @default 16:9
         * @enum {string}
         */
        KlingVideoGenAspectRatio: "16:9" | "9:16" | "1:1";
        /**
         * @description Video length in seconds
         * @default 5
         * @enum {string}
         */
        KlingVideoGenDuration: "5" | "10";
        /**
         * Format: float
         * @description Flexibility in video generation. The higher the value, the lower the model's degree of flexibility, and the stronger the relevance to the user's prompt.
         * @default 0.5
         */
        KlingVideoGenCfgScale: number;
        KlingCameraControl: {
            type?: components["schemas"]["KlingCameraControlType"];
            config?: components["schemas"]["KlingCameraConfig"];
        };
        /**
         * @description Predefined camera movements type. simple: Customizable camera movement. down_back: Camera descends and moves backward. forward_up: Camera moves forward and tilts up. right_turn_forward: Rotate right and move forward. left_turn_forward: Rotate left and move forward.
         * @enum {string}
         */
        KlingCameraControlType: "simple" | "down_back" | "forward_up" | "right_turn_forward" | "left_turn_forward";
        KlingCameraConfig: {
            /** @description Controls camera's movement along horizontal axis (x-axis). Negative indicates left, positive indicates right. */
            horizontal?: number;
            /** @description Controls camera's movement along vertical axis (y-axis). Negative indicates downward, positive indicates upward. */
            vertical?: number;
            /** @description Controls camera's rotation in vertical plane (x-axis). Negative indicates downward rotation, positive indicates upward rotation. */
            pan?: number;
            /** @description Controls camera's rotation in horizontal plane (y-axis). Negative indicates left rotation, positive indicates right rotation. */
            tilt?: number;
            /** @description Controls camera's rolling amount (z-axis). Negative indicates counterclockwise, positive indicates clockwise. */
            roll?: number;
            /** @description Controls change in camera's focal length. Negative indicates narrower field of view, positive indicates wider field of view. */
            zoom?: number;
        };
        KlingVideoResult: {
            /** @description Generated video ID */
            id?: string;
            /**
             * Format: uri
             * @description URL for generated video
             */
            url?: string;
            /** @description Total video duration */
            duration?: string;
        };
        /**
         * @description Method of Transmitting Audio Files for Lip-Sync. Required when mode is audio2video.
         * @enum {string}
         */
        KlingAudioUploadType: "file" | "url";
        /**
         * @description Video Generation Mode. text2video: Text-to-video generation mode; audio2video: Audio-to-video generation mode
         * @enum {string}
         */
        KlingLipSyncMode: "text2video" | "audio2video";
        /**
         * @description The voice language corresponds to the Voice ID.
         * @default en
         * @enum {string}
         */
        KlingLipSyncVoiceLanguage: "zh" | "en";
        /**
         * @description Scene Name. Dual-character Effects (hug, kiss, heart_gesture).
         * @enum {string}
         */
        KlingDualCharacterEffectsScene: "hug" | "kiss" | "heart_gesture";
        /**
         * @description Scene Name. Single Image Effects (bloombloom, dizzydizzy, fuzzyfuzzy, squish, expansion).
         * @enum {string}
         */
        KlingSingleImageEffectsScene: "bloombloom" | "dizzydizzy" | "fuzzyfuzzy" | "squish" | "expansion";
        /**
         * @description Model Name. Can be kling-v1, kling-v1-5, or kling-v1-6.
         * @default kling-v1
         * @enum {string}
         */
        KlingCharacterEffectModelName: "kling-v1" | "kling-v1-5" | "kling-v1-6";
        /**
         * @description Model Name. Only kling-v1-6 is supported for single image effects.
         * @enum {string}
         */
        KlingSingleImageEffectModelName: "kling-v1-6";
        /**
         * @description Video Length in seconds. Only 5-second videos are supported.
         * @enum {string}
         */
        KlingSingleImageEffectDuration: "5";
        KlingDualCharacterImages: string[];
        /**
         * @description Aspect ratio of the generated images
         * @default 16:9
         * @enum {string}
         */
        KlingImageGenAspectRatio: "16:9" | "9:16" | "1:1" | "4:3" | "3:4" | "3:2" | "2:3" | "21:9";
        /**
         * @description Image reference type
         * @enum {string}
         */
        KlingImageGenImageReferenceType: "subject" | "face";
        /**
         * @description Model Name
         * @default kling-v1
         * @enum {string}
         */
        KlingImageGenModelName: "kling-v1" | "kling-v1-5" | "kling-v2";
        KlingImageResult: {
            /** @description Image Number (0-9) */
            index?: number;
            /**
             * Format: uri
             * @description URL for generated image
             */
            url?: string;
        };
        /**
         * @description Model Name
         * @default kolors-virtual-try-on-v1
         * @enum {string}
         */
        KlingVirtualTryOnModelName: "kolors-virtual-try-on-v1" | "kolors-virtual-try-on-v1-5";
        KlingText2VideoRequest: {
            model_name?: components["schemas"]["KlingTextToVideoModelName"];
            /** @description Positive text prompt */
            prompt?: string;
            /** @description Negative text prompt */
            negative_prompt?: string;
            cfg_scale?: components["schemas"]["KlingVideoGenCfgScale"];
            mode?: components["schemas"]["KlingVideoGenMode"];
            camera_control?: components["schemas"]["KlingCameraControl"];
            aspect_ratio?: components["schemas"]["KlingVideoGenAspectRatio"];
            duration?: components["schemas"]["KlingVideoGenDuration"];
            /**
             * @description Whether to generate sound simultaneously when generating videos. Only V2.6 and subsequent versions of the model support this parameter.
             * @default off
             * @enum {string}
             */
            sound: "on" | "off";
            /**
             * Format: uri
             * @description The callback notification address
             */
            callback_url?: string;
            /** @description Customized Task ID */
            external_task_id?: string;
        };
        KlingText2VideoResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                task_info?: {
                    external_task_id?: string;
                };
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    videos?: components["schemas"]["KlingVideoResult"][];
                };
            };
        };
        KlingImage2VideoRequest: {
            model_name?: components["schemas"]["KlingVideoGenModelName"];
            /** @description Reference Image - URL or Base64 encoded string, cannot exceed 10MB, resolution not less than 300*300px, aspect ratio between 1:2.5 ~ 2.5:1. Base64 should not include data:image prefix. */
            image?: string;
            /** @description Reference Image - End frame control. URL or Base64 encoded string, cannot exceed 10MB, resolution not less than 300*300px. Base64 should not include data:image prefix. */
            image_tail?: string;
            /** @description Positive text prompt */
            prompt?: string;
            /** @description Negative text prompt */
            negative_prompt?: string;
            cfg_scale?: components["schemas"]["KlingVideoGenCfgScale"];
            mode?: components["schemas"]["KlingVideoGenMode"];
            /** @description Static Brush Application Area (Mask image created by users using the motion brush). The aspect ratio must match the input image. */
            static_mask?: string;
            /** @description Dynamic Brush Configuration List (up to 6 groups). For 5-second videos, trajectory length must not exceed 77 coordinates. */
            dynamic_masks?: {
                /**
                 * Format: uri
                 * @description Dynamic Brush Application Area (Mask image created by users using the motion brush). The aspect ratio must match the input image.
                 */
                mask?: string;
                trajectories?: {
                    /** @description The horizontal coordinate of trajectory point. Based on bottom-left corner of image as origin (0,0). */
                    x?: number;
                    /** @description The vertical coordinate of trajectory point. Based on bottom-left corner of image as origin (0,0). */
                    y?: number;
                }[];
            }[];
            camera_control?: components["schemas"]["KlingCameraControl"];
            aspect_ratio?: components["schemas"]["KlingVideoGenAspectRatio"];
            duration?: components["schemas"]["KlingVideoGenDuration"];
            /**
             * @description Whether to generate sound simultaneously when generating videos. Only V2.6 and subsequent versions of the model support this parameter.
             * @default off
             * @enum {string}
             */
            sound: "on" | "off";
            /**
             * Format: uri
             * @description The callback notification address. Server will notify when the task status changes.
             */
            callback_url?: string;
            /** @description Customized Task ID. Must be unique within a single user account. */
            external_task_id?: string;
        };
        KlingImage2VideoResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                task_info?: {
                    external_task_id?: string;
                };
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    videos?: components["schemas"]["KlingVideoResult"][];
                };
            };
        };
        KlingVideoExtendRequest: {
            /** @description The ID of the video to be extended. Supports videos generated by text-to-video, image-to-video, and previous video extension operations. Cannot exceed 3 minutes total duration after extension. */
            video_id?: string;
            /** @description Positive text prompt for guiding the video extension */
            prompt?: string;
            /** @description Negative text prompt for elements to avoid in the extended video */
            negative_prompt?: string;
            cfg_scale?: components["schemas"]["KlingVideoGenCfgScale"];
            /**
             * Format: uri
             * @description The callback notification address. Server will notify when the task status changes.
             */
            callback_url?: string;
        };
        KlingVideoExtendResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                task_info?: {
                    external_task_id?: string;
                };
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    videos?: components["schemas"]["KlingVideoResult"][];
                };
            };
        };
        KlingOmniVideoRequest: {
            /**
             * @description Model Name
             * @default kling-video-o1
             * @enum {string}
             */
            model_name: "kling-video-o1";
            /** @description Text prompt words, which can include positive and negative descriptions. Must not exceed 2,500 characters. Can specify elements, images, or videos in the format <<<>>> such as <<element_1>>, <<<image_1>>>, <<<video_1>>>. */
            prompt: string;
            /** @description Reference Image List. Can include reference images of the element, scene, style, etc., or be used as the first or last frame to generate videos. */
            image_list?: {
                /** @description Image Base64 encoding or image URL (ensure accessibility). Supported formats include .jpg/.jpeg/.png. File size cannot exceed 10MB. Width and height dimensions shall not be less than 300px, aspect ratio between 1:2.5 ~ 2.5:1. */
                image_url?: string;
                /**
                 * @description Whether the image is in the first or last frame. first_frame is the first frame, end_frame is the last frame. Currently does not support only the end frame.
                 * @enum {string}
                 */
                type?: "first_frame" | "end_frame";
            }[];
            /** @description Reference Element List based on element ID configuration. */
            element_list?: {
                /**
                 * Format: int64
                 * @description Element ID
                 */
                element_id?: number;
            }[];
            /** @description Reference Video list. Can be used as a reference video for feature or as a video to be edited, with the default being the video to be edited. */
            video_list?: {
                /** @description URL of uploaded video. Only .mp4/.mov formats are supported. Duration between 3-10 seconds. Resolution must be between 720px and 2160px. Frame rates of 24-60 fps supported. Only 1 video can be uploaded, with size not exceeding 200MB. */
                video_url?: string;
                /**
                 * @description Reference video type. feature is the feature reference video, base is the video to be edited.
                 * @enum {string}
                 */
                refer_type?: "feature" | "base";
                /**
                 * @description Whether to keep the video original sound. yes indicates retention, no indicates non retention.
                 * @enum {string}
                 */
                keep_original_sound?: "yes" | "no";
            }[];
            /**
             * @description Video generation mode. pro - Professional Mode, generates videos use longer duration but higher quality video output.
             * @default pro
             * @enum {string}
             */
            mode: "pro";
            /**
             * @description The aspect ratio of the generated video frame (width:height). Required when first-frame reference or video editing features are not used.
             * @enum {string}
             */
            aspect_ratio?: "16:9" | "9:16" | "1:1";
            /**
             * @description Video Length in seconds. When using text generated videos, first frame image generated videos, and first and last frame generated videos, only 5 and 10 seconds are supported. When using video editing function, output duration is the same as input video.
             * @default 5
             * @enum {string}
             */
            duration: "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10";
            /**
             * Format: uri
             * @description The callback notification address for the result of this task. If configured, the server will actively notify when the task status changes.
             */
            callback_url?: string;
            /** @description Customized Task ID. Must be unique within a single user account. */
            external_task_id?: string;
        };
        KlingOmniVideoResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                /** @description Task status information, displaying the failure reason when the task fails */
                task_status_msg?: string;
                task_info?: {
                    external_task_id?: string;
                };
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    videos?: components["schemas"]["KlingVideoResult"][];
                };
            };
        };
        KlingOmniImageRequest: {
            /**
             * @description Model Name
             * @default kling-image-o1
             * @enum {string}
             */
            model_name: "kling-image-o1";
            /** @description Text prompt words, which can include positive and negative descriptions. Must not exceed 2,500 characters. The Omni model can achieve various capabilities through Prompt with elements and images. Specify an image in the format of <<<>>>, such as <<<image_1>>>. */
            prompt: string;
            /** @description Reference Image List. Supports inputting image Base64 encoding or image URL (ensure accessibility). Supported formats include .jpg/.jpeg/.png. File size cannot exceed 10MB. Width and height dimensions shall not be less than 300px, aspect ratio between 1:2.5 ~ 2.5:1. Maximum 10 images. */
            image_list?: {
                /** @description Image Base64 encoding or image URL (ensure accessibility) */
                image?: string;
            }[];
            /**
             * @description Image generation resolution. 1k is 1K standard, 2k is 2K high-res, 4k is 4K high-res.
             * @default 1k
             * @enum {string}
             */
            resolution: "1k" | "2k" | "4k";
            /**
             * @description Number of generated images. Value range [1,9].
             * @default 1
             */
            n: number;
            /**
             * @description Aspect ratio of the generated images (width:height). auto is to intelligently generate images based on incoming content.
             * @default auto
             * @enum {string}
             */
            aspect_ratio: "16:9" | "9:16" | "1:1" | "4:3" | "3:4" | "3:2" | "2:3" | "21:9" | "auto";
            /**
             * Format: uri
             * @description The callback notification address for the result of this task. If configured, the server will actively notify when the task status changes.
             */
            callback_url?: string;
            /** @description Customized Task ID. Must be unique within a single user account. */
            external_task_id?: string;
        };
        KlingOmniImageResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                /** @description Task status information, displaying the failure reason when the task fails (such as triggering the content risk control of the platform, etc.) */
                task_status_msg?: string;
                task_info?: {
                    /** @description Customer-defined task ID */
                    external_task_id?: string;
                };
                /** @description Task creation time, Unix timestamp in milliseconds */
                created_at?: number;
                /** @description Task update time, Unix timestamp in milliseconds */
                updated_at?: number;
                task_result?: {
                    images?: components["schemas"]["KlingImageResult"][];
                };
            };
        };
        KlingLipSyncInputObject: {
            /** @description The ID of the video generated by Kling AI. Only supports 5-second and 10-second videos generated within the last 30 days. */
            video_id?: string;
            /** @description Get link for uploaded video. Video files support .mp4/.mov, file size does not exceed 100MB, video length between 2-10s. */
            video_url?: string;
            mode: components["schemas"]["KlingLipSyncMode"];
            /** @description Text Content for Lip-Sync Video Generation. Required when mode is text2video. Maximum length is 120 characters. */
            text?: string;
            /** @description Voice ID. Required when mode is text2video. The system offers a variety of voice options to choose from. */
            voice_id?: string;
            voice_language?: components["schemas"]["KlingLipSyncVoiceLanguage"];
            /**
             * @description Speech Rate. Valid range: 0.8~2.0, accurate to one decimal place.
             * @default 1
             */
            voice_speed: number;
            audio_type?: components["schemas"]["KlingAudioUploadType"];
            /** @description Local Path of Audio File. Supported formats: .mp3/.wav/.m4a/.aac, maximum file size of 5MB. Base64 code. */
            audio_file?: string;
            /** @description Audio File Download URL. Supported formats: .mp3/.wav/.m4a/.aac, maximum file size of 5MB. */
            audio_url?: string;
        };
        KlingLipSyncRequest: {
            input: components["schemas"]["KlingLipSyncInputObject"];
            /**
             * Format: uri
             * @description The callback notification address. Server will notify when the task status changes.
             */
            callback_url?: string;
        };
        KlingLipSyncResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                task_info?: {
                    external_task_id?: string;
                };
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    videos?: components["schemas"]["KlingVideoResult"][];
                };
            };
        };
        KlingVideoEffectsRequest: {
            effect_scene: components["schemas"]["KlingDualCharacterEffectsScene"] | components["schemas"]["KlingSingleImageEffectsScene"];
            input: components["schemas"]["KlingVideoEffectsInput"];
            /**
             * Format: uri
             * @description The callback notification address for the result of this task.
             */
            callback_url?: string;
            /** @description Customized Task ID. Must be unique within a single user account. */
            external_task_id?: string;
        };
        KlingVideoEffectsInput: components["schemas"]["KlingSingleImageEffectInput"] | components["schemas"]["KlingDualCharacterEffectInput"];
        KlingSingleImageEffectInput: {
            model_name: components["schemas"]["KlingSingleImageEffectModelName"];
            /** @description Reference Image. URL or Base64 encoded string (without data:image prefix). File size cannot exceed 10MB, resolution not less than 300*300px, aspect ratio between 1:2.5 ~ 2.5:1. */
            image: string;
            duration: components["schemas"]["KlingSingleImageEffectDuration"];
        };
        KlingDualCharacterEffectInput: {
            model_name?: components["schemas"]["KlingCharacterEffectModelName"];
            mode?: components["schemas"]["KlingVideoGenMode"];
            images: components["schemas"]["KlingDualCharacterImages"];
            duration: components["schemas"]["KlingVideoGenDuration"];
        };
        KlingVideoEffectsResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                task_info?: {
                    external_task_id?: string;
                };
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    videos?: components["schemas"]["KlingVideoResult"][];
                };
            };
        };
        KlingImageGenerationsRequest: {
            model_name?: components["schemas"]["KlingImageGenModelName"];
            /** @description Positive text prompt */
            prompt: string;
            /** @description Negative text prompt */
            negative_prompt?: string;
            /** @description Reference Image - Base64 encoded string or image URL */
            image?: string;
            image_reference?: components["schemas"]["KlingImageGenImageReferenceType"];
            /**
             * @description Reference intensity for user-uploaded images
             * @default 0.5
             */
            image_fidelity: number;
            /**
             * @description Subject reference similarity
             * @default 0.45
             */
            human_fidelity: number;
            /**
             * @description Number of generated images
             * @default 1
             */
            n: number;
            aspect_ratio?: components["schemas"]["KlingImageGenAspectRatio"];
            /**
             * Format: uri
             * @description The callback notification address
             */
            callback_url?: string;
        };
        KlingImageGenerationsResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                /** @description Task status information */
                task_status_msg?: string;
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    images?: components["schemas"]["KlingImageResult"][];
                };
            };
        };
        KlingVirtualTryOnRequest: {
            model_name?: components["schemas"]["KlingVirtualTryOnModelName"];
            /** @description Reference human image - Base64 encoded string or image URL */
            human_image: string;
            /** @description Reference clothing image - Base64 encoded string or image URL */
            cloth_image?: string;
            /**
             * Format: uri
             * @description The callback notification address
             */
            callback_url?: string;
        };
        KlingVirtualTryOnResponse: {
            /** @description Error code */
            code?: number;
            /** @description Error message */
            message?: string;
            /** @description Request ID */
            request_id?: string;
            data?: {
                /** @description Task ID */
                task_id?: string;
                task_status?: components["schemas"]["KlingTaskStatus"];
                /** @description Task status information */
                task_status_msg?: string;
                /** @description Task creation time */
                created_at?: number;
                /** @description Task update time */
                updated_at?: number;
                task_result?: {
                    images?: components["schemas"]["KlingImageResult"][];
                };
            };
        };
        KlingResourcePackageResponse: {
            /** @description Error code; 0 indicates success */
            code?: number;
            /** @description Error information */
            message?: string;
            /** @description Request ID, generated by the system, used to track requests and troubleshoot problems */
            request_id?: string;
            data?: {
                /** @description Error code; 0 indicates success */
                code?: number;
                /** @description Error information */
                msg?: string;
                /** @description Resource package list */
                resource_pack_subscribe_infos?: {
                    /** @description Resource package name */
                    resource_pack_name?: string;
                    /** @description Resource package ID */
                    resource_pack_id?: string;
                    /**
                     * @description Resource package type (decreasing_total=decreasing total, constant_period=constant periodicity)
                     * @enum {string}
                     */
                    resource_pack_type?: "decreasing_total" | "constant_period";
                    /**
                     * Format: float
                     * @description Total quantity
                     */
                    total_quantity?: number;
                    /**
                     * Format: float
                     * @description Remaining quantity (updated with a 12-hour delay)
                     */
                    remaining_quantity?: number;
                    /**
                     * Format: int64
                     * @description Purchase time, Unix timestamp in ms
                     */
                    purchase_time?: number;
                    /**
                     * Format: int64
                     * @description Effective time, Unix timestamp in ms
                     */
                    effective_time?: number;
                    /**
                     * Format: int64
                     * @description Expiration time, Unix timestamp in ms
                     */
                    invalid_time?: number;
                    /**
                     * @description Resource Package Status
                     * @enum {string}
                     */
                    status?: "toBeOnline" | "online" | "expired" | "runOut";
                }[];
            };
        };
        LTXText2VideoRequest: {
            /** @description Text prompt describing the desired video content */
            prompt: string;
            /**
             * @description Model to use for generation
             * @enum {string}
             */
            model: "ltx-2-fast" | "ltx-2-pro";
            /**
             * @description Video duration in seconds
             * @enum {integer}
             */
            duration: 6 | 8 | 10;
            /**
             * @description Output video resolution
             * @enum {string}
             */
            resolution: "1920x1080" | "2560x1440" | "3840x2160";
            /**
             * @description Frame rate in frames per second
             * @default 25
             * @enum {integer}
             */
            fps: 25 | 50;
            /**
             * @description Generate audio for the video
             * @default true
             */
            generate_audio: boolean;
        };
        LTXImage2VideoRequest: {
            /** @description Image to be used as the first frame of the video (HTTPS URL or base64 data URI) */
            image_uri: string;
            /** @description Text description of how the image should be animated */
            prompt: string;
            /**
             * @description Model to use for generation
             * @enum {string}
             */
            model: "ltx-2-fast" | "ltx-2-pro";
            /**
             * @description Video duration in seconds
             * @enum {integer}
             */
            duration: 6 | 8 | 10;
            /**
             * @description Output video resolution
             * @enum {string}
             */
            resolution: "1920x1080" | "2560x1440" | "3840x2160";
            /**
             * @description Frame rate in frames per second
             * @default 25
             * @enum {integer}
             */
            fps: 25 | 50;
            /**
             * @description Generate audio for the video
             * @default true
             */
            generate_audio: boolean;
        };
        StripeEvent: {
            id: string;
            /** @enum {string} */
            object: "event";
            data: {
                object?: Record<string, never>;
            };
            /** @enum {string} */
            type: "invoice.paid";
        };
        /** @description Parameters for the Minimax video generation proxy request. */
        MinimaxVideoGenerationRequest: {
            /**
             * @description Required. ID of model. Options: MiniMax-Hailuo-02, T2V-01-Director, I2V-01-Director, S2V-01, I2V-01, I2V-01-live, T2V-01
             * @enum {string}
             */
            model: "MiniMax-Hailuo-02" | "T2V-01-Director" | "I2V-01-Director" | "S2V-01" | "I2V-01" | "I2V-01-live" | "T2V-01";
            /** @description Description of the video. Should be less than 2000 characters. Supports camera movement instructions in [brackets]. */
            prompt?: string;
            /**
             * @description If true (default), the model will automatically optimize the prompt. Set to false for more precise control.
             * @default true
             */
            prompt_optimizer: boolean;
            /** @description URL or base64 encoding of the first frame image. Required when model is I2V-01, I2V-01-Director, or I2V-01-live. */
            first_frame_image?: string;
            /** @description Only available when model is S2V-01. The model will generate a video based on the subject uploaded through this parameter. */
            subject_reference?: {
                /** @description URL or base64 encoding of the subject reference image. */
                image?: string;
                /** @description URL or base64 encoding of the mask for the subject reference image. */
                mask?: string;
            }[];
            /** @description Optional. URL to receive real-time status updates about the video generation task. */
            callback_url?: string;
            /**
             * @description Video length in seconds. Only available for MiniMax-Hailuo-02
             * @default 6
             * @enum {integer}
             */
            duration: 6 | 10;
            /**
             * @description Video resolution. Only available for MiniMax-Hailuo-02.
             * @default 768P
             * @enum {string}
             */
            resolution: "768P" | "1080P";
        };
        /** @description Common response structure used by Minimax APIs */
        MinimaxBaseResponse: {
            /** @description Status code. 0 indicates success, other values indicate errors. */
            status_code: number;
            /** @description Specific error details or success message. */
            status_msg: string;
        };
        /** @description Response from the Minimax video generation API. */
        MinimaxVideoGenerationResponse: {
            /** @description The task ID for the asynchronous video generation task. */
            task_id: string;
            base_resp: components["schemas"]["MinimaxBaseResponse"];
        };
        /** @description Response from retrieving a Minimax file download URL. */
        MinimaxFileRetrieveResponse: {
            file: {
                /** @description Unique identifier for the file */
                file_id?: number;
                /** @description File size in bytes */
                bytes?: number;
                /** @description Unix timestamp when the file was created, in seconds */
                created_at?: number;
                /** @description The name of the file */
                filename?: string;
                /** @description The purpose of using the file */
                purpose?: string;
                /** @description The URL to download the video */
                download_url?: string;
            };
            base_resp: components["schemas"]["MinimaxBaseResponse"];
        };
        /** @description Response from querying a Minimax video generation task status. */
        MinimaxTaskResultResponse: {
            /** @description The task ID being queried. */
            task_id: string;
            /**
             * @description Task status: 'Queueing' (in queue), 'Preparing' (task is preparing), 'Processing' (generating), 'Success' (task completed successfully), or 'Fail' (task failed).
             * @enum {string}
             */
            status: "Queueing" | "Preparing" | "Processing" | "Success" | "Fail";
            /** @description After the task status changes to Success, this field returns the file ID corresponding to the generated video. */
            file_id?: string;
            base_resp: components["schemas"]["MinimaxBaseResponse"];
        };
        BFLFluxKontextProGenerateRequest: {
            /** @description The text prompt describing what to edit on the image */
            prompt: string;
            /** @description Base64 encoded image to be edited */
            input_image: string;
            /**
             * @description Number of inference steps
             * @default 50
             */
            steps: number;
            /**
             * @description The guidance scale for generation
             * @default 3
             */
            guidance: number;
        };
        BFLFluxKontextProGenerateResponse: {
            /** @description Job ID for tracking */
            id: string;
            /** @description URL to poll for results */
            polling_url: string;
        };
        BFLFluxKontextMaxGenerateRequest: {
            /** @description The text prompt describing what to edit on the image */
            prompt: string;
            /** @description Base64 encoded image to be edited */
            input_image: string;
            /**
             * @description Number of inference steps
             * @default 50
             */
            steps: number;
            /**
             * @description The guidance scale for generation
             * @default 3
             */
            guidance: number;
        };
        BFLFluxKontextMaxGenerateResponse: {
            /** @description Job ID for tracking */
            id: string;
            /** @description URL to poll for results */
            polling_url: string;
        };
        BFLFluxPro1_1GenerateRequest: {
            /** @description The main text prompt for image generation */
            prompt: string;
            /** @description Optional image prompt */
            image_prompt?: string;
            /** @description Width of the generated image */
            width: number;
            /** @description Height of the generated image */
            height: number;
            /** @description Whether to use prompt upsampling */
            prompt_upsampling?: boolean;
            /** @description Random seed for reproducibility */
            seed?: number;
            /** @description Safety tolerance level */
            safety_tolerance?: number;
            /**
             * @description Output image format
             * @enum {string}
             */
            output_format?: "jpeg" | "png";
            /** @description Optional webhook URL for async processing */
            webhook_url?: string;
            /** @description Optional webhook secret for async processing */
            webhook_secret?: string;
        };
        BFLFluxPro1_1GenerateResponse: {
            /** @description Job ID for tracking */
            id: string;
            /** @description URL to poll for results */
            polling_url: string;
        };
        /** @description Request body for the BFL Flux Pro 1.1 Ultra image generation API. */
        BFLFluxProGenerateRequest: {
            /** @description The text prompt for image generation. */
            prompt: string;
            /** @description The negative prompt for image generation. */
            negative_prompt?: string;
            /** @description The width of the image to generate. */
            width: number;
            /** @description The height of the image to generate. */
            height: number;
            /** @description The number of inference steps. */
            num_inference_steps?: number;
            /** @description The guidance scale for generation. */
            guidance_scale?: number;
            /** @description The seed value for reproducibility. */
            seed?: number;
            /** @description The number of images to generate. */
            num_images?: number;
        };
        /** @description Response from the BFL Flux Pro 1.1 Ultra image generation API. */
        BFLFluxProGenerateResponse: {
            /** @description The unique identifier for the generation task. */
            id: string;
            /** @description URL to poll for the generation result. */
            polling_url: string;
            /**
             * Format: float
             * @description The cost of the generation task.
             */
            cost?: number;
            /**
             * Format: float
             * @description Input megapixels.
             */
            input_mp?: number;
            /**
             * Format: float
             * @description Output megapixels.
             */
            output_mp?: number;
        };
        /** @description Response from the BFL Flux Pro 1.1 Ultra status check API. */
        BFLFluxProStatusResponse: {
            /** @description The unique identifier for the generation task. */
            id: string;
            /** @description The status of the task. */
            status: components["schemas"]["BFLStatus"];
            /** @description The result of the task (null if not completed). */
            result?: Record<string, never> | null;
            /**
             * Format: float
             * @description The progress of the task (0.0 to 1.0).
             */
            progress: number;
            /** @description Additional details about the task (null if not available). */
            details?: Record<string, never> | null;
        };
        /**
         * @description Possible statuses for a BFL Flux Pro generation task.
         * @example Ready
         * @enum {string}
         */
        BFLStatus: "Task not found" | "Pending" | "Request Moderated" | "Content Moderated" | "Ready" | "Error";
        /** @description Request body for the BFL Flux 2 Pro image generation API. */
        BFLFlux2ProGenerateRequest: {
            /** @description Text description of the image to generate. */
            prompt: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_2?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_3?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_4?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_5?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_6?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_7?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_8?: string;
            /** @description Base64 encoded image for image-to-image generation. */
            input_image_9?: string;
            /**
             * @description Width of the image.
             * @default 1024
             */
            width: number;
            /**
             * @description Height of the image.
             * @default 1024
             */
            height: number;
            /** @description Seed for reproducibility. */
            seed?: number;
            /**
             * @description Automatically modify prompt for generation.
             * @default true
             */
            prompt_upsampling: boolean;
            /**
             * @description Output format for the generated image.
             * @default jpeg
             * @enum {string}
             */
            output_format: "jpeg" | "png";
            /**
             * @description Moderation tolerance level (Flux 2 Max only).
             * @default 2
             */
            safety_tolerance: number;
        };
        /** FluxProFillInputs */
        BFLFluxProFillInputs: {
            /**
             * Image
             * @description A Base64-encoded string representing the image you wish to modify. Can contain alpha mask if desired.
             */
            image: string;
            /**
             * Mask
             * @description A Base64-encoded string representing a mask for the areas you want to modify in the image. The mask should be the same dimensions as the image and in black and white. Black areas (0%) indicate no modification, while white areas (100%) specify areas for inpainting. Optional if you provide an alpha mask in the original image. Validation: The endpoint verifies that the dimensions of the mask match the original image.
             */
            mask?: string;
            /**
             * Prompt
             * @description The description of the changes you want to make. This text guides the inpainting process, allowing you to specify features, styles, or modifications for the masked area.
             * @default
             * @example ein fantastisches bild
             */
            prompt: string;
            /**
             * Steps
             * @description Number of steps for the image generation process
             * @default 50
             * @example 50
             */
            steps: number;
            /**
             * Prompt Upsampling
             * @description Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
             * @default false
             */
            prompt_upsampling: boolean;
            /**
             * Seed
             * @description Optional seed for reproducibility
             */
            seed?: number;
            /**
             * Guidance
             * @description Guidance strength for the image generation process
             * @default 60
             */
            guidance: number;
            /**
             * @description Output format for the generated image. Can be 'jpeg' or 'png'.
             * @default jpeg
             */
            output_format: components["schemas"]["BFLOutputFormat"];
            /**
             * Safety Tolerance
             * @description Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
             * @default 2
             * @example 2
             */
            safety_tolerance: number;
            /**
             * Webhook Url
             * @description URL to receive webhook notifications
             */
            webhook_url?: string;
            /**
             * Webhook Secret
             * @description Optional secret for webhook signature verification
             */
            webhook_secret?: string;
        };
        /** AsyncResponse */
        BFLAsyncResponse: {
            /** Id */
            id: string;
            /** Polling Url */
            polling_url: string;
        };
        /** AsyncWebhookResponse */
        BFLAsyncWebhookResponse: {
            /** Id */
            id: string;
            /** Status */
            status: string;
            /** Webhook Url */
            webhook_url: string;
        };
        /** HTTPValidationError */
        BFLHTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["BFLValidationError"][];
        };
        /** FluxProExpandInputs */
        BFLFluxProExpandInputs: {
            /**
             * Image
             * @description A Base64-encoded string representing the image you wish to expand.
             */
            image: string;
            /**
             * Top
             * @description Number of pixels to expand at the top of the image
             * @default 0
             */
            top: number;
            /**
             * Bottom
             * @description Number of pixels to expand at the bottom of the image
             * @default 0
             */
            bottom: number;
            /**
             * Left
             * @description Number of pixels to expand on the left side of the image
             * @default 0
             */
            left: number;
            /**
             * Right
             * @description Number of pixels to expand on the right side of the image
             * @default 0
             */
            right: number;
            /**
             * Prompt
             * @description The description of the changes you want to make. This text guides the expansion process, allowing you to specify features, styles, or modifications for the expanded areas.
             * @default
             * @example ein fantastisches bild
             */
            prompt: string;
            /**
             * Steps
             * @description Number of steps for the image generation process
             * @default 50
             * @example 50
             */
            steps: number;
            /**
             * Prompt Upsampling
             * @description Whether to perform upsampling on the prompt. If active, automatically modifies the prompt for more creative generation
             * @default false
             */
            prompt_upsampling: boolean;
            /**
             * Seed
             * @description Optional seed for reproducibility
             */
            seed?: number;
            /**
             * Guidance
             * @description Guidance strength for the image generation process
             * @default 60
             */
            guidance: number;
            /**
             * @description Output format for the generated image. Can be 'jpeg' or 'png'.
             * @default jpeg
             */
            output_format: components["schemas"]["BFLOutputFormat"];
            /**
             * Safety Tolerance
             * @description Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
             * @default 2
             * @example 2
             */
            safety_tolerance: number;
            /**
             * Webhook Url
             * @description URL to receive webhook notifications
             */
            webhook_url?: string;
            /**
             * Webhook Secret
             * @description Optional secret for webhook signature verification
             */
            webhook_secret?: string;
        };
        /** CannyInputs */
        BFLCannyInputs: {
            /**
             * Prompt
             * @description Text prompt for image generation
             * @example ein fantastisches bild
             */
            prompt: string;
            /**
             * Control Image
             * @description Base64 encoded image to use as control input if no preprocessed image is provided
             */
            control_image?: string;
            /**
             * Preprocessed Image
             * @description Optional pre-processed image that will bypass the control preprocessing step
             */
            preprocessed_image?: string;
            /**
             * Canny Low Threshold
             * @description Low threshold for Canny edge detection
             * @default 50
             */
            canny_low_threshold: number;
            /**
             * Canny High Threshold
             * @description High threshold for Canny edge detection
             * @default 200
             */
            canny_high_threshold: number;
            /**
             * Prompt Upsampling
             * @description Whether to perform upsampling on the prompt
             * @default false
             */
            prompt_upsampling: boolean;
            /**
             * Seed
             * @description Optional seed for reproducibility
             * @example 42
             */
            seed?: number;
            /**
             * Steps
             * @description Number of steps for the image generation process
             * @default 50
             */
            steps: number;
            /**
             * @description Output format for the generated image. Can be 'jpeg' or 'png'.
             * @default jpeg
             */
            output_format: components["schemas"]["BFLOutputFormat"];
            /**
             * Guidance
             * @description Guidance strength for the image generation process
             * @default 30
             */
            guidance: number;
            /**
             * Safety Tolerance
             * @description Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
             * @default 2
             */
            safety_tolerance: number;
            /**
             * Webhook Url
             * @description URL to receive webhook notifications
             */
            webhook_url?: string;
            /**
             * Webhook Secret
             * @description Optional secret for webhook signature verification
             */
            webhook_secret?: string;
        };
        /** DepthInputs */
        BFLDepthInputs: {
            /**
             * Prompt
             * @description Text prompt for image generation
             * @example ein fantastisches bild
             */
            prompt: string;
            /**
             * Control Image
             * @description Base64 encoded image to use as control input
             */
            control_image?: string;
            /**
             * Preprocessed Image
             * @description Optional pre-processed image that will bypass the control preprocessing step
             */
            preprocessed_image?: string;
            /**
             * Prompt Upsampling
             * @description Whether to perform upsampling on the prompt
             * @default false
             */
            prompt_upsampling: boolean;
            /**
             * Seed
             * @description Optional seed for reproducibility
             * @example 42
             */
            seed?: number;
            /**
             * Steps
             * @description Number of steps for the image generation process
             * @default 50
             */
            steps: number;
            /**
             * @description Output format for the generated image. Can be 'jpeg' or 'png'.
             * @default jpeg
             */
            output_format: components["schemas"]["BFLOutputFormat"];
            /**
             * Guidance
             * @description Guidance strength for the image generation process
             * @default 15
             */
            guidance: number;
            /**
             * Safety Tolerance
             * @description Tolerance level for input and output moderation. Between 0 and 6, 0 being most strict, 6 being least strict.
             * @default 2
             */
            safety_tolerance: number;
            /**
             * Webhook Url
             * @description URL to receive webhook notifications
             */
            webhook_url?: string;
            /**
             * Webhook Secret
             * @description Optional secret for webhook signature verification
             */
            webhook_secret?: string;
        };
        /**
         * OutputFormat
         * @enum {string}
         */
        BFLOutputFormat: "jpeg" | "png";
        /** ValidationError */
        BFLValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /** @description Parameters for the Recraft image generation proxy request. */
        RecraftImageGenerationRequest: {
            /** @description The text prompt describing the image to generate */
            prompt: string;
            /** @description The model to use for generation (e.g., "recraftv3") */
            model: string;
            /** @description The style to apply to the generated image (e.g., "digital_illustration") */
            style?: string;
            /** @description The style ID to apply to the generated image (e.g., "123e4567-e89b-12d3-a456-426614174000"). If style_id is provided, style should not be provided. */
            style_id?: string;
            /** @description The size of the generated image (e.g., "1024x1024") */
            size: string;
            /** @description The controls for the generated image */
            controls?: {
                /** @description Defines artistic tone of your image. At a simple level, the person looks straight at the camera in a static and clean style. Dynamic and eccentric levels introduce movement and creativity. */
                artistic_level?: number | null;
                /** @description An array of preferable colors */
                colors?: components["schemas"]["RGBColor"][];
                /** @description Use given color as a desired background color */
                background_color?: components["schemas"]["RGBColor"];
                /** @description Do not embed text layouts */
                no_text?: boolean;
            };
            /** @description The number of images to generate */
            n: number;
        };
        /** @description Response from the Recraft image generation API. */
        RecraftImageGenerationResponse: {
            /** @description Unix timestamp when the generation was created */
            created: number;
            /** @description Number of credits used for the generation */
            credits: number;
            /** @description Array of generated image information */
            data: {
                /** @description Unique identifier for the generated image */
                image_id?: string;
                /** @description URL to access the generated image */
                url?: string;
            }[];
        };
        RecraftImageFeatures: {
            nsfw_score?: number;
        };
        RecraftTextLayoutItem: {
            bbox: number[][];
            text: string;
        };
        RecraftImageColor: {
            rgb?: number[];
            std?: number[];
            weight?: number;
        };
        /** @enum {string} */
        RecraftImageStyle: "digital_illustration" | "icon" | "realistic_image" | "vector_illustration";
        /** @enum {string} */
        RecraftImageSubStyle: "2d_art_poster" | "3d" | "80s" | "glow" | "grain" | "hand_drawn" | "infantile_sketch" | "kawaii" | "pixel_art" | "psychedelic" | "seamless" | "voxel" | "watercolor" | "broken_line" | "colored_outline" | "colored_shapes" | "colored_shapes_gradient" | "doodle_fill" | "doodle_offset_fill" | "offset_fill" | "outline" | "outline_gradient" | "uneven_fill" | "70s" | "cartoon" | "doodle_line_art" | "engraving" | "flat_2" | "kawaii" | "line_art" | "linocut" | "seamless" | "b_and_w" | "enterprise" | "hard_flash" | "hdr" | "motion_blur" | "natural_light" | "studio_portrait" | "line_circuit" | "2d_art_poster_2" | "engraving_color" | "flat_air_art" | "hand_drawn_outline" | "handmade_3d" | "stickers_drawings" | "plastic" | "pictogram";
        /** @enum {string} */
        RecraftTransformModel: "refm1" | "recraft20b" | "recraftv2" | "recraftv3" | "flux1_1pro" | "flux1dev" | "imagen3" | "hidream_i1_dev";
        /** @enum {string} */
        RecraftImageFormat: "webp" | "png";
        /** @enum {string} */
        RecraftResponseFormat: "url" | "b64_json";
        RecraftImage: {
            b64_json?: string;
            features?: components["schemas"]["RecraftImageFeatures"];
            /** Format: uuid */
            image_id: string;
            revised_prompt?: string;
            url?: string;
        };
        RecraftUserControls: {
            artistic_level?: number;
            background_color?: components["schemas"]["RecraftImageColor"];
            colors?: components["schemas"]["RecraftImageColor"][];
            no_text?: boolean;
        };
        RecraftTextLayout: components["schemas"]["RecraftTextLayoutItem"][];
        RecraftProcessImageRequest: {
            /** Format: binary */
            image: string;
            image_format?: components["schemas"]["RecraftImageFormat"];
            response_format?: components["schemas"]["RecraftResponseFormat"];
        };
        RecraftProcessImageResponse: {
            created: number;
            credits: number;
            image: components["schemas"]["RecraftImage"];
        };
        RecraftImageToImageRequest: {
            block_nsfw?: boolean;
            calculate_features?: boolean;
            controls?: components["schemas"]["RecraftUserControls"];
            /** Format: binary */
            image: string;
            image_format?: components["schemas"]["RecraftImageFormat"];
            model?: components["schemas"]["RecraftTransformModel"];
            n?: number;
            negative_prompt?: string;
            prompt: string;
            response_format?: components["schemas"]["RecraftResponseFormat"];
            strength: number;
            style?: components["schemas"]["RecraftImageStyle"];
            /** Format: uuid */
            style_id?: string;
            substyle?: components["schemas"]["RecraftImageSubStyle"];
            text_layout?: components["schemas"]["RecraftTextLayout"];
        };
        RecraftGenerateImageResponse: {
            created: number;
            credits: number;
            data: components["schemas"]["RecraftImage"][];
        };
        RecraftTransformImageWithMaskRequest: {
            block_nsfw?: boolean;
            calculate_features?: boolean;
            /** Format: binary */
            image: string;
            image_format?: components["schemas"]["RecraftImageFormat"];
            /** Format: binary */
            mask: string;
            model?: components["schemas"]["RecraftTransformModel"];
            n?: number;
            negative_prompt?: string;
            prompt: string;
            response_format?: components["schemas"]["RecraftResponseFormat"];
            style?: components["schemas"]["RecraftImageStyle"];
            /** Format: uuid */
            style_id?: string;
            substyle?: components["schemas"]["RecraftImageSubStyle"];
            text_layout?: components["schemas"]["RecraftTextLayout"];
        };
        KlingErrorResponse: {
            /**
             * @description - 1000: Authentication failed
             *     - 1001: Authorization is empty
             *     - 1002: Authorization is invalid
             *     - 1003: Authorization is not yet valid
             *     - 1004: Authorization has expired
             *     - 1100: Account exception
             *     - 1101: Account in arrears (postpaid scenario)
             *     - 1102: Resource pack depleted or expired (prepaid scenario)
             *     - 1103: Unauthorized access to requested resource
             *     - 1200: Invalid request parameters
             *     - 1201: Invalid parameters
             *     - 1202: Invalid request method
             *     - 1203: Requested resource does not exist
             *     - 1300: Trigger platform strategy
             *     - 1301: Trigger content security policy
             *     - 1302: API request too frequent
             *     - 1303: Concurrency/QPS exceeds limit
             *     - 1304: Trigger IP whitelist policy
             *     - 5000: Internal server error
             *     - 5001: Service temporarily unavailable
             *     - 5002: Server internal timeout
             */
            code: number;
            /** @description Human-readable error message */
            message: string;
            /** @description Request ID for tracking and troubleshooting */
            request_id: string;
        };
        TripoTask: {
            task_id: string;
            type: string;
            /** @enum {string} */
            status: "queued" | "running" | "success" | "failed" | "cancelled" | "unknown" | "banned" | "expired";
            input: Record<string, never>;
            output: {
                model?: string;
                base_model?: string;
                pbr_model?: string;
                rendered_image?: string;
                riggable?: boolean;
                /** @enum {string} */
                topology?: "bip" | "quad";
            };
            progress: number;
            create_time: number;
        };
        TripoSuccessTask: {
            /** @enum {integer} */
            code: 0;
            data: {
                /** @description used for getTask */
                task_id: string;
            };
        };
        TripoBalance: {
            balance: number;
            frozen: number;
        };
        TripoErrorResponse: {
            /** @enum {integer} */
            code: 1001 | 2000 | 2001 | 2002 | 2003 | 2004 | 2006 | 2007 | 2008 | 2010;
            message: string;
            suggestion: string;
        };
        /**
         * @description Standard success code for Tripo API responses. Typically 0 for success.
         * @example 0
         */
        TripoResponseSuccessCode: number;
        /**
         * @description The type of the Tripo task, specifically for text-to-model operations.
         * @example text_to_model
         * @enum {string}
         */
        TripoTextToModel: "text_to_model";
        /**
         * @description Version of the Tripo model.
         * @example v2.5-20250123
         * @enum {string}
         */
        TripoModelVersion: "v2.5-20250123" | "v2.0-20240919" | "v1.4-20240625";
        /**
         * @description Style for the Tripo model generation.
         * @example object:clay
         * @enum {string}
         */
        TripoModelStyle: "person:person2cartoon" | "animal:venom" | "object:clay" | "object:steampunk" | "object:christmas" | "object:barbie" | "gold" | "ancient_bronze";
        /**
         * @description Task type for Tripo image-to-model generation.
         * @example image_to_model
         * @enum {string}
         */
        TripoImageToModel: "image_to_model";
        /**
         * @description Task type for Tripo multiview-to-model generation.
         * @example multiview_to_model
         * @enum {string}
         */
        TripoMultiviewToModel: "multiview_to_model";
        /**
         * @description Mode for multiview generation, specifying view orientation.
         * @example LEFT
         * @enum {string}
         */
        TripoMultiviewMode: "LEFT" | "RIGHT";
        /** @enum {string} */
        TripoTextureQuality: "standard" | "detailed";
        /** @enum {string} */
        TripoTextureAlignment: "original_image" | "geometry";
        /**
         * @default default
         * @enum {string}
         */
        TripoOrientation: "align_image" | "default";
        /** @enum {string} */
        TripoTypeTextureModel: "texture_model";
        /** @enum {string} */
        TripoTypeRefineModel: "refine_model";
        /** @enum {string} */
        TripoTypeAnimatePrerigcheck: "animate_prerigcheck";
        /** @enum {string} */
        TripoTypeAnimateRig: "animate_rig";
        /** @enum {string} */
        TripoStandardFormat: "glb" | "fbx";
        /** @enum {string} */
        TripoTopology: "bip" | "quad";
        /** @enum {string} */
        TripoSpec: "mixamo" | "tripo";
        /** @enum {string} */
        TripoTypeAnimateRetarget: "animate_retarget";
        /** @enum {string} */
        TripoAnimation: "preset:idle" | "preset:walk" | "preset:climb" | "preset:jump" | "preset:run" | "preset:slash" | "preset:shoot" | "preset:hurt" | "preset:fall" | "preset:turn";
        /** @enum {string} */
        TripoTypeStylizeModel: "stylize_model";
        /** @enum {string} */
        TripoStylizeOptions: "lego" | "voxel" | "voronoi" | "minecraft";
        /** @enum {string} */
        TripoTypeConvertModel: "convert_model";
        /** @enum {string} */
        TripoConvertFormat: "GLTF" | "USDZ" | "FBX" | "OBJ" | "STL" | "3MF";
        /** @enum {string} */
        TripoTextureFormat: "BMP" | "DPX" | "HDR" | "JPEG" | "OPEN_EXR" | "PNG" | "TARGA" | "TIFF" | "WEBP";
        /** @enum {string} */
        TripoGeometryQuality: "standard" | "detailed";
        /**
         * @description The aspect ratio of the generation
         * @default 16:9
         * @example 16:9
         * @enum {string}
         */
        LumaAspectRatio: "1:1" | "16:9" | "9:16" | "4:3" | "3:4" | "21:9" | "9:21";
        /**
         * @description The keyframes of the generation
         * @example {
         *       "frame0": {
         *         "type": "image",
         *         "url": "https://example.com/image.jpg"
         *       },
         *       "frame1": {
         *         "type": "generation",
         *         "id": "123e4567-e89b-12d3-a456-426614174000"
         *       }
         *     }
         */
        LumaKeyframes: {
            frame0?: components["schemas"]["LumaKeyframe"];
            frame1?: components["schemas"]["LumaKeyframe"];
        };
        /**
         * @description The video model used for the generation
         * @default ray-2
         * @example ray-2
         * @enum {string}
         */
        LumaVideoModel: "ray-2" | "ray-flash-2" | "ray-1-6";
        LumaVideoModelOutputResolution: ("540p" | "720p" | "1080p" | "4k") | string;
        LumaVideoModelOutputDuration: ("5s" | "9s") | string;
        /**
         * @description The image model used for the generation
         * @default photon-1
         * @enum {string}
         */
        LumaImageModel: "photon-1" | "photon-flash-1";
        /** @description The image reference object */
        LumaImageRef: {
            /**
             * Format: uri
             * @description The URL of the image reference
             */
            url?: string;
            /** @description The weight of the image reference */
            weight?: number;
        };
        /** @description The image identity object */
        LumaImageIdentity: {
            /** @description The URLs of the image identity */
            images?: string[];
        };
        /** @description The modify image reference object */
        LumaModifyImageRef: {
            /**
             * Format: uri
             * @description The URL of the image reference
             */
            url?: string;
            /** @description The weight of the modify image reference */
            weight?: number;
        };
        /**
         * @description The generation reference object
         * @example {
         *       "type": "generation",
         *       "id": "123e4567-e89b-12d3-a456-426614174003"
         *     }
         */
        LumaGenerationReference: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "generation";
            /**
             * Format: uuid
             * @description The ID of the generation
             */
            id: string;
        };
        /**
         * @description The image object
         * @example {
         *       "type": "image",
         *       "url": "https://example.com/image.jpg"
         *     }
         */
        LumaImageReference: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "image";
            /**
             * Format: uri
             * @description The URL of the image
             */
            url: string;
        };
        /** @description A keyframe can be either a Generation reference, an Image, or a Video */
        LumaKeyframe: components["schemas"]["LumaGenerationReference"] | components["schemas"]["LumaImageReference"];
        /** @enum {string} */
        LumaGenerationType: "video" | "image";
        /**
         * @description The state of the generation
         * @example completed
         * @enum {string}
         */
        LumaState: "queued" | "dreaming" | "completed" | "failed";
        /** @description The assets of the generation */
        LumaAssets: {
            /**
             * Format: uri
             * @description The URL of the video
             */
            video?: string;
            /**
             * Format: uri
             * @description The URL of the image
             */
            image?: string;
            /**
             * Format: uri
             * @description The URL of the progress video
             */
            progress_video?: string;
        };
        /** @description The generation request object */
        LumaGenerationRequest: {
            /**
             * @default video
             * @enum {string}
             */
            generation_type: "video";
            /** @description The prompt of the generation */
            prompt: string;
            aspect_ratio: components["schemas"]["LumaAspectRatio"];
            /** @description Whether to loop the video */
            loop?: boolean;
            keyframes?: components["schemas"]["LumaKeyframes"];
            /**
             * Format: uri
             * @description The callback URL of the generation, a POST request with Generation object will be sent to the callback URL when the generation is dreaming, completed, or failed
             */
            callback_url?: string;
            model: components["schemas"]["LumaVideoModel"];
            resolution: components["schemas"]["LumaVideoModelOutputResolution"];
            duration: components["schemas"]["LumaVideoModelOutputDuration"];
        };
        /** @description The image generation request object */
        LumaImageGenerationRequest: {
            /**
             * @default image
             * @enum {string}
             */
            generation_type: "image";
            model?: components["schemas"]["LumaImageModel"];
            /** @description The prompt of the generation */
            prompt?: string;
            aspect_ratio?: components["schemas"]["LumaAspectRatio"];
            /**
             * Format: uri
             * @description The callback URL for the generation
             */
            callback_url?: string;
            image_ref?: components["schemas"]["LumaImageRef"][];
            style_ref?: components["schemas"]["LumaImageRef"][];
            character_ref?: {
                identity0?: components["schemas"]["LumaImageIdentity"];
            };
            modify_image_ref?: components["schemas"]["LumaModifyImageRef"];
        };
        /** @description The upscale generation request object */
        LumaUpscaleVideoGenerationRequest: {
            /**
             * @default upscale_video
             * @enum {string}
             */
            generation_type: "upscale_video";
            resolution?: components["schemas"]["LumaVideoModelOutputResolution"];
            /**
             * Format: uri
             * @description The callback URL for the upscale
             */
            callback_url?: string;
        };
        /** @description The audio generation request object */
        LumaAudioGenerationRequest: {
            /**
             * @default add_audio
             * @enum {string}
             */
            generation_type: "add_audio";
            /** @description The prompt of the audio */
            prompt?: string;
            /** @description The negative prompt of the audio */
            negative_prompt?: string;
            /**
             * Format: uri
             * @description The callback URL for the audio
             */
            callback_url?: string;
        };
        /**
         * @description The error object
         * @example {
         *       "detail": "Invalid API key is provided"
         *     }
         */
        LumaError: {
            /** @description The error message */
            detail?: string;
        };
        /**
         * @description The generation response object
         * @example {
         *       "id": "123e4567-e89b-12d3-a456-426614174000",
         *       "state": "completed",
         *       "failure_reason": null,
         *       "created_at": "2023-06-01T12:00:00Z",
         *       "assets": {
         *         "video": "https://example.com/video.mp4"
         *       },
         *       "model": "ray-2",
         *       "request": {
         *         "prompt": "A serene lake surrounded by mountains at sunset",
         *         "aspect_ratio": "16:9",
         *         "loop": true,
         *         "keyframes": {
         *           "frame0": {
         *             "type": "image",
         *             "url": "https://example.com/image.jpg"
         *           },
         *           "frame1": {
         *             "type": "generation",
         *             "id": "123e4567-e89b-12d3-a456-426614174000"
         *           }
         *         }
         *       }
         *     }
         */
        LumaGeneration: {
            /**
             * Format: uuid
             * @description The ID of the generation
             */
            id?: string;
            generation_type?: components["schemas"]["LumaGenerationType"];
            state?: components["schemas"]["LumaState"];
            /** @description The reason for the state of the generation */
            failure_reason?: string;
            /**
             * Format: date-time
             * @description The date and time when the generation was created
             */
            created_at?: string;
            assets?: components["schemas"]["LumaAssets"];
            /** @description The model used for the generation */
            model?: string;
            /** @description The request of the generation */
            request?: components["schemas"]["LumaGenerationRequest"] | components["schemas"]["LumaImageGenerationRequest"] | components["schemas"]["LumaUpscaleVideoGenerationRequest"] | components["schemas"]["LumaAudioGenerationRequest"];
        };
        PixverseTextVideoRequest: {
            /** @enum {string} */
            aspect_ratio: "16:9" | "4:3" | "1:1" | "3:4" | "9:16";
            /** @enum {integer} */
            duration: 5 | 8;
            /** @enum {string} */
            model: "v3.5";
            /** @enum {string} */
            motion_mode?: "normal" | "fast";
            negative_prompt?: string;
            prompt: string;
            /** @enum {string} */
            quality: "360p" | "540p" | "720p" | "1080p";
            seed?: number;
            /** @enum {string} */
            style?: "anime" | "3d_animation" | "clay" | "comic" | "cyberpunk";
            template_id?: number;
            water_mark?: boolean;
        };
        PixverseVideoResponse: {
            ErrCode?: number;
            ErrMsg?: string;
            Resp?: {
                video_id?: number;
            };
        };
        PixverseImageUploadResponse: {
            ErrCode?: number;
            ErrMsg?: string;
            Resp?: {
                img_id?: number;
            };
        };
        PixverseImageVideoRequest: {
            img_id: number;
            /** @enum {string} */
            model: "v3.5";
            prompt: string;
            /** @enum {integer} */
            duration: 5 | 8;
            /** @enum {string} */
            quality: "360p" | "540p" | "720p" | "1080p";
            /** @enum {string} */
            motion_mode?: "normal" | "fast";
            seed?: number;
            /** @enum {string} */
            style?: "anime" | "3d_animation" | "clay" | "comic" | "cyberpunk";
            template_id?: number;
            water_mark?: boolean;
        };
        PixverseTransitionVideoRequest: {
            first_frame_img: number;
            last_frame_img: number;
            /** @enum {string} */
            model: "v3.5";
            /** @enum {integer} */
            duration: 5 | 8;
            /** @enum {string} */
            quality: "360p" | "540p" | "720p" | "1080p";
            /** @enum {string} */
            motion_mode: "normal" | "fast";
            seed: number;
            prompt: string;
            /** @enum {string} */
            style?: "anime" | "3d_animation" | "clay" | "comic" | "cyberpunk";
            template_id?: number;
            water_mark?: boolean;
        };
        PixverseVideoResultResponse: {
            ErrCode?: number;
            ErrMsg?: string;
            Resp?: {
                create_time?: string;
                id?: number;
                modify_time?: string;
                negative_prompt?: string;
                outputHeight?: number;
                outputWidth?: number;
                prompt?: string;
                resolution_ratio?: number;
                seed?: number;
                size?: number;
                /**
                 * @description Video generation status codes:
                 *     * 1 - Generation successful
                 *     * 5 - Generating
                 *     * 6 - Deleted
                 *     * 7 - Contents moderation failed
                 *     * 8 - Generation failed
                 * @enum {integer}
                 */
                status?: 1 | 5 | 6 | 7 | 8;
                style?: string;
                url?: string;
            };
        };
        Veo2GenVidRequest: {
            instances?: {
                /** @description Text description of the video */
                prompt: string;
                /** @description Optional image to guide video generation */
                image?: {
                    /** Format: byte */
                    bytesBase64Encoded?: string;
                    gcsUri?: string;
                    mimeType?: string;
                } & (unknown | unknown);
            }[];
            parameters?: {
                /** @example 16:9 */
                aspectRatio?: string;
                negativePrompt?: string;
                /** @enum {string} */
                personGeneration?: "ALLOW" | "BLOCK";
                sampleCount?: number;
                /** Format: uint32 */
                seed?: number;
                /** @description Optional Cloud Storage URI to upload the video */
                storageUri?: string;
                durationSeconds?: number;
                enhancePrompt?: boolean;
            };
        };
        Veo2GenVidResponse: {
            /**
             * @description Operation resource name
             * @example projects/PROJECT_ID/locations/us-central1/publishers/google/models/MODEL_ID/operations/a1b07c8e-7b5a-4aba-bb34-3e1ccb8afcc8
             */
            name: string;
        };
        Veo2GenVidPollRequest: {
            /**
             * @description Full operation name (from predict response)
             * @example projects/PROJECT_ID/locations/us-central1/publishers/google/models/MODEL_ID/operations/OPERATION_ID
             */
            operationName: string;
        };
        Veo2GenVidPollResponse: {
            name?: string;
            done?: boolean;
            /** @description The actual prediction response if done is true */
            response?: {
                /** @example type.googleapis.com/cloud.ai.large_models.vision.GenerateVideoResponse */
                "@type"?: string;
                /** @description Count of media filtered by responsible AI policies */
                raiMediaFilteredCount?: number;
                /** @description Reasons why media was filtered by responsible AI policies */
                raiMediaFilteredReasons?: string[];
                videos?: {
                    /** @description Cloud Storage URI of the video */
                    gcsUri?: string;
                    /** @description Base64-encoded video content */
                    bytesBase64Encoded?: string;
                    /** @description Video MIME type */
                    mimeType?: string;
                }[];
            };
            /** @description Error details if operation failed */
            error?: {
                /** @description Error code */
                code?: number;
                /** @description Error message */
                message?: string;
            };
        };
        VeoGenVidRequest: {
            instances?: {
                /** @description Text description of the video */
                prompt: string;
                /** @description Optional image to guide video generation */
                image?: {
                    /** Format: byte */
                    bytesBase64Encoded?: string;
                    gcsUri?: string;
                    mimeType?: string;
                } & (unknown | unknown);
                /** @description Optional last frame image to guide video generation */
                lastFrame?: {
                    /** Format: byte */
                    bytesBase64Encoded?: string;
                    gcsUri?: string;
                    mimeType?: string;
                } & (unknown | unknown);
            }[];
            parameters?: {
                /** @example 16:9 */
                aspectRatio?: string;
                negativePrompt?: string;
                /** @enum {string} */
                personGeneration?: "ALLOW" | "BLOCK";
                sampleCount?: number;
                /** Format: uint32 */
                seed?: number;
                /** @description Optional Cloud Storage URI to upload the video */
                storageUri?: string;
                durationSeconds?: number;
                enhancePrompt?: boolean;
                /** @description Generate audio for the video. Only supported by veo 3 models. */
                generateAudio?: boolean;
            };
        };
        VeoGenVidResponse: {
            /**
             * @description Operation resource name
             * @example projects/PROJECT_ID/locations/us-central1/publishers/google/models/MODEL_ID/operations/a1b07c8e-7b5a-4aba-bb34-3e1ccb8afcc8
             */
            name: string;
        };
        VeoGenVidPollRequest: {
            /**
             * @description Full operation name (from predict response)
             * @example projects/PROJECT_ID/locations/us-central1/publishers/google/models/MODEL_ID/operations/OPERATION_ID
             */
            operationName: string;
        };
        VeoGenVidPollResponse: {
            name?: string;
            done?: boolean;
            /** @description The actual prediction response if done is true */
            response?: {
                /** @example type.googleapis.com/cloud.ai.large_models.vision.GenerateVideoResponse */
                "@type"?: string;
                /** @description Count of media filtered by responsible AI policies */
                raiMediaFilteredCount?: number;
                /** @description Reasons why media was filtered by responsible AI policies */
                raiMediaFilteredReasons?: string[];
                videos?: {
                    /** @description Cloud Storage URI of the video */
                    gcsUri?: string;
                    /** @description Base64-encoded video content */
                    bytesBase64Encoded?: string;
                    /** @description Video MIME type */
                    mimeType?: string;
                }[];
            };
            /** @description Error details if operation failed */
            error?: {
                /** @description Error code */
                code?: number;
                /** @description Error message */
                message?: string;
            };
        };
        RunwayImageToVideoRequest: {
            promptImage: components["schemas"]["RunwayPromptImageObject"];
            /**
             * Format: int64
             * @description Random seed for generation
             */
            seed: number;
            /** @description Model to use for generation */
            model: components["schemas"]["RunwayModelEnum"];
            /** @description Text prompt for the generation */
            promptText?: string;
            /** @description The number of seconds of duration for the output video. */
            duration: components["schemas"]["RunwayDurationEnum"];
            /** @description The resolution (aspect ratio) of the output video. Allowable values depend on the selected model. 1280:768 and 768:1280 are only supported for gen3a_turbo. */
            ratio: components["schemas"]["RunwayAspectRatioEnum"];
        };
        RunwayImageToVideoResponse: {
            /** @description Task ID */
            id?: string;
        };
        RunwayTextToImageResponse: {
            /** @description Task ID */
            id?: string;
        };
        RunwayTaskStatusResponse: {
            /** @description Task ID */
            id: string;
            /** @description Task status */
            status: components["schemas"]["RunwayTaskStatusEnum"];
            /**
             * Format: date-time
             * @description Task creation timestamp
             */
            createdAt: string;
            /** @description Array of output video URLs */
            output?: string[];
            /**
             * Format: float
             * @description Float value between 0 and 1 representing the progress of the task. Only available if status is RUNNING.
             */
            progress?: number;
        };
        /**
         * @description Possible statuses for a Runway task.
         * @enum {string}
         */
        RunwayTaskStatusEnum: "SUCCEEDED" | "RUNNING" | "FAILED" | "PENDING" | "CANCELLED" | "THROTTLED";
        /**
         * @description Available Runway models for generation.
         * @enum {string}
         */
        RunwayModelEnum: "gen4_turbo" | "gen3a_turbo";
        /** @description Represents an image with its position in the video sequence. */
        RunwayPromptImageDetailedObject: {
            /** @description A HTTPS URL or data URI containing an encoded image. */
            uri: string;
            /**
             * @description The position of the image in the output video. 'last' is currently supported for gen3a_turbo only.
             * @enum {string}
             */
            position: "first" | "last";
        };
        /** @enum {integer} */
        RunwayDurationEnum: 5 | 10;
        /** @enum {string} */
        RunwayAspectRatioEnum: "1280:720" | "720:1280" | "1104:832" | "832:1104" | "960:960" | "1584:672" | "1280:768" | "768:1280";
        /** @enum {string} */
        RunwayTextToImageAspectRatioEnum: "1920:1080" | "1080:1920" | "1024:1024" | "1360:768" | "1080:1080" | "1168:880" | "1440:1080" | "1080:1440" | "1808:768" | "2112:912";
        /** @description Image(s) to use for the video generation. Can be a single URI or an array of image objects with positions. */
        RunwayPromptImageObject: string | components["schemas"]["RunwayPromptImageDetailedObject"][];
        OpenAIImageGenerationResponse: {
            data?: {
                /** @description Base64 encoded image data */
                b64_json?: string;
                /** @description URL of the image */
                url?: string;
                /** @description Revised prompt */
                revised_prompt?: string;
            }[];
            usage?: {
                input_tokens?: number;
                input_tokens_details?: {
                    text_tokens?: number;
                    image_tokens?: number;
                };
                output_tokens?: number;
                output_tokens_details?: {
                    text_tokens?: number;
                    image_tokens?: number;
                };
                total_tokens?: number;
            };
        };
        OpenAIImageGenerationRequest: {
            /**
             * @description The model to use for image generation
             * @example dall-e-3
             */
            model?: string;
            /**
             * @description A text description of the desired image
             * @example Draw a rocket in front of a blackhole in deep space
             */
            prompt: string;
            /**
             * @description The number of images to generate (1-10). Only 1 supported for dall-e-3.
             * @example 1
             */
            n?: number;
            /**
             * @description The quality of the generated image
             * @example high
             * @enum {string}
             */
            quality?: "low" | "medium" | "high" | "standard" | "hd";
            /**
             * @description Size of the image (e.g., 1024x1024, 1536x1024, auto)
             * @example 1024x1536
             */
            size?: string;
            /**
             * @description Format of the output image
             * @example png
             * @enum {string}
             */
            output_format?: "png" | "webp" | "jpeg";
            /**
             * @description Compression level for JPEG or WebP (0-100)
             * @example 100
             */
            output_compression?: number;
            /**
             * @description Content moderation setting
             * @example auto
             * @enum {string}
             */
            moderation?: "low" | "auto";
            /**
             * @description Background transparency
             * @example opaque
             * @enum {string}
             */
            background?: "transparent" | "opaque";
            /**
             * @description Response format of image data
             * @example b64_json
             * @enum {string}
             */
            response_format?: "url" | "b64_json";
            /**
             * @description Style of the image (only for dall-e-3)
             * @example vivid
             * @enum {string}
             */
            style?: "vivid" | "natural";
            /**
             * @description A unique identifier for end-user monitoring
             * @example user-1234
             */
            user?: string;
        };
        OpenAIImageEditRequest: {
            /**
             * @description The model to use for image editing
             * @example gpt-image-1
             */
            model: string;
            /**
             * @description A text description of the desired edit
             * @example Give the rocketship rainbow coloring
             */
            prompt: string;
            /**
             * @description The number of images to generate
             * @example 1
             */
            n?: number;
            /**
             * @description The quality of the edited image
             * @example low
             */
            quality?: string;
            /**
             * @description Size of the output image
             * @example 1024x1024
             */
            size?: string;
            /**
             * @description Format of the output image
             * @example png
             * @enum {string}
             */
            output_format?: "png" | "webp" | "jpeg";
            /**
             * @description Compression level for JPEG or WebP (0-100)
             * @example 100
             */
            output_compression?: number;
            /**
             * @description Content moderation setting
             * @example auto
             * @enum {string}
             */
            moderation?: "low" | "auto";
            /**
             * @description Background transparency
             * @example opaque
             */
            background?: string;
            /**
             * @description A unique identifier for end-user monitoring
             * @example user-1234
             */
            user?: string;
        };
        OpenAIVideoCreateRequest: {
            /**
             * @description Text prompt that describes the video to generate
             * @example A calico cat playing a piano on stage
             */
            prompt: string;
            /**
             * Format: binary
             * @description Optional image or video reference that guides generation
             */
            input_reference?: string;
            /**
             * @description The video generation model to use
             * @default sora-2
             * @enum {string}
             */
            model: "sora-2" | "sora-2-pro";
            /**
             * @description Clip duration in seconds
             * @default 4
             * @enum {string}
             */
            seconds: "4" | "8" | "12";
            /**
             * @description Output resolution formatted as width x height
             * @default 720x1280
             * @enum {string}
             */
            size: "720x1280" | "1280x720" | "1024x1792" | "1792x1024";
        };
        OpenAIVideoJob: {
            /**
             * @description Unique identifier for the video job
             * @example video_123
             */
            id?: string;
            /**
             * @description The object type, which is always video
             * @example video
             * @enum {string}
             */
            object?: "video";
            /**
             * @description The video generation model that produced the job
             * @example sora-2
             */
            model?: string;
            /**
             * @description Current lifecycle status of the video job
             * @example queued
             * @enum {string}
             */
            status?: "queued" | "in_progress" | "completed" | "failed";
            /**
             * @description Approximate completion percentage for the generation task
             * @example 0
             */
            progress?: number;
            /**
             * @description Unix timestamp (seconds) for when the job was created
             * @example 1712697600
             */
            created_at?: number;
            /**
             * @description Unix timestamp (seconds) for when the job completed, if finished
             * @example 1712698600
             */
            completed_at?: number;
            /**
             * @description Unix timestamp (seconds) for when the downloadable assets expire, if set
             * @example 1712784000
             */
            expires_at?: number;
            /**
             * @description The resolution of the generated video
             * @example 1024x1808
             */
            size?: string;
            /**
             * @description Duration of the generated clip in seconds
             * @example 8
             */
            seconds?: string;
            /**
             * @description Quality of the generated video
             * @example standard
             */
            quality?: string;
            /**
             * @description Identifier of the source video if this video is a remix
             * @example video_456
             */
            remixed_from_video_id?: string;
            /** @description Error payload that explains why generation failed, if applicable */
            error?: {
                /** @description Error code */
                code?: string;
                /** @description Human-readable error message */
                message?: string;
            };
        };
        CustomerStorageResourceResponse: {
            /** @description The signed URL to use for downloading the file from the specified path */
            download_url?: string;
            /** @description The signed URL to use for uploading the file to the specified path */
            upload_url?: string;
            /**
             * Format: date-time
             * @description When the signed URL will expire
             */
            expires_at?: string;
            /** @description Whether an existing file with the same hash was found */
            existing_file?: boolean;
        };
        /** @enum {string} */
        Pikaffect: "Cake-ify" | "Crumble" | "Crush" | "Decapitate" | "Deflate" | "Dissolve" | "Explode" | "Eye-pop" | "Inflate" | "Levitate" | "Melt" | "Peel" | "Poke" | "Squish" | "Ta-da" | "Tear";
        /** Body_generate_pikaffects_generate_pikaffects_post */
        PikaBody_generate_pikaffects_generate_pikaffects_post: {
            /**
             * Image
             * Format: binary
             */
            image?: string;
            /** Pikaffect */
            pikaffect?: components["schemas"]["Pikaffect"];
            /** Prompttext */
            promptText?: string;
            /** Negativeprompt */
            negativePrompt?: string;
            /** Seed */
            seed?: number;
        };
        /** GenerateResponse */
        PikaGenerateResponse: {
            /** Video Id */
            video_id: string;
        };
        /** HTTPValidationError */
        PikaHTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["PikaValidationError"][];
        };
        /** Body_generate_pikadditions_generate_pikadditions_post */
        PikaBody_generate_pikadditions_generate_pikadditions_post: {
            /**
             * Video
             * Format: binary
             */
            video?: string;
            /**
             * Image
             * Format: binary
             */
            image?: string;
            /** Prompttext */
            promptText?: string;
            /** Negativeprompt */
            negativePrompt?: string;
            /** Seed */
            seed?: number;
        };
        /** Body_generate_pikaswaps_generate_pikaswaps_post */
        PikaBody_generate_pikaswaps_generate_pikaswaps_post: {
            /**
             * Video
             * Format: binary
             */
            video?: string;
            /** Image */
            image?: string;
            /** Prompttext */
            promptText?: string;
            /**
             * Modifyregionmask
             * @description A mask image that specifies the region to modify, where the mask is white and the background is black
             */
            modifyRegionMask?: string;
            /**
             * Modifyregionroi
             * @description Plaintext description of the object / region to modify
             */
            modifyRegionRoi?: string;
            /** Negativeprompt */
            negativePrompt?: string;
            /** Seed */
            seed?: number;
        };
        /** Body_generate_2_2_t2v_generate_2_2_t2v_post */
        PikaBody_generate_2_2_t2v_generate_2_2_t2v_post: {
            /** Prompttext */
            promptText: string;
            /** Negativeprompt */
            negativePrompt?: string | null;
            /** Seed */
            seed?: number | null;
            /** Resolution */
            resolution?: components["schemas"]["PikaResolutionEnum"];
            /** Duration */
            duration?: components["schemas"]["PikaDurationEnum"];
            /**
             * Aspectratio
             * Format: float
             * @description Aspect ratio (width / height)
             * @default 1.7777777777777777
             */
            aspectRatio: number;
        };
        /** Body_generate_2_2_i2v_generate_2_2_i2v_post */
        PikaBody_generate_2_2_i2v_generate_2_2_i2v_post: {
            /**
             * Image
             * Format: binary
             */
            image?: string | null;
            /** Prompttext */
            promptText?: string | null;
            /** Negativeprompt */
            negativePrompt?: string | null;
            /** Seed */
            seed?: number | null;
            /** Resolution */
            resolution?: components["schemas"]["PikaResolutionEnum"];
            /** Duration */
            duration?: components["schemas"]["PikaDurationEnum"];
        };
        /** Body_generate_2_2_c2v_generate_2_2_pikascenes_post */
        PikaBody_generate_2_2_c2v_generate_2_2_pikascenes_post: {
            /** Images */
            images?: string[];
            /**
             * Ingredientsmode
             * @enum {string}
             */
            ingredientsMode: "creative" | "precise";
            /** Prompttext */
            promptText?: string;
            /** Negativeprompt */
            negativePrompt?: string;
            /** Seed */
            seed?: number;
            /**
             * Resolution
             * @default 1080p
             */
            resolution: string;
            /**
             * Duration
             * @default 5
             */
            duration: number;
            /**
             * Aspectratio
             * @description Aspect ratio (width / height)
             */
            aspectRatio?: number;
        };
        /** Body_generate_2_2_keyframe_generate_2_2_pikaframes_post */
        PikaBody_generate_2_2_keyframe_generate_2_2_pikaframes_post: {
            /**
             * Keyframes
             * @description Array of keyframe images
             */
            keyFrames?: string[];
            /** Prompttext */
            promptText: string;
            /** Negativeprompt */
            negativePrompt?: string;
            /** Seed */
            seed?: number;
            /** Resolution */
            resolution?: components["schemas"]["PikaResolutionEnum"];
            /** Duration */
            duration?: number;
        };
        /** VideoResponse */
        PikaVideoResponse: {
            /** Id */
            id: string;
            /**
             * Status
             * @description The status of the video
             */
            status: components["schemas"]["PikaStatusEnum"];
            /**
             * Url
             * @default null
             */
            url: string | null;
            /**
             * Progress
             * @default null
             */
            progress: number | null;
        };
        /** @enum {string} */
        PikaStatusEnum: "queued" | "started" | "finished";
        /** ValidationError */
        PikaValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
        /**
         * @default 1080p
         * @enum {string}
         */
        PikaResolutionEnum: "1080p" | "720p";
        /**
         * @default 5
         * @enum {integer}
         */
        PikaDurationEnum: 5 | 10;
        /**
         * @description RGB color values
         * @example {
         *       "rgb": [
         *         255,
         *         0,
         *         0
         *       ]
         *     }
         */
        RGBColor: {
            rgb: number[];
        };
        /**
         * @example {
         *       "id": "2a1b2d4eafe2bc6ab4cd4d5c6133f513",
         *       "name": "internal_error",
         *       "errors": [
         *         "An unexpected server error has occurred, please try again later."
         *       ]
         *     }
         */
        StabilityError: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       {
             *         "some-field": "is required"
             *       }
             *     ]
             */
            errors: string[];
        };
        /**
         * @description The name of your application, used to help us communicate app-specific debugging or moderation issues to you.
         * @example my-awesome-app
         */
        StabilityStabilityClientID: string;
        /**
         * @description A unique identifier for your end user. Used to help us communicate user-specific debugging or moderation issues to you. Feel free to obfuscate this value to protect user privacy.
         * @example DiscordUser#9999
         */
        StabilityStabilityClientUserID: string;
        /**
         * @description The version of your application, used to help us communicate version-specific debugging or moderation issues to you.
         * @example 1.2.1
         */
        StabilityStabilityClientVersion: string;
        /**
         * @description Your request was flagged by our content moderation system.
         * @example {
         *       "id": "ed14db44362126aab3cbd25cca51ffe3",
         *       "name": "content_moderation",
         *       "errors": [
         *         "Your request was flagged by our content moderation system, as a result your request was denied and you were not charged."
         *       ]
         *     }
         */
        StabilityContentModerationResponse: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Our content moderation system has flagged some part of your request and subsequently denied it.  You were not charged for this request.  While this may at times be frustrating, it is necessary to maintain the integrity of our platform and ensure a safe experience for all users. If you would like to provide feedback, please use the [Support Form](https://kb.stability.ai/knowledge-base/kb-tickets/new).
             * @enum {string}
             */
            name: "content_moderation";
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        ImagenGenerateImageRequest: {
            instances: components["schemas"]["ImagenImageGenerationInstance"][];
            parameters: components["schemas"]["ImagenImageGenerationParameters"];
        };
        ImagenGenerateImageResponse: {
            predictions?: components["schemas"]["ImagenImagePrediction"][];
        };
        ImagenImageGenerationInstance: {
            /** @description Text prompt for image generation */
            prompt: string;
        };
        ImagenImageGenerationParameters: {
            sampleCount?: number;
            /** Format: uint32 */
            seed?: number;
            addWatermark?: boolean;
            /** @enum {string} */
            aspectRatio?: "1:1" | "9:16" | "16:9" | "3:4" | "4:3";
            enhancePrompt?: boolean;
            includeRaiReason?: boolean;
            includeSafetyAttributes?: boolean;
            outputOptions?: components["schemas"]["ImagenOutputOptions"];
            /** @enum {string} */
            personGeneration?: "dont_allow" | "allow_adult" | "allow_all";
            /** @enum {string} */
            safetySetting?: "block_most" | "block_some" | "block_few" | "block_fewest";
            /** Format: uri */
            storageUri?: string;
        };
        ImagenImagePrediction: {
            /** @description MIME type of the generated image */
            mimeType?: string;
            /** @description Enhanced or rewritten prompt used to generate this image */
            prompt?: string;
            /**
             * Format: byte
             * @description Base64-encoded image content
             */
            bytesBase64Encoded?: string;
        };
        ImagenOutputOptions: {
            /** @enum {string} */
            mimeType?: "image/png" | "image/jpeg";
            compressionQuality?: number;
        };
        /**
         * @description The rendering speed setting that controls the trade-off between generation speed and quality
         * @default DEFAULT
         * @enum {string}
         */
        RenderingSpeed: "DEFAULT" | "TURBO" | "QUALITY";
        /**
         * @default GENERAL
         * @enum {string}
         */
        IdeogramStyleType: "AUTO" | "GENERAL" | "REALISTIC" | "DESIGN" | "FICTION";
        /**
         * @description Controls the likelihood of creating additional details not heavily conditioned by the init image.
         * @default 0.35
         */
        StabilityCreativity: number;
        /**
         * @description The `id` of a generation, typically used for async generations, that can be used to check the status of the generation or retrieve the result.
         * @example a6dc6c6e20acda010fe14d71f180658f2896ed9b4ec25aa99a6ff06c796987c4
         */
        StabilityGenerationID: string;
        StabilityImageGenerationSD3_Request: {
            /**
             * @description What you wish to see in the output image. A strong, descriptive prompt that clearly defines
             *     elements, colors, and subjects will lead to better results.
             */
            prompt: string;
            /**
             * GenerationMode
             * @description Controls whether this is a text-to-image or image-to-image generation, which affects which parameters are required:
             *     - **text-to-image** requires only the `prompt` parameter
             *     - **image-to-image** requires the `prompt`, `image`, and `strength` parameters
             * @default text-to-image
             * @enum {string}
             */
            mode: "text-to-image" | "image-to-image";
            /**
             * Format: binary
             * @description The image to use as the starting point for the generation.
             *
             *     Supported formats:
             *
             *
             *
             *       - jpeg
             *       - png
             *       - webp
             *
             *     Supported dimensions:
             *
             *
             *
             *       - Every side must be at least 64 pixels
             *
             *     > **Important:** This parameter is only valid for **image-to-image** requests.
             */
            image?: string;
            /**
             * @description Sometimes referred to as _denoising_, this parameter controls how much influence the
             *     `image` parameter has on the generated image.  A value of 0 would yield an image that
             *     is identical to the input.  A value of 1 would be as if you passed in no image at all.
             *
             *     > **Important:** This parameter is only valid for **image-to-image** requests.
             */
            strength?: number;
            /**
             * @description Controls the aspect ratio of the generated image. Defaults to 1:1.
             *
             *     > **Important:** This parameter is only valid for **text-to-image** requests.
             * @default 1:1
             * @enum {string}
             */
            aspect_ratio: "21:9" | "16:9" | "3:2" | "5:4" | "1:1" | "4:5" | "2:3" | "9:16" | "9:21";
            /**
             * @description The model to use for generation.
             *
             *     - `sd3.5-large` requires 6.5 credits per generation
             *     - `sd3.5-large-turbo` requires 4 credits per generation
             *     - `sd3.5-medium` requires 3.5 credits per generation
             *     - As of the April 17, 2025, `sd3-large`, `sd3-large-turbo` and `sd3-medium`
             *
             *
             *
             *       are re-routed to their `sd3.5-[model version]` equivalent, at the same price.
             * @default sd3.5-large
             * @enum {string}
             */
            model: "sd3.5-large" | "sd3.5-large-turbo" | "sd3.5-medium";
            /**
             * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
             * @default 0
             */
            seed: number;
            /**
             * @description Dictates the `content-type` of the generated image.
             * @default png
             * @enum {string}
             */
            output_format: "png" | "jpeg";
            /**
             * @description Guides the image model towards a particular style.
             * @enum {string}
             */
            style_preset?: "enhance" | "anime" | "photographic" | "digital-art" | "comic-book" | "fantasy-art" | "line-art" | "analog-film" | "neon-punk" | "isometric" | "low-poly" | "origami" | "modeling-compound" | "cinematic" | "3d-model" | "pixel-art" | "tile-texture";
            /**
             * @description Keywords of what you **do not** wish to see in the output image.
             *     This is an advanced feature.
             */
            negative_prompt?: string;
            /** @description How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt). The _Large_ and _Medium_ models use a default of `4`. The _Turbo_ model uses a default of `1`. */
            cfg_scale?: number;
        };
        StabilityImageGenrationSD3_Response_200: {
            /**
             * @description The generated image, encoded to base64.
             * @example AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
             */
            image: string;
            /**
             * @description The seed used as random noise for this generation.
             * @default 0
             * @example 343940597
             */
            seed: number;
            /**
             * @description The reason the generation finished.
             *
             *     - `SUCCESS` = successful generation.
             *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
             *     policy and has been blurred as a result.
             * @example SUCCESS
             * @enum {string}
             */
            finish_reason: "SUCCESS" | "CONTENT_FILTERED";
        };
        StabilityImageGenrationSD3_Response_400: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "4212a4b66fbe1cedca4bf2133d35dca5",
         *       "name": "payload_too_large",
         *       "errors": [
         *         "body: payloads cannot be larger than 10MiB in size"
         *       ]
         *     }
         */
        StabilityImageGenrationSD3_Response_413: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationSD3_Response_422: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "rate_limit_exceeded",
         *       "name": "rate_limit_exceeded",
         *       "errors": [
         *         "You have exceeded the rate limit of 150 requests within a 10 second period, and have been timed out for 60 seconds."
         *       ]
         *     }
         */
        StabilityImageGenrationSD3_Response_429: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "2a1b2d4eafe2bc6ab4cd4d5c6133f513",
         *       "name": "internal_error",
         *       "errors": [
         *         "An unexpected server error has occurred, please try again later."
         *       ]
         *     }
         */
        StabilityImageGenrationSD3_Response_500: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationUpscaleConservative_Request: {
            /**
             * Format: binary
             * @description The image you wish to upscale.
             *
             *     Supported Formats:
             *     - jpeg
             *     - png
             *     - webp
             *
             *     Validation Rules:
             *     - Every side must be at least 64 pixels
             *     - Total pixel count must be between 4,096 and 9,437,184 pixels
             *     - The aspect ratio must be between 1:2.5 and 2.5:1
             * @example ./some/image.png
             */
            image: string;
            /**
             * @description What you wish to see in the output image. A strong, descriptive prompt that clearly defines
             *     elements, colors, and subjects will lead to better results.
             *
             *     To control the weight of a given word use the format `(word:weight)`,
             *     where `word` is the word you'd like to control the weight of and `weight`
             *     is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)`
             *     would convey a sky that was blue and green, but more green than blue.
             */
            prompt: string;
            /**
             * @description A blurb of text describing what you **do not** wish to see in the output image.
             *     This is an advanced feature.
             */
            negative_prompt?: string;
            /**
             * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
             * @default 0
             */
            seed: number;
            /**
             * @description Dictates the `content-type` of the generated image.
             * @default png
             * @enum {string}
             */
            output_format: "jpeg" | "png" | "webp";
            creativity?: components["schemas"]["StabilityCreativity"];
        };
        StabilityImageGenrationUpscaleConservative_Response_200: {
            /**
             * @description The generated image, encoded to base64.
             * @example AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
             */
            image: string;
            /**
             * @description The seed used as random noise for this generation.
             * @default 0
             * @example 343940597
             */
            seed: number;
            /**
             * @description The reason the generation finished.
             *
             *     - `SUCCESS` = successful generation.
             *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
             *     policy and has been blurred as a result.
             * @example SUCCESS
             * @enum {string}
             */
            finish_reason: "SUCCESS" | "CONTENT_FILTERED";
        };
        StabilityImageGenrationUpscaleConservative_Response_400: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "4212a4b66fbe1cedca4bf2133d35dca5",
         *       "name": "payload_too_large",
         *       "errors": [
         *         "body: payloads cannot be larger than 10MiB in size"
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleConservative_Response_413: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationUpscaleConservative_Response_422: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "rate_limit_exceeded",
         *       "name": "rate_limit_exceeded",
         *       "errors": [
         *         "You have exceeded the rate limit of 150 requests within a 10 second period, and have been timed out for 60 seconds."
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleConservative_Response_429: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "2a1b2d4eafe2bc6ab4cd4d5c6133f513",
         *       "name": "internal_error",
         *       "errors": [
         *         "An unexpected server error has occurred, please try again later."
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleConservative_Response_500: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationUpscaleCreative_Request: {
            /**
             * Format: binary
             * @description The image you wish to upscale.
             *
             *     Supported Formats:
             *     - jpeg
             *     - png
             *     - webp
             *
             *     Validation Rules:
             *     - Every side must be at least 64 pixels
             *     - Total pixel count must be between 4,096 and 1,048,576 pixels
             * @example ./some/image.png
             */
            image: string;
            /**
             * @description What you wish to see in the output image. A strong, descriptive prompt that clearly defines
             *     elements, colors, and subjects will lead to better results.
             *
             *     To control the weight of a given word use the format `(word:weight)`,
             *     where `word` is the word you'd like to control the weight of and `weight`
             *     is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)`
             *     would convey a sky that was blue and green, but more green than blue.
             */
            prompt: string;
            /**
             * @description A blurb of text describing what you **do not** wish to see in the output image.
             *     This is an advanced feature.
             */
            negative_prompt?: string;
            /**
             * @description Dictates the `content-type` of the generated image.
             * @default png
             * @enum {string}
             */
            output_format: "jpeg" | "png" | "webp";
            /**
             * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
             * @default 0
             */
            seed: number;
            /**
             * @description Indicates how creative the model should be when upscaling an image.
             *     Higher values will result in more details being added to the image during upscaling.
             * @default 0.3
             */
            creativity: number;
            /**
             * @description Guides the image model towards a particular style.
             * @enum {string}
             */
            style_preset?: "enhance" | "anime" | "photographic" | "digital-art" | "comic-book" | "fantasy-art" | "line-art" | "analog-film" | "neon-punk" | "isometric" | "low-poly" | "origami" | "modeling-compound" | "cinematic" | "3d-model" | "pixel-art" | "tile-texture";
        };
        StabilityImageGenrationUpscaleCreative_Response_200: {
            id: components["schemas"]["StabilityGenerationID"];
        };
        StabilityImageGenrationUpscaleCreative_Response_400: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "4212a4b66fbe1cedca4bf2133d35dca5",
         *       "name": "payload_too_large",
         *       "errors": [
         *         "body: payloads cannot be larger than 10MiB in size"
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleCreative_Response_413: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationUpscaleCreative_Response_422: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "rate_limit_exceeded",
         *       "name": "rate_limit_exceeded",
         *       "errors": [
         *         "You have exceeded the rate limit of 150 requests within a 10 second period, and have been timed out for 60 seconds."
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleCreative_Response_429: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "2a1b2d4eafe2bc6ab4cd4d5c6133f513",
         *       "name": "internal_error",
         *       "errors": [
         *         "An unexpected server error has occurred, please try again later."
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleCreative_Response_500: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationUpscaleFast_Request: {
            /**
             * Format: binary
             * @description The image you wish to upscale.
             *
             *     Supported Formats:
             *     - jpeg
             *     - png
             *     - webp
             *
             *     Validation Rules:
             *     - Width must be between 32 and 1,536 pixels
             *     - Height must be between 32 and 1,536 pixels
             *     - Total pixel count must be between 1,024 and 1,048,576 pixels
             * @example ./some/image.png
             */
            image: string;
            /**
             * @description Dictates the `content-type` of the generated image.
             * @default png
             * @enum {string}
             */
            output_format: "jpeg" | "png" | "webp";
        };
        StabilityImageGenrationUpscaleFast_Response_200: {
            /**
             * @description The generated image, encoded to base64.
             * @example AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
             */
            image: string;
            /**
             * @description The seed used as random noise for this generation.
             * @default 0
             * @example 343940597
             */
            seed: number;
            /**
             * @description The reason the generation finished.
             *
             *     - `SUCCESS` = successful generation.
             *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
             *     policy and has been blurred as a result.
             * @example SUCCESS
             * @enum {string}
             */
            finish_reason: "SUCCESS" | "CONTENT_FILTERED";
        };
        StabilityImageGenrationUpscaleFast_Response_400: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "4212a4b66fbe1cedca4bf2133d35dca5",
         *       "name": "payload_too_large",
         *       "errors": [
         *         "body: payloads cannot be larger than 10MiB in size"
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleFast_Response_413: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityImageGenrationUpscaleFast_Response_422: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /**
         * @example {
         *       "id": "rate_limit_exceeded",
         *       "name": "rate_limit_exceeded",
         *       "errors": [
         *         "You have exceeded the rate limit of 150 requests within a 10 second period, and have been timed out for 60 seconds."
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleFast_Response_429: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        StabilityGetResultResponse_202: {
            /** @enum {string} */
            status?: "in-progress";
            /**
             * @description The ID of the generation result.
             * @example 1234567890
             */
            id?: string;
        };
        APIKey: {
            id?: string;
            name?: string;
            description?: string;
            key_prefix?: string;
            /** Format: date-time */
            created_at?: string;
        };
        APIKeyWithPlaintext: components["schemas"]["APIKey"] & {
            /** @description The full API key (only returned at creation) */
            plaintext_key?: string;
        };
        GeminiGenerateContentRequest: {
            contents: components["schemas"]["GeminiContent"][];
            tools?: components["schemas"]["GeminiTool"][];
            safetySettings?: components["schemas"]["GeminiSafetySetting"][];
            generationConfig?: components["schemas"]["GeminiGenerationConfig"];
            systemInstruction?: components["schemas"]["GeminiSystemInstructionContent"];
            videoMetadata?: components["schemas"]["GeminiVideoMetadata"];
        };
        GeminiGenerateContentResponse: {
            candidates?: components["schemas"]["GeminiCandidate"][];
            promptFeedback?: components["schemas"]["GeminiPromptFeedback"];
            usageMetadata?: components["schemas"]["GeminiUsageMetadata"];
        };
        GeminiUsageMetadata: {
            /** @description Number of tokens in the request. When cachedContent is set, this is still the total effective prompt size meaning this includes the number of tokens in the cached content. */
            promptTokenCount?: number;
            /** @description Number of tokens in the response(s). */
            candidatesTokenCount?: number;
            /** @description Number of tokens present in tool-use prompt(s). */
            toolUsePromptTokenCount?: number;
            /** @description Number of tokens present in thoughts output. */
            thoughtsTokenCount?: number;
            /** @description Output only. Number of tokens in the cached part in the input (the cached content). */
            cachedContentTokenCount?: number;
            /** @description Breakdown of prompt tokens by modality. */
            promptTokensDetails?: components["schemas"]["ModalityTokenCount"][];
            /** @description Breakdown of candidate tokens by modality. */
            candidatesTokensDetails?: components["schemas"]["ModalityTokenCount"][];
        };
        ModalityTokenCount: {
            modality?: components["schemas"]["Modality"];
            /** @description Number of tokens for the given modality. */
            tokenCount?: number;
        };
        /**
         * @description Type of input or output content modality.
         * @enum {string}
         */
        Modality: "MODALITY_UNSPECIFIED" | "TEXT" | "IMAGE" | "VIDEO" | "AUDIO" | "DOCUMENT";
        /** @description Available for gemini-2.0-flash and gemini-2.0-flash-lite. Instructions for the model to steer it toward better performance. For example, "Answer as concisely as possible" or "Don't use technical terms in your response". The text strings count toward the token limit. The role field of systemInstruction is ignored and doesn't affect the performance of the model. Note: Only text should be used in parts and content in each part should be in a separate paragraph. */
        GeminiSystemInstructionContent: {
            /**
             * @description The identity of the entity that creates the message. The following values are supported: user: This indicates that the message is sent by a real person, typically a user-generated message. model: This indicates that the message is generated by the model. The model value is used to insert messages from the model into the conversation during multi-turn conversations. For non-multi-turn conversations, this field can be left blank or unset.
             * @example user
             * @enum {string}
             */
            role: "user" | "model";
            /** @description A list of ordered parts that make up a single message. Different parts may have different IANA MIME types. For limits on the inputs, such as the maximum number of tokens or the number of images, see the model specifications on the Google models page. */
            parts: components["schemas"]["GeminiTextPart"][];
        };
        /** @description The content of the current conversation with the model. For single-turn queries, this is a single instance. For multi-turn queries, this is a repeated field that contains conversation history and the latest request. */
        GeminiContent: {
            /**
             * @example user
             * @enum {string}
             */
            role: "user" | "model";
            parts: components["schemas"]["GeminiPart"][];
        };
        /** @description A piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model. See Function calling. */
        GeminiTool: {
            functionDeclarations?: components["schemas"]["GeminiFunctionDeclaration"][];
        };
        /** @description Per request settings for blocking unsafe content. Enforced on GenerateContentResponse.candidates. */
        GeminiSafetySetting: {
            category: components["schemas"]["GeminiSafetyCategory"];
            threshold: components["schemas"]["GeminiSafetyThreshold"];
        };
        /** @enum {string} */
        GeminiSafetyCategory: "HARM_CATEGORY_SEXUALLY_EXPLICIT" | "HARM_CATEGORY_HATE_SPEECH" | "HARM_CATEGORY_HARASSMENT" | "HARM_CATEGORY_DANGEROUS_CONTENT";
        /** @enum {string} */
        GeminiSafetyThreshold: "OFF" | "BLOCK_NONE" | "BLOCK_LOW_AND_ABOVE" | "BLOCK_MEDIUM_AND_ABOVE" | "BLOCK_ONLY_HIGH";
        GeminiGenerationConfig: {
            /**
             * Format: float
             * @description The temperature is used for sampling during response generation, which occurs when topP and topK are applied. Temperature controls the degree of randomness in token selection. Lower temperatures are good for prompts that require a less open-ended or creative response, while higher temperatures can lead to more diverse or creative results. A temperature of 0 means that the highest probability tokens are always selected. In this case, responses for a given prompt are mostly deterministic, but a small amount of variation is still possible. If the model returns a response that's too generic, too short, or the model gives a fallback response, try increasing the temperature
             * @default 1
             */
            temperature: number;
            /**
             * Format: float
             * @description If specified, nucleus sampling is used.
             *     Top-P changes how the model selects tokens for output. Tokens are selected from the most (see top-K) to least probable until the sum of their probabilities equals the top-P value. For example, if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the top-P value is 0.5, then the model will select either A or B as the next token by using temperature and excludes C as a candidate.
             *     Specify a lower value for less random responses and a higher value for more random responses.
             * @default 0.95
             */
            topP: number;
            /**
             * @description Top-K changes how the model selects tokens for output. A top-K of 1 means the next selected token is the most probable among all tokens in the model's vocabulary. A top-K of 3 means that the next token is selected from among the 3 most probable tokens by using temperature.
             * @default 40
             * @example 40
             */
            topK: number;
            /**
             * @description Maximum number of tokens that can be generated in the response. A token is approximately 4 characters. 100 tokens correspond to roughly 60-80 words.
             * @example 2048
             */
            maxOutputTokens?: number;
            /**
             * @description When seed is fixed to a specific value, the model makes a best effort to provide the same response for repeated requests. Deterministic output isn't guaranteed. Also, changing the model or parameter settings, such as the temperature, can cause variations in the response even when you use the same seed value. By default, a random seed value is used. Available for the following models:, gemini-2.5-flash, gemini-2.5-pro, gemini-2.5-flash-preview-04-1, gemini-2.5-pro-preview-05-0, gemini-2.0-flash-lite-00, gemini-2.0-flash-001
             * @example 343940597
             */
            seed?: number;
            stopSequences?: string[];
            responseModalities?: ("TEXT" | "IMAGE")[];
            /** @description Configuration for image generation */
            imageConfig?: {
                /** @description Aspect ratio for generated images */
                aspectRatio?: string;
                /** @description Optional. Specifies the size of generated images. Supported values are 1K, 2K, 4K. If not specified, the model will use default value 1K. */
                imageSize?: string;
            };
        };
        /** @description For video input, the start and end offset of the video in Duration format. For example, to specify a 10 second clip starting at 1:00, set "startOffset": { "seconds": 60 } and "endOffset": { "seconds": 70 }. The metadata should only be specified while the video data is presented in inlineData or fileData. */
        GeminiVideoMetadata: {
            startOffset?: components["schemas"]["GeminiOffset"];
            endOffset?: components["schemas"]["GeminiOffset"];
        };
        /** @description Represents a duration offset for video timeline positions. */
        GeminiOffset: {
            /**
             * @description Signed seconds of the span of time. Must be from -315,576,000,000 to +315,576,000,000 inclusive.
             * @example 60
             */
            seconds?: number;
            /**
             * @description Signed fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values.
             * @example 0
             */
            nanos?: number;
        };
        GeminiCandidate: {
            content?: components["schemas"]["GeminiContent"];
            finishReason?: string;
            safetyRatings?: components["schemas"]["GeminiSafetyRating"][];
            citationMetadata?: components["schemas"]["GeminiCitationMetadata"];
        };
        /**
         * @description The media type of the file specified in the data or fileUri fields. Acceptable values include the following. For gemini-2.0-flash-lite and gemini-2.0-flash, the maximum length of an audio file is 8.4 hours and the maximum length of a video file (without audio) is one hour. For more information, see Gemini audio and video requirements. Text files must be UTF-8 encoded. The contents of the text file count toward the token limit. There is no limit on image resolution.
         * @enum {string}
         */
        GeminiMimeType: "application/pdf" | "audio/mpeg" | "audio/mp3" | "audio/wav" | "image/png" | "image/jpeg" | "image/webp" | "text/plain" | "video/mov" | "video/mpeg" | "video/mp4" | "video/mpg" | "video/avi" | "video/wmv" | "video/mpegps" | "video/flv";
        GeminiPromptFeedback: {
            safetyRatings?: components["schemas"]["GeminiSafetyRating"][];
            blockReason?: string;
            blockReasonMessage?: string;
        };
        GeminiTextPart: {
            /**
             * @description A text prompt or code snippet.
             * @example Answer as concisely as possible
             */
            text?: string;
        };
        GeminiPart: {
            /**
             * @description A text prompt or code snippet.
             * @example Write a story about a robot learning to paint
             */
            text?: string;
            inlineData?: components["schemas"]["GeminiInlineData"];
            fileData?: components["schemas"]["GeminiFileData"];
        };
        GeminiFunctionDeclaration: {
            name: string;
            description?: string;
            /** @description JSON schema for the function parameters */
            parameters: Record<string, never>;
        };
        GeminiSafetyRating: {
            category?: components["schemas"]["GeminiSafetyCategory"];
            /**
             * @description The probability that the content violates the specified safety category
             * @enum {string}
             */
            probability?: "NEGLIGIBLE" | "LOW" | "MEDIUM" | "HIGH" | "UNKNOWN";
        };
        GeminiCitationMetadata: {
            citations?: components["schemas"]["GeminiCitation"][];
        };
        /** @description Inline data in raw bytes. For gemini-2.0-flash-lite and gemini-2.0-flash, you can specify up to 3000 images by using inlineData. */
        GeminiInlineData: {
            mimeType?: components["schemas"]["GeminiMimeType"];
            /**
             * Format: byte
             * @description The base64 encoding of the image, PDF, or video to include inline in the prompt. When including media inline, you must also specify the media type (mimeType) of the data. Size limit: 20MB
             */
            data?: string;
        };
        /** @description URI based data. */
        GeminiFileData: {
            mimeType?: components["schemas"]["GeminiMimeType"];
            /** @description URI */
            fileUri?: string;
        };
        GeminiCitation: {
            startIndex?: number;
            endIndex?: number;
            uri?: string;
            title?: string;
            license?: string;
            /** Format: date */
            publicationDate?: string;
            authors?: string[];
        };
        Rodin3DGenerateRequest: {
            /** @description The reference images to generate 3D Assets. */
            images: string;
            /** @description Seed. */
            seed?: number;
            tier?: components["schemas"]["RodinTierType"];
            material?: components["schemas"]["RodinMaterialType"];
            quality?: components["schemas"]["RodinQualityType"];
            mesh_mode?: components["schemas"]["RodinMeshModeType"];
        };
        /**
         * @description Rodin Tier para options
         * @enum {string}
         */
        RodinTierType: "Regular" | "Sketch" | "Detail" | "Smooth";
        /**
         * @description Rodin Material para options
         * @enum {string}
         */
        RodinMaterialType: "PBR" | "Shaded";
        /**
         * @description Rodin Quality para options
         * @enum {string}
         */
        RodinQualityType: "extra-low" | "low" | "medium" | "high";
        /**
         * @description Rodin Mesh_Mode para options
         * @enum {string}
         */
        RodinMeshModeType: "Quad" | "Raw";
        Rodin3DCheckStatusRequest: {
            /** @description subscription from generate endpoint */
            subscription_key: string;
        };
        Rodin3DDownloadRequest: {
            /** @description Task UUID */
            task_uuid: string;
        };
        Rodin3DGenerateResponse: {
            /** @description message */
            message?: string;
            /** @description prompt */
            prompt?: string;
            /** @description Time */
            submit_time?: string;
            /** @description Task UUID */
            uuid?: string;
            jobs?: components["schemas"]["RodinGenerateJobsData"];
        };
        RodinGenerateJobsData: {
            /** @description subjobs uuid. */
            uuids?: string[];
            /** @description Subscription Key. */
            subscription_key?: string;
        };
        Rodin3DCheckStatusResponse: {
            /** @description Details for the generation status. */
            jobs?: components["schemas"]["RodinCheckStatusJobItem"][];
        };
        RodinCheckStatusJobItem: {
            /** @description sub uuid */
            uuid?: string;
            status?: components["schemas"]["RodinStatusOptions"];
        };
        /** @enum {string} */
        RodinStatusOptions: "Done" | "Failed" | "Generating" | "Waiting";
        Rodin3DDownloadResponse: {
            list?: components["schemas"]["RodinResourceItem"][];
        };
        RodinResourceItem: {
            /** @description Download url */
            url?: string;
            /** @description File name */
            name?: string;
        };
        CreateAPIKeyRequest: {
            name: string;
            description?: string;
        };
        /**
         * @example {
         *       "id": "2a1b2d4eafe2bc6ab4cd4d5c6133f513",
         *       "name": "internal_error",
         *       "errors": [
         *         "An unexpected server error has occurred, please try again later."
         *       ]
         *     }
         */
        StabilityImageGenrationUpscaleFast_Response_500: {
            /**
             * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new)
             *     you file, as it will greatly assist us in diagnosing the root cause of the problem.
             * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
             */
            id: string;
            /**
             * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
             * @example bad_request
             */
            name: string;
            /**
             * @description One or more error messages indicating what went wrong.
             * @example [
             *       "some-field: is required"
             *     ]
             */
            errors: string[];
        };
        /** @description Request parameters for Stable Audio 2.5 text-to-audio generation */
        StableAudio25TextToAudioRequest: {
            /** @description What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results. */
            prompt: string;
            /**
             * @description Controls the duration in seconds of the generated audio.
             * @default 190
             */
            duration: number;
            /**
             * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
             * @default 0
             */
            seed: number;
            /**
             * @description Controls the number of sampling steps. For stable-audio-2.5 accepts steps between 4 and 8 (defaults to 8).
             * @default 8
             */
            steps: number;
            /**
             * @description How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). Defaults to 1 for stable-audio-2.5.
             * @default 1
             */
            cfg_scale: number;
            model: components["schemas"]["StableAudio25Model"];
            output_format?: components["schemas"]["StableAudio25OutputFormat"];
        };
        /** @description Request parameters for Stable Audio audio-to-audio transformation */
        StableAudio25AudioToAudioRequest: {
            /** @description What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results. */
            prompt: string;
            /**
             * Format: binary
             * @description The audio to be used as the starting point for the generation. Supported formats - mp3, wav. Audio must be between 6 and 190 seconds long.
             */
            audio: string;
            /**
             * @description Controls the duration in seconds of the generated audio.
             * @default 190
             */
            duration: number;
            /**
             * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
             * @default 0
             */
            seed: number;
            /**
             * @description Controls the number of sampling steps. For stable-audio-2.5 accepts steps between 4 and 8 (defaults to 8).
             * @default 8
             */
            steps: number;
            /** @description How strictly the diffusion process adheres to the prompt text (higher values make your audio closer to your prompt). Defaults to 7 for stable-audio-2 and 1 for stable-audio-2.5. */
            cfg_scale?: number;
            model: components["schemas"]["StableAudio25Model"];
            output_format?: components["schemas"]["StableAudio25OutputFormat"];
            /**
             * @description Controls how much influence the audio parameter has on the generated audio. A value of 0 would yield audio that is identical to the input. A value of 1 would be as if you passed in no audio at all. Minimum value for stable-audio-2.5 is 0.01.
             * @default 1
             */
            strength: number;
        };
        /** @description Request parameters for Stable Audio 2.5 audio inpainting */
        StableAudio25InpaintRequest: {
            /** @description What you wish the output audio to be. A strong, descriptive prompt that clearly defines instruments, moods, styles, and genre will lead to better results. */
            prompt: string;
            /**
             * Format: binary
             * @description The audio to be used as the starting point for the generation. Supported formats - mp3, wav. Audio must be between 6 and 190 seconds long.
             */
            audio: string;
            /**
             * @description Controls the duration in seconds of the generated audio.
             * @default 190
             */
            duration: number;
            /**
             * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass 0 to use a random seed.)
             * @default 0
             */
            seed: number;
            /**
             * @description Controls the number of sampling steps.
             * @default 8
             */
            steps: number;
            output_format?: components["schemas"]["StableAudio25OutputFormat"];
            /**
             * @description Start time in seconds for the audio segment to be inpainted.
             * @default 30
             */
            mask_start: number;
            /**
             * @description End time in seconds for the audio segment to be inpainted.
             * @default 190
             */
            mask_end: number;
        };
        /** @description Response from Stable Audio 2.5 audio generation */
        StableAudio25AudioResponse: {
            /** @description Unique identifier for the generation request */
            id?: string;
            /**
             * Format: byte
             * @description Base64-encoded audio data
             */
            audio?: string;
            /**
             * @description Reason for completion
             * @enum {string}
             */
            finish_reason?: "SUCCESS" | "ERROR" | "CONTENT_FILTERED";
        };
        /**
         * @description The model to use for generation
         * @enum {string}
         */
        StableAudio25Model: "stable-audio-2.5";
        /**
         * @description Dictates the content-type of the generated audio
         * @enum {string}
         */
        StableAudio25OutputFormat: "mp3" | "wav";
        /** @description Common properties for model responses */
        ModelResponseProperties: {
            /** @description The model used to generate the response */
            model?: string;
            /** @description Instructions for the model on how to generate the response */
            instructions?: string;
            /** @description Maximum number of tokens to generate */
            max_output_tokens?: number;
            /**
             * @description Controls randomness in the response
             * @default 1
             */
            temperature: number;
            /**
             * @description Controls diversity of the response via nucleus sampling
             * @default 1
             */
            top_p: number;
            /**
             * @description How to handle truncation of the response
             * @default disabled
             * @enum {string}
             */
            truncation: "disabled" | "auto";
        };
        /**
         * Input file
         * @description A file input to the model.
         */
        InputFileContent: {
            /**
             * @description The type of the input item. Always `input_file`.
             * @default input_file
             * @enum {string}
             */
            type: "input_file";
            /** @description The ID of the file to be sent to the model. */
            file_id?: string;
            /** @description The name of the file to be sent to the model. */
            filename?: string;
            /** @description The content of the file to be sent to the model. */
            file_data?: string;
        };
        ResponseProperties: {
            /**
             * @description The unique ID of the previous response to the model. Use this to
             *     create multi-turn conversations. Learn more about
             *     [conversation state](/docs/guides/conversation-state).
             */
            previous_response_id?: string;
            /**
             * @description Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI
             *     offers a wide range of models with different capabilities, performance
             *     characteristics, and price points. Refer to the [model guide](/docs/models)
             *     to browse and compare available models.
             */
            model?: components["schemas"]["OpenAIModels"];
            reasoning?: components["schemas"]["Reasoning"];
            /** @description An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning). */
            max_output_tokens?: number;
            /**
             * @description Inserts a system (or developer) message as the first item in the model's context.
             *
             *     When using along with `previous_response_id`, the instructions from a previous
             *     response will not be carried over to the next response. This makes it simple
             *     to swap out system (or developer) messages in new responses.
             */
            instructions?: string;
            text?: {
                format?: components["schemas"]["TextResponseFormatConfiguration"];
            };
            tools?: components["schemas"]["Tool"][];
            /**
             * @description How the model should select which tool (or tools) to use when generating
             *     a response. See the `tools` parameter to see how to specify which tools
             *     the model can call.
             */
            tool_choice?: components["schemas"]["ToolChoiceOptions"] | components["schemas"]["ToolChoiceTypes"] | components["schemas"]["ToolChoiceFunction"];
            /**
             * @description The truncation strategy to use for the model response.
             *     - `auto`: If the context of this response and previous ones exceeds
             *       the model's context window size, the model will truncate the
             *       response to fit the context window by dropping input items in the
             *       middle of the conversation.
             *     - `disabled` (default): If a model response will exceed the context window
             *       size for a model, the request will fail with a 400 error.
             * @default disabled
             * @enum {string}
             */
            truncation: "auto" | "disabled";
        };
        /**
         * @description An object specifying the format that the model must output.
         *
         *     Configuring `{ "type": "json_schema" }` enables Structured Outputs,
         *     which ensures the model will match your supplied JSON schema. Learn more in the
         *     [Structured Outputs guide](/docs/guides/structured-outputs).
         *
         *     The default format is `{ "type": "text" }` with no additional options.
         *
         *     **Not recommended for gpt-4o and newer models:**
         *
         *     Setting to `{ "type": "json_object" }` enables the older JSON mode, which
         *     ensures the message the model generates is valid JSON. Using `json_schema`
         *     is preferred for models that support it.
         */
        TextResponseFormatConfiguration: components["schemas"]["ResponseFormatText"] | components["schemas"]["TextResponseFormatJsonSchema"] | components["schemas"]["ResponseFormatJsonObject"];
        /**
         * JSON object
         * @description JSON object response format. An older method of generating JSON responses.
         *     Using `json_schema` is recommended for models that support it. Note that the
         *     model will not generate JSON without a system or user message instructing it
         *     to do so.
         */
        ResponseFormatJsonObject: {
            /**
             * @description The type of response format being defined. Always `json_object`.
             * @enum {string}
             */
            type: "json_object";
        };
        /**
         * JSON schema
         * @description JSON Schema response format. Used to generate structured JSON responses.
         *     Learn more about [Structured Outputs](/docs/guides/structured-outputs).
         */
        ResponseFormatJsonSchema: {
            /** @default json_schema */
            type: string;
            /**
             * JSON schema
             * @description Structured Outputs configuration options, including a JSON Schema.
             */
            json_schema: {
                /**
                 * @description A description of what the response format is for, used by the model to
                 *     determine how to respond in the format.
                 */
                description?: string;
                /**
                 * @description The name of the response format. Must be a-z, A-Z, 0-9, or contain
                 *     underscores and dashes, with a maximum length of 64.
                 */
                name: string;
                schema?: components["schemas"]["ResponseFormatJsonSchemaSchema"];
                /**
                 * @description Whether to enable strict schema adherence when generating the output.
                 *     If set to true, the model will always follow the exact schema defined
                 *     in the `schema` field. Only a subset of JSON Schema is supported when
                 *     `strict` is `true`. To learn more, read the [Structured Outputs
                 *     guide](/docs/guides/structured-outputs).
                 * @default false
                 */
                strict: boolean;
            };
        };
        /**
         * JSON schema
         * @description The schema for the response format, described as a JSON Schema object.
         *     Learn how to build JSON schemas [here](https://json-schema.org/).
         */
        ResponseFormatJsonSchemaSchema: {
            [key: string]: unknown;
        };
        /**
         * Text
         * @description Default response format. Used to generate text responses.
         */
        ResponseFormatText: {
            /**
             * @description The type of response format being defined. Always `text`.
             * @enum {string}
             */
            type: "text";
        };
        /**
         * JSON schema
         * @description JSON Schema response format. Used to generate structured JSON responses.
         *     Learn more about [Structured Outputs](/docs/guides/structured-outputs).
         */
        TextResponseFormatJsonSchema: {
            /**
             * @description The type of response format being defined. Always `json_schema`.
             * @enum {string}
             */
            type: "json_schema";
            /**
             * @description A description of what the response format is for, used by the model to
             *     determine how to respond in the format.
             */
            description?: string;
            /**
             * @description The name of the response format. Must be a-z, A-Z, 0-9, or contain
             *     underscores and dashes, with a maximum length of 64.
             */
            name: string;
            schema: components["schemas"]["ResponseFormatJsonSchemaSchema"];
            /**
             * @description Whether to enable strict schema adherence when generating the output.
             *     If set to true, the model will always follow the exact schema defined
             *     in the `schema` field. Only a subset of JSON Schema is supported when
             *     `strict` is `true`. To learn more, read the [Structured Outputs
             *     guide](/docs/guides/structured-outputs).
             * @default false
             */
            strict: boolean;
        };
        /**
         * Reasoning
         * @description **o-series models only**
         *
         *     Configuration options for
         *     [reasoning models](https://platform.openai.com/docs/guides/reasoning).
         */
        Reasoning: {
            effort?: components["schemas"]["ReasoningEffort"];
            /**
             * @description A summary of the reasoning performed by the model. This can be
             *     useful for debugging and understanding the model's reasoning process.
             *     One of `auto`, `concise`, or `detailed`.
             * @enum {string}
             */
            summary?: "auto" | "concise" | "detailed";
            /**
             * @deprecated
             * @description **Deprecated:** use `summary` instead.
             *
             *     A summary of the reasoning performed by the model. This can be
             *     useful for debugging and understanding the model's reasoning process.
             *     One of `auto`, `concise`, or `detailed`.
             * @enum {string}
             */
            generate_summary?: "auto" | "concise" | "detailed";
        };
        /**
         * @description **o-series models only**
         *
         *     Constrains effort on reasoning for
         *     [reasoning models](https://platform.openai.com/docs/guides/reasoning).
         *     Currently supported values are `low`, `medium`, and `high`. Reducing
         *     reasoning effort can result in faster responses and fewer tokens used
         *     on reasoning in a response.
         * @default medium
         * @enum {string}
         */
        ReasoningEffort: "low" | "medium" | "high";
        /**
         * Web search preview
         * @description This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search).
         */
        WebSearchPreviewTool: {
            /**
             * @description The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "WebSearchPreviewTool";
            /**
             * @description High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default.
             * @enum {string}
             */
            search_context_size?: "low" | "medium" | "high";
        };
        /**
         * Computer use preview
         * @description A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use).
         */
        ComputerUsePreviewTool: {
            /**
             * @description The type of the computer use tool. Always `computer_use_preview`. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "ComputerUsePreviewTool";
            /**
             * @description The type of computer environment to control.
             * @enum {string}
             */
            environment: "windows" | "mac" | "linux" | "ubuntu" | "browser";
            /** @description The width of the computer display. */
            display_width: number;
            /** @description The height of the computer display. */
            display_height: number;
        };
        Tool: components["schemas"]["FileSearchTool"] | components["schemas"]["FunctionTool"] | components["schemas"]["WebSearchPreviewTool"] | components["schemas"]["ComputerUsePreviewTool"];
        /** @description Emitted when an error occurs. */
        ResponseErrorEvent: {
            /**
             * @description The type of the event. Always `error`.
             * @enum {string}
             */
            type: "error";
            /** @description The error code. */
            code: string;
            /** @description The error message. */
            message: string;
            /** @description The error parameter. */
            param: string;
        };
        /** @description Emitted when a new output item is added. */
        ResponseOutputItemAddedEvent: {
            /**
             * @description The type of the event. Always `response.output_item.added`.
             * @enum {string}
             */
            type: "response.output_item.added";
            /** @description The index of the output item that was added. */
            output_index: number;
            /** @description The output item that was added. */
            item: components["schemas"]["OutputItem"];
        };
        /** @description Emitted when an output item is marked done. */
        ResponseOutputItemDoneEvent: {
            /**
             * @description The type of the event. Always `response.output_item.done`.
             * @enum {string}
             */
            type: "response.output_item.done";
            /** @description The index of the output item that was marked done. */
            output_index: number;
            /** @description The output item that was marked done. */
            item: components["schemas"]["OutputItem"];
        };
        /**
         * Function tool
         * @description Use this option to force the model to call a specific function.
         */
        ToolChoiceFunction: {
            /**
             * @description For function calling, the type is always `function`.
             * @enum {string}
             */
            type: "function";
            /** @description The name of the function to call. */
            name: string;
        };
        /**
         * Tool choice mode
         * @description Controls which (if any) tool is called by the model.
         *
         *     `none` means the model will not call any tool and instead generates a message.
         *
         *     `auto` means the model can pick between generating a message or calling one or
         *     more tools.
         *
         *     `required` means the model must call one or more tools.
         * @enum {string}
         */
        ToolChoiceOptions: "none" | "auto" | "required";
        /**
         * Hosted tool
         * @description Indicates that the model should use a built-in tool to generate a response.
         *     [Learn more about built-in tools](/docs/guides/tools).
         */
        ToolChoiceTypes: {
            /**
             * @description The type of hosted tool the model should to use. Learn more about
             *     [built-in tools](/docs/guides/tools).
             *
             *     Allowed values are:
             *     - `file_search`
             *     - `web_search_preview`
             *     - `computer_use_preview`
             * @enum {string}
             */
            type: "file_search" | "web_search_preview" | "computer_use_preview" | "web_search_preview_2025_03_11";
        };
        /** @description An event that is emitted when a response fails. */
        ResponseFailedEvent: {
            /**
             * @description The type of the event. Always `response.failed`.
             * @enum {string}
             */
            type: "response.failed";
            /** @description The response that failed. */
            response: components["schemas"]["OpenAIResponse"];
        };
        /** @description Emitted when the response is in progress. */
        ResponseInProgressEvent: {
            /**
             * @description The type of the event. Always `response.in_progress`.
             * @enum {string}
             */
            type: "response.in_progress";
            /** @description The response that is in progress. */
            response: components["schemas"]["OpenAIResponse"];
        };
        /** @description An event that is emitted when a response finishes as incomplete. */
        ResponseIncompleteEvent: {
            /**
             * @description The type of the event. Always `response.incomplete`.
             * @enum {string}
             */
            type: "response.incomplete";
            /** @description The response that was incomplete. */
            response: components["schemas"]["OpenAIResponse"];
        };
        /** @description An event that is emitted when a response is created. */
        ResponseCreatedEvent: {
            /**
             * @description The type of the event. Always `response.created`.
             * @enum {string}
             */
            type: "response.created";
            /** @description The response that was created. */
            response: components["schemas"]["OpenAIResponse"];
        };
        /** @description Emitted when the model response is complete. */
        ResponseCompletedEvent: {
            /**
             * @description The type of the event. Always `response.completed`.
             * @enum {string}
             */
            type: "response.completed";
            /** @description Properties of the completed response. */
            response: components["schemas"]["OpenAIResponse"];
        };
        /** @description Emitted when a new content part is added. */
        ResponseContentPartAddedEvent: {
            /**
             * @description The type of the event. Always `response.content_part.added`.
             * @enum {string}
             */
            type: "response.content_part.added";
            /** @description The ID of the output item that the content part was added to. */
            item_id: string;
            /** @description The index of the output item that the content part was added to. */
            output_index: number;
            /** @description The index of the content part that was added. */
            content_index: number;
            /** @description The content part that was added. */
            part: components["schemas"]["OutputContent"];
        };
        /** @description Emitted when a content part is done. */
        ResponseContentPartDoneEvent: {
            /**
             * @description The type of the event. Always `response.content_part.done`.
             * @enum {string}
             */
            type: "response.content_part.done";
            /** @description The ID of the output item that the content part was added to. */
            item_id: string;
            /** @description The index of the output item that the content part was added to. */
            output_index: number;
            /** @description The index of the content part that is done. */
            content_index: number;
            /** @description The content part that is done. */
            part: components["schemas"]["OutputContent"];
        };
        ResponseTool: components["schemas"]["WebSearchTool"] | components["schemas"]["FileSearchTool"] | components["schemas"]["FunctionTool"];
        WebSearchTool: {
            /**
             * @description The type of tool
             * @enum {string}
             */
            type: "web_search";
            /** @description Optional list of domains to restrict search to */
            domains?: string[];
        };
        FileSearchTool: {
            /**
             * @description The type of tool (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "FileSearchTool";
            /** @description IDs of vector stores to search in */
            vector_store_ids: string[];
        };
        FunctionTool: {
            /**
             * @description The type of tool (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "FunctionTool";
            /** @description Name of the function */
            name: string;
            /** @description Description of what the function does */
            description?: string;
            /** @description JSON Schema object describing the function parameters */
            parameters: Record<string, never>;
        };
        OutputItem: components["schemas"]["OutputMessage"] | components["schemas"]["FileSearchToolCall"] | components["schemas"]["FunctionToolCall"] | components["schemas"]["WebSearchToolCall"] | components["schemas"]["ComputerToolCall"] | components["schemas"]["ReasoningItem"];
        /**
         * Web search tool call
         * @description The results of a web search tool call. See the
         *     [web search guide](/docs/guides/tools-web-search) for more information.
         */
        WebSearchToolCall: {
            /** @description The unique ID of the web search tool call. */
            id: string;
            /**
             * @description The type of the web search tool call. Always `web_search_call`.
             *      (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "WebSearchToolCall";
            /**
             * @description The status of the web search tool call.
             * @enum {string}
             */
            status: "in_progress" | "searching" | "completed" | "failed";
        };
        /**
         * File search tool call
         * @description The results of a file search tool call. See the
         *     [file search guide](/docs/guides/tools-file-search) for more information.
         */
        FileSearchToolCall: {
            /** @description The unique ID of the file search tool call. */
            id: string;
            /**
             * @description The type of the file search tool call. Always `file_search_call`.
             *      (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "FileSearchToolCall";
            /**
             * @description The status of the file search tool call. One of `in_progress`,
             *     `searching`, `incomplete` or `failed`,
             * @enum {string}
             */
            status: "in_progress" | "searching" | "completed" | "incomplete" | "failed";
            /** @description The queries used to search for files. */
            queries: string[];
            /** @description The results of the file search tool call. */
            results?: {
                /** @description The unique ID of the file. */
                file_id?: string;
                /** @description The text that was retrieved from the file. */
                text?: string;
                /** @description The name of the file. */
                filename?: string;
                /**
                 * Format: float
                 * @description The relevance score of the file - a value between 0 and 1.
                 */
                score?: number;
            }[];
        };
        /**
         * Function tool call
         * @description A tool call to run a function. See the
         *     [function calling guide](/docs/guides/function-calling) for more information.
         */
        FunctionToolCall: {
            /** @description The unique ID of the function tool call. */
            id?: string;
            /**
             * @description The type of the function tool call. Always `function_call`.
             * @enum {string}
             */
            type: "function_call";
            /** @description The unique ID of the function tool call generated by the model. */
            call_id: string;
            /** @description The name of the function to run. */
            name: string;
            /** @description A JSON string of the arguments to pass to the function. */
            arguments: string;
            /**
             * @description The status of the item. One of `in_progress`, `completed`, or
             *     `incomplete`. Populated when items are returned via API.
             * @enum {string}
             */
            status?: "in_progress" | "completed" | "incomplete";
        };
        OutputMessage: {
            /**
             * @description The type of output item (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "OutputMessage";
            /**
             * @description The role of the message
             * @enum {string}
             */
            role: "assistant";
            /** @description The content of the message */
            content: components["schemas"]["OutputContent"][];
        };
        OutputContent: components["schemas"]["OutputTextContent"] | components["schemas"]["OutputAudioContent"];
        OutputTextContent: {
            /**
             * @description The type of output content
             * @enum {string}
             */
            type: "output_text";
            /** @description The text content */
            text: string;
        };
        OutputAudioContent: {
            /**
             * @description The type of output content
             * @enum {string}
             */
            type: "output_audio";
            /** @description Base64-encoded audio data */
            data: string;
            /** @description Transcript of the audio */
            transcript: string;
        };
        /**
         * @description Represents token usage details including input tokens, output tokens,
         *     a breakdown of output tokens, and the total tokens used.
         */
        ResponseUsage: {
            /** @description The number of input tokens. */
            input_tokens: number;
            /** @description A detailed breakdown of the input tokens. */
            input_tokens_details: {
                /**
                 * @description The number of tokens that were retrieved from the cache.
                 *     [More on prompt caching](/docs/guides/prompt-caching).
                 */
                cached_tokens: number;
            };
            /** @description The number of output tokens. */
            output_tokens: number;
            /** @description A detailed breakdown of the output tokens. */
            output_tokens_details: {
                /** @description The number of reasoning tokens. */
                reasoning_tokens: number;
            };
            /** @description The total number of tokens used. */
            total_tokens: number;
        };
        /** @description A response from the model */
        OpenAIResponse: components["schemas"]["ModelResponseProperties"] & components["schemas"]["ResponseProperties"] & {
            /** @description Unique identifier for this Response. */
            id?: string;
            /**
             * @description The object type of this resource - always set to `response`.
             * @enum {string}
             */
            object?: "response";
            /**
             * @description The status of the response generation. One of `completed`, `failed`, `in_progress`, or `incomplete`.
             * @enum {string}
             */
            status?: "completed" | "failed" | "in_progress" | "incomplete";
            /** @description Unix timestamp (in seconds) of when this Response was created. */
            created_at?: number;
            error?: components["schemas"]["ResponseError"];
            /** @description Details about why the response is incomplete. */
            incomplete_details?: {
                /**
                 * @description The reason why the response is incomplete.
                 * @enum {string}
                 */
                reason?: "max_output_tokens" | "content_filter";
            } | null;
            /**
             * @description An array of content items generated by the model.
             *
             *     - The length and order of items in the `output` array is dependent
             *       on the model's response.
             *     - Rather than accessing the first item in the `output` array and
             *       assuming it's an `assistant` message with the content generated by
             *       the model, you might consider using the `output_text` property where
             *       supported in SDKs.
             */
            output?: components["schemas"]["OutputItem"][];
            /**
             * @description SDK-only convenience property that contains the aggregated text output
             *     from all `output_text` items in the `output` array, if any are present.
             *     Supported in the Python and JavaScript SDKs.
             */
            output_text?: string | null;
            usage?: components["schemas"]["ResponseUsage"];
            /**
             * @description Whether to allow the model to run tool calls in parallel.
             * @default true
             */
            parallel_tool_calls: boolean;
        };
        /** @description An error object returned when the model fails to generate a Response. */
        ResponseError: {
            code: components["schemas"]["ResponseErrorCode"];
            /** @description A human-readable description of the error. */
            message: string;
        };
        /**
         * @description The error code for the response.
         * @enum {string}
         */
        ResponseErrorCode: "server_error" | "rate_limit_exceeded" | "invalid_prompt" | "vector_store_timeout" | "invalid_image" | "invalid_image_format" | "invalid_base64_image" | "invalid_image_url" | "image_too_large" | "image_too_small" | "image_parse_error" | "image_content_policy_violation" | "invalid_image_mode" | "image_file_too_large" | "unsupported_image_media_type" | "empty_image_file" | "failed_to_download_image" | "image_file_not_found";
        /** @description Events that can be emitted during response streaming */
        OpenAIResponseStreamEvent: components["schemas"]["ResponseCreatedEvent"] | components["schemas"]["ResponseInProgressEvent"] | components["schemas"]["ResponseCompletedEvent"] | components["schemas"]["ResponseFailedEvent"] | components["schemas"]["ResponseIncompleteEvent"] | components["schemas"]["ResponseOutputItemAddedEvent"] | components["schemas"]["ResponseOutputItemDoneEvent"] | components["schemas"]["ResponseContentPartAddedEvent"] | components["schemas"]["ResponseContentPartDoneEvent"] | components["schemas"]["ResponseErrorEvent"];
        InputMessage: {
            /** @enum {string} */
            type?: "message";
            /** @enum {string} */
            role?: "user" | "system" | "developer";
            /** @enum {string} */
            status?: "in_progress" | "completed" | "incomplete";
            content?: components["schemas"]["InputMessageContentList"];
        };
        /**
         * Input item content list
         * @description A list of one or many input items to the model, containing different content
         *     types.
         */
        InputMessageContentList: components["schemas"]["InputContent"][];
        InputContent: components["schemas"]["InputTextContent"] | components["schemas"]["InputImageContent"] | components["schemas"]["InputFileContent"];
        /**
         * Input text
         * @description A text input to the model.
         */
        InputTextContent: {
            /**
             * @description The type of the input item. Always `input_text`.
             * @default input_text
             * @enum {string}
             */
            type: "input_text";
            /** @description The text input to the model. */
            text: string;
        };
        /**
         * Input image
         * @description An image input to the model. Learn about [image inputs](/docs/guides/vision).
         */
        InputImageContent: {
            /**
             * @description The type of the input item. Always `input_image`.
             * @default input_image
             * @enum {string}
             */
            type: "input_image";
            /** @description The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL. */
            image_url?: string;
            /** @description The ID of the file to be sent to the model. */
            file_id?: string;
            /**
             * @description The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.
             * @enum {string}
             */
            detail: "low" | "high" | "auto";
        };
        InputMessageResource: components["schemas"]["InputMessage"] & {
            /** @description The unique ID of the message input. */
            id: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "InputMessageResource";
        };
        /** @description Content item used to generate a response. */
        ItemResource: components["schemas"]["InputMessageResource"] | components["schemas"]["OutputMessage"] | components["schemas"]["FileSearchToolCall"] | components["schemas"]["ComputerToolCall"] | components["schemas"]["WebSearchToolCall"] | components["schemas"]["FunctionToolCallResource"];
        FunctionToolCallResource: components["schemas"]["FunctionToolCall"] & {
            /** @description The unique ID of the function tool call. */
            id: string;
        } & {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "FunctionToolCallResource";
        };
        /**
         * Computer tool call
         * @description A tool call to a computer use tool. See the
         *     [computer use guide](/docs/guides/tools-computer-use) for more information.
         */
        ComputerToolCall: {
            /**
             * @description The type of the computer call. Always `computer_call`. (enum property replaced by openapi-typescript)
             * @enum {string}
             */
            type: "ComputerToolCall";
            /** @description The unique ID of the computer call. */
            id: string;
            /** @description An identifier used when responding to the tool call with output. */
            call_id: string;
            action: Record<string, never>;
            /**
             * @description The status of the item. One of `in_progress`, `completed`, or
             *     `incomplete`. Populated when items are returned via API.
             * @enum {string}
             */
            status: "in_progress" | "completed" | "incomplete";
        };
        /** @description A list of Response items. */
        ResponseItemList: {
            /**
             * @description The type of object returned, must be `list`.
             * @enum {string}
             */
            object: "list";
            /** @description A list of items used to generate this response. */
            data: components["schemas"]["ItemResource"][];
            /** @description Whether there are more items available. */
            has_more: boolean;
            /** @description The ID of the first item in the list. */
            first_id: string;
            /** @description The ID of the last item in the list. */
            last_id: string;
        };
        /**
         * @description Specify additional output data to include in the model response. Currently
         *     supported values are:
         *     - `file_search_call.results`: Include the search results of
         *       the file search tool call.
         *     - `message.input_image.image_url`: Include image urls from the input message.
         *     - `computer_call_output.output.image_url`: Include image urls from the computer call output.
         * @enum {string}
         */
        Includable: "file_search_call.results" | "message.input_image.image_url" | "computer_call_output.output.image_url";
        CreateModelResponseProperties: components["schemas"]["ModelResponseProperties"];
        InputItem: components["schemas"]["EasyInputMessage"] | components["schemas"]["Item"];
        /** @description Content item used to generate a response. */
        Item: components["schemas"]["InputMessage"] | components["schemas"]["OutputMessage"] | components["schemas"]["FileSearchToolCall"] | components["schemas"]["ComputerToolCall"] | components["schemas"]["WebSearchToolCall"] | components["schemas"]["FunctionToolCall"] | components["schemas"]["ReasoningItem"];
        /**
         * Reasoning
         * @description A description of the chain of thought used by a reasoning model while generating
         *     a response.
         */
        ReasoningItem: {
            /**
             * @description The type of the object. Always `reasoning`.
             * @enum {string}
             */
            type: "reasoning";
            /** @description The unique identifier of the reasoning content. */
            id: string;
            /** @description Reasoning text contents. */
            summary: {
                /**
                 * @description The type of the object. Always `summary_text`.
                 * @enum {string}
                 */
                type: "summary_text";
                /**
                 * @description A short summary of the reasoning used by the model when generating
                 *     the response.
                 */
                text: string;
            }[];
            /**
             * @description The status of the item. One of `in_progress`, `completed`, or
             *     `incomplete`. Populated when items are returned via API.
             * @enum {string}
             */
            status?: "in_progress" | "completed" | "incomplete";
        };
        /**
         * Input message
         * @description A message input to the model with a role indicating instruction following
         *     hierarchy. Instructions given with the `developer` or `system` role take
         *     precedence over instructions given with the `user` role. Messages with the
         *     `assistant` role are presumed to have been generated by the model in previous
         *     interactions.
         */
        EasyInputMessage: {
            /**
             * @description The role of the message input. One of `user`, `assistant`, `system`, or
             *     `developer`.
             * @enum {string}
             */
            role: "user" | "assistant" | "system" | "developer";
            /**
             * @description Text, image, or audio input to the model, used to generate a response.
             *     Can also contain previous assistant responses.
             */
            content: string | components["schemas"]["InputMessageContentList"];
            /**
             * @description The type of the message input. Always `message`.
             * @enum {string}
             */
            type?: "message";
        };
        OpenAICreateResponse: components["schemas"]["CreateModelResponseProperties"] & components["schemas"]["ResponseProperties"] & {
            /**
             * @description Text, image, or file inputs to the model, used to generate a response.
             *
             *     Learn more:
             *     - [Text inputs and outputs](/docs/guides/text)
             *     - [Image inputs](/docs/guides/images)
             *     - [File inputs](/docs/guides/pdf-files)
             *     - [Conversation state](/docs/guides/conversation-state)
             *     - [Function calling](/docs/guides/function-calling)
             */
            input: string | components["schemas"]["InputItem"][];
            /**
             * @description Specify additional output data to include in the model response. Currently
             *     supported values are:
             *     - `file_search_call.results`: Include the search results of
             *       the file search tool call.
             *     - `message.input_image.image_url`: Include image urls from the input message.
             *     - `computer_call_output.output.image_url`: Include image urls from the computer call output.
             */
            include?: components["schemas"]["Includable"][] | null;
            usage?: components["schemas"]["ResponseUsage"];
            /**
             * @description Whether to allow the model to run tool calls in parallel.
             * @default true
             */
            parallel_tool_calls: boolean | null;
            /**
             * @description Whether to store the generated model response for later retrieval via
             *     API.
             * @default true
             */
            store: boolean | null;
            /**
             * @description If set to true, the model response data will be streamed to the client
             *     as it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).
             *     See the [Streaming section below](/docs/api-reference/responses-streaming)
             *     for more information.
             * @default false
             */
            stream: boolean | null;
        };
        /** @enum {string} */
        OpenAIModels: "gpt-4" | "gpt-4-0314" | "gpt-4-0613" | "gpt-4-32k" | "gpt-4-32k-0314" | "gpt-4-32k-0613" | "gpt-4-0125-preview" | "gpt-4-turbo" | "gpt-4-turbo-2024-04-09" | "gpt-4-turbo-preview" | "gpt-4-1106-preview" | "gpt-4-vision-preview" | "gpt-3.5-turbo" | "gpt-3.5-turbo-16k" | "gpt-3.5-turbo-0301" | "gpt-3.5-turbo-0613" | "gpt-3.5-turbo-1106" | "gpt-3.5-turbo-0125" | "gpt-3.5-turbo-16k-0613" | "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-4.1-2025-04-14" | "gpt-4.1-mini-2025-04-14" | "gpt-4.1-nano-2025-04-14" | "o1" | "o1-mini" | "o1-preview" | "o1-pro" | "o1-2024-12-17" | "o1-preview-2024-09-12" | "o1-mini-2024-09-12" | "o1-pro-2025-03-19" | "o3" | "o3-mini" | "o3-2025-04-16" | "o3-mini-2025-01-31" | "o4-mini" | "o4-mini-2025-04-16" | "gpt-4o" | "gpt-4o-mini" | "gpt-4o-2024-11-20" | "gpt-4o-2024-08-06" | "gpt-4o-2024-05-13" | "gpt-4o-mini-2024-07-18" | "gpt-4o-audio-preview" | "gpt-4o-audio-preview-2024-10-01" | "gpt-4o-audio-preview-2024-12-17" | "gpt-4o-mini-audio-preview" | "gpt-4o-mini-audio-preview-2024-12-17" | "gpt-4o-search-preview" | "gpt-4o-mini-search-preview" | "gpt-4o-search-preview-2025-03-11" | "gpt-4o-mini-search-preview-2025-03-11" | "computer-use-preview" | "computer-use-preview-2025-03-11" | "gpt-5" | "gpt-5-mini" | "gpt-5-nano" | "chatgpt-4o-latest";
        MoonvalleyTextToVideoInferenceParams: {
            /**
             * @description Height of the generated video in pixels
             * @default 1080
             */
            height: number;
            /**
             * @description Width of the generated video in pixels
             * @default 1920
             */
            width: number;
            /**
             * Format: float
             * @description Guidance scale for generation control
             * @default 10
             */
            guidance_scale: number;
            /**
             * @description Random seed for generation (default: random)
             * @default 9
             */
            seed: number;
            /**
             * @description Number of denoising steps
             * @default 80
             */
            steps: number;
            /**
             * @description Whether to use negative prompts
             * @default true
             */
            use_negative_prompts: boolean;
            /** @description Negative prompt text */
            negative_prompt?: string;
        };
        MoonvalleyVideoToVideoInferenceParams: {
            /**
             * Format: float
             * @description Guidance scale for generation control
             * @default 10
             */
            guidance_scale: number;
            /**
             * @description Random seed for generation (default: random)
             * @default 9
             */
            seed: number;
            /**
             * @description Number of denoising steps
             * @default 80
             */
            steps: number;
            /**
             * @description Whether to use negative prompts
             * @default true
             */
            use_negative_prompts: boolean;
            /** @description Negative prompt text */
            negative_prompt?: string;
            control_params?: {
                /**
                 * Format: int32
                 * @description Intensity of motion control
                 * @default 6
                 */
                motion_intensity: number;
            };
        };
        MoonvalleyTextToImageRequest: {
            prompt_text?: string;
            image_url?: string;
            inference_params?: components["schemas"]["MoonvalleyTextToVideoInferenceParams"];
            webhook_url?: string;
        };
        MoonvalleyTextToVideoRequest: {
            prompt_text?: string;
            image_url?: string;
            inference_params?: components["schemas"]["MoonvalleyTextToVideoInferenceParams"];
            webhook_url?: string;
        };
        MoonvalleyVideoToVideoRequest: {
            /** @description Describes the video to generate */
            prompt_text: string;
            /** @description Url to control video */
            video_url: string;
            /**
             * @description Supported types for video control
             * @enum {string}
             */
            control_type: "motion_control" | "pose_control";
            /** @description Url to control image */
            image_url?: string;
            /** @description Parameters for video-to-video generation inference */
            inference_params?: components["schemas"]["MoonvalleyVideoToVideoInferenceParams"];
            /** @description Optional webhook URL for notifications */
            webhook_url?: string;
        };
        MoonvalleyPromptResponse: {
            id?: string;
            status?: string;
            prompt_text?: string;
            output_url?: string;
            inference_params?: Record<string, never>;
            model_params?: Record<string, never>;
            meta?: Record<string, never>;
            frame_conditioning?: Record<string, never>;
            error?: Record<string, never>;
        };
        MoonvalleyImageToVideoRequest: components["schemas"]["MoonvalleyTextToVideoRequest"] & {
            keyframes?: {
                [key: string]: {
                    image_url?: string;
                };
            };
        };
        MoonvalleyResizeVideoRequest: components["schemas"]["MoonvalleyVideoToVideoRequest"] & {
            frame_position?: number[];
            frame_resolution?: number[];
            scale?: number[];
        };
        MoonvalleyUploadFileRequest: {
            /** Format: binary */
            file?: string;
        };
        MoonvalleyUploadFileResponse: {
            access_url?: string;
        };
        /** @description GitHub release webhook payload based on official webhook documentation */
        GithubReleaseWebhook: {
            /**
             * @description The action performed on the release
             * @enum {string}
             */
            action: "published" | "unpublished" | "created" | "edited" | "deleted" | "prereleased" | "released";
            /** @description The release object */
            release: {
                /** @description The ID of the release */
                id: number;
                /** @description The node ID of the release */
                node_id: string;
                /** @description The API URL of the release */
                url: string;
                /** @description The HTML URL of the release */
                html_url: string;
                /** @description The URL to the release assets */
                assets_url?: string;
                /** @description The URL to upload release assets */
                upload_url?: string;
                /** @description The tag name of the release */
                tag_name: string;
                /** @description The branch or commit the release was created from */
                target_commitish: string;
                /** @description The name of the release */
                name?: string | null;
                /** @description The release notes/body */
                body?: string | null;
                /** @description Whether the release is a draft */
                draft: boolean;
                /** @description Whether the release is a prerelease */
                prerelease: boolean;
                /**
                 * Format: date-time
                 * @description When the release was created
                 */
                created_at: string;
                /**
                 * Format: date-time
                 * @description When the release was published
                 */
                published_at?: string | null;
                author: components["schemas"]["GithubUser"];
                /** @description URL to the tarball */
                tarball_url: string;
                /** @description URL to the zipball */
                zipball_url: string;
                /** @description Array of release assets */
                assets: components["schemas"]["GithubReleaseAsset"][];
            };
            repository: components["schemas"]["GithubRepository"];
            sender: components["schemas"]["GithubUser"];
            organization?: components["schemas"]["GithubOrganization"];
            installation?: components["schemas"]["GithubInstallation"];
            enterprise?: components["schemas"]["GithubEnterprise"];
        };
        /** @description A GitHub user */
        GithubUser: {
            /** @description The user's login name */
            login: string;
            /** @description The user's ID */
            id: number;
            /** @description The user's node ID */
            node_id: string;
            /** @description URL to the user's avatar */
            avatar_url: string;
            /** @description The user's gravatar ID */
            gravatar_id?: string | null;
            /** @description The API URL of the user */
            url: string;
            /** @description The HTML URL of the user */
            html_url: string;
            /**
             * @description The type of user
             * @enum {string}
             */
            type: "Bot" | "User" | "Organization";
            /** @description Whether the user is a site admin */
            site_admin: boolean;
        };
        /** @description A GitHub repository */
        GithubRepository: {
            /** @description The repository ID */
            id: number;
            /** @description The repository node ID */
            node_id: string;
            /** @description The name of the repository */
            name: string;
            /** @description The full name of the repository (owner/repo) */
            full_name: string;
            /** @description Whether the repository is private */
            private: boolean;
            owner: components["schemas"]["GithubUser"];
            /** @description The HTML URL of the repository */
            html_url: string;
            /** @description The repository description */
            description?: string | null;
            /** @description Whether the repository is a fork */
            fork: boolean;
            /** @description The API URL of the repository */
            url: string;
            /** @description The clone URL of the repository */
            clone_url: string;
            /** @description The git URL of the repository */
            git_url: string;
            /** @description The SSH URL of the repository */
            ssh_url: string;
            /** @description The default branch of the repository */
            default_branch: string;
            /**
             * Format: date-time
             * @description When the repository was created
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the repository was last updated
             */
            updated_at: string;
            /**
             * Format: date-time
             * @description When the repository was last pushed to
             */
            pushed_at: string;
        };
        /** @description A GitHub release asset */
        GithubReleaseAsset: {
            /** @description The asset ID */
            id: number;
            /** @description The asset node ID */
            node_id: string;
            /** @description The name of the asset */
            name: string;
            /** @description The label of the asset */
            label?: string | null;
            /** @description The content type of the asset */
            content_type: string;
            /**
             * @description The state of the asset
             * @enum {string}
             */
            state: "uploaded" | "open";
            /** @description The size of the asset in bytes */
            size: number;
            /** @description The number of downloads */
            download_count: number;
            /**
             * Format: date-time
             * @description When the asset was created
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the asset was last updated
             */
            updated_at: string;
            /** @description The browser download URL */
            browser_download_url: string;
            uploader: components["schemas"]["GithubUser"];
        };
        /** @description A GitHub organization */
        GithubOrganization: {
            /** @description The organization's login name */
            login: string;
            /** @description The organization ID */
            id: number;
            /** @description The organization node ID */
            node_id: string;
            /** @description The API URL of the organization */
            url: string;
            /** @description The API URL of the organization's repositories */
            repos_url: string;
            /** @description The API URL of the organization's events */
            events_url: string;
            /** @description The API URL of the organization's hooks */
            hooks_url: string;
            /** @description The API URL of the organization's issues */
            issues_url: string;
            /** @description The API URL of the organization's members */
            members_url: string;
            /** @description The API URL of the organization's public members */
            public_members_url: string;
            /** @description URL to the organization's avatar */
            avatar_url: string;
            /** @description The organization description */
            description?: string | null;
        };
        /** @description A GitHub App installation */
        GithubInstallation: {
            /** @description The installation ID */
            id: number;
            account: components["schemas"]["GithubUser"];
            /**
             * @description Repository selection for the installation
             * @enum {string}
             */
            repository_selection: "selected" | "all";
            /** @description The API URL for access tokens */
            access_tokens_url: string;
            /** @description The API URL for repositories */
            repositories_url: string;
            /** @description The HTML URL of the installation */
            html_url: string;
            /** @description The GitHub App ID */
            app_id: number;
            /** @description The target ID */
            target_id: number;
            /** @description The target type */
            target_type: string;
            /** @description The installation permissions */
            permissions: Record<string, never>;
            /** @description The events the installation subscribes to */
            events: string[];
            /**
             * Format: date-time
             * @description When the installation was created
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the installation was last updated
             */
            updated_at: string;
            /** @description The single file name if applicable */
            single_file_name?: string | null;
        };
        /** @description A GitHub enterprise */
        GithubEnterprise: {
            /** @description The enterprise ID */
            id: number;
            /** @description The enterprise slug */
            slug: string;
            /** @description The enterprise name */
            name: string;
            /** @description The enterprise node ID */
            node_id: string;
            /** @description URL to the enterprise avatar */
            avatar_url: string;
            /** @description The enterprise description */
            description?: string | null;
            /** @description The enterprise website URL */
            website_url?: string | null;
            /** @description The HTML URL of the enterprise */
            html_url: string;
            /**
             * Format: date-time
             * @description When the enterprise was created
             */
            created_at: string;
            /**
             * Format: date-time
             * @description When the enterprise was last updated
             */
            updated_at: string;
        };
        ReleaseNote: {
            /** @description Unique identifier for the release note */
            id: number;
            /**
             * @description The project this release note belongs to
             * @enum {string}
             */
            project: "comfyui" | "comfyui_frontend" | "desktop" | "cloud";
            /** @description The version of the release */
            version: string;
            /**
             * @description The attention level for this release
             * @enum {string}
             */
            attention: "low" | "medium" | "high";
            /** @description The content of the release note in markdown format */
            content: string;
            /**
             * Format: date-time
             * @description When the release note was published
             */
            published_at: string;
        };
        ViduCreation: {
            id?: string;
            url?: string;
            cover_url?: string;
            watermarked_url?: string;
            moderation_url?: string[];
        };
        /** @enum {string} */
        ViduState: "created" | "processing" | "queueing" | "success" | "failed";
        ViduGetCreationsReply: {
            state?: components["schemas"]["ViduState"];
            err_code?: string;
            creations?: components["schemas"]["ViduCreation"][];
            id?: string;
        };
        ViduTaskReply: {
            task_id: string;
            state: components["schemas"]["ViduState"];
            model?: string;
            /** @enum {string} */
            style?: "general" | "anime";
            prompt?: string;
            images?: string[];
            /** Format: int32 */
            duration?: number;
            /** Format: int32 */
            seed?: number;
            aspect_ratio?: string;
            resolution?: string;
            /** @enum {string} */
            movement_amplitude?: "auto" | "small" | "medium" | "large";
            /** Format: date-time */
            created_at?: string;
            /** Format: int32 */
            credits: number;
        };
        ViduTaskRequest: {
            model?: string;
            /** @enum {string} */
            style?: "general" | "anime";
            prompt?: string;
            images?: string[];
            /** Format: int32 */
            duration?: number;
            /** Format: int32 */
            seed?: number;
            aspect_ratio?: string;
            resolution?: string;
            /** @enum {string} */
            movement_amplitude?: "auto" | "small" | "medium" | "large";
            enhance?: boolean;
            callback_url?: string;
            /** Format: int32 */
            priority?: number;
        };
        BytePlusImageGenerationRequest: {
            /** @enum {string} */
            model: "seedream-3-0-t2i-250415" | "seededit-3-0-i2i-250628" | "seedream-4-0-250828" | "seedream-4-5-251128";
            /** @description Text description for image generation or transformation */
            prompt: string;
            /**
             * @description Only seedream-4.0 and seededit-3.0-i2i support this parameter.
             *
             *     Enter the Base64 encoding or an accessible URL of the image to edit. Among the models, bytedance-seedream-4.0 supports inputting a single image or multiple images (see the multi-image blending example), while bytedance-seededit-3.0-i2 only supports single-image input.
             *
             *      Image URL: Make sure that the image URL is accessible.
             *      Base64 encoding: The format must be data:image/<image format>;base64,<Base64 encoding>. Note: <image format> must be in lowercase, e.g., data:image/png;base64,<base64_image>.
             *
             *     An input image must meet the following requirements:
             *      Image format: jpeg, png
             *      Aspect ratio (width/height): In the range [1/3, 3]
             *      Width and height (px): > 14
             *      Size: No more than 10 MB
             */
            image?: string | string[];
            /**
             * @description "seedream-3-0-t2i-250415": Specifies the dimensions (width x height in pixels) of the generated image. Must be between [512x512, 2048x2048]
             *     "seededit-3-0-i2i-250628": The width and height pixels of the generated image. Currently only supports adaptive.
             *     "seedream-4-0-250828": Set the specification for the generated image. Two methods are available but cannot be used together.
             *       Method 1 | Example: Specify the resolution of the generated image, and describe its aspect ratio, shape, or purpose in the prompt using natural language, let the model ultimately determine the final image width and height.
             *         Optional values: 1K, 2K, 4K
             *       Method 2 | Example: Specify the width and height of the generated image in pixels:
             *         Default value: 2048x2048
             *         The value range of total pixels: [1024x1024, 4096x4096]
             *         The aspect ratio value range: [1/16, 16]
             */
            size?: string;
            /**
             * @description Specifies the format of the generated image returned in the response
             * @default url
             * @enum {string}
             */
            response_format: "url" | "b64_json";
            /**
             * @description Random seed to control the stochasticity of image generation. Range: [-1, 2147483647]. If not specified, a seed will be automatically generated. To reproduce the same output, use the same seed value.
             * @default -1
             */
            seed: number;
            /**
             * @description Controls whether to disable the batch generation feature. This parameter is only supported on seedream-4.0. Valid values:
             *     auto: In automatic mode, the model automatically determines whether to return multiple images and how many images it will contain based on the user's prompt.
             *     disabled: Disables batch generation feature. The model will only generate one image.
             */
            sequential_image_generation?: string;
            /**
             * @description Only seedream-4.0 supports this parameter.
             *     Configuration for the batch image generation feature. This parameter is only effective when sequential_image_generation is set to auto.
             */
            sequential_image_generation_options?: {
                /**
                 * @description Specifies the maximum number of images to generate in this request. Number of input reference images + Number of generated images  15.
                 * @default 15
                 */
                max_images: number;
            };
            /**
             * Format: float
             * @description Controls how closely the output image aligns with the input prompt. Range [1, 10]. Higher values result in stronger prompt adherence. Default 2.5 for seedream-3-0-t2i-250415 and 5.5 for seededit-3-0-i2i-250628
             */
            guidance_scale?: number;
            /**
             * @description Specifies whether to add a watermark to the generated image. false = No watermark, true = Adds watermark with 'AI generated' label
             * @default true
             */
            watermark: boolean;
        };
        BytePlusImageGenerationResponse: {
            /**
             * @description The model ID used for the request
             * @example seedream-3-0-t2i-250415
             */
            model?: string;
            /** @description Unix timestamp (in seconds) indicating the time when the request was created */
            created?: number;
            /** @description Contains information about the generated image(s) */
            data?: {
                /**
                 * Format: uri
                 * @description URL for image download (if response_format is "url")
                 */
                url?: string;
                /** @description Base64-encoded image data (if response_format is "b64_json") */
                b64_json?: string;
            }[];
            usage?: {
                /** @description Number of images generated by the model */
                generated_images?: number;
                /** @description The number of tokens used for the picture generated by the model. */
                output_tokens?: number;
                /** @description The total number of tokens consumed by this request. */
                total_tokens?: number;
            };
            /** @description Error information (if any) */
            error?: {
                /** @description Error code */
                code?: string;
                /** @description Error message */
                message?: string;
            };
        };
        BytePlusVideoGenerationRequest: {
            /**
             * @description The ID of the model to call. Available models include seedance-1-0-pro-250528, seedance-1-0-pro-fast-251015, seedance-1-0-lite-t2v-250428, seedance-1-0-lite-i2v-250428
             * @enum {string}
             */
            model: "seedance-1-0-pro-250528" | "seedance-1-0-lite-t2v-250428" | "seedance-1-0-lite-i2v-250428" | "seedance-1-0-pro-fast-251015";
            /** @description The input content for the model to generate a video */
            content: components["schemas"]["BytePlusVideoGenerationContent"][];
            /**
             * Format: uri
             * @description Callback notification address for the result of this generation task
             */
            callback_url?: string;
        };
        BytePlusVideoGenerationContent: {
            /**
             * @description The type of the input content
             * @enum {string}
             */
            type: "text" | "image_url";
            /**
             * @description The input text information for the model. Includes text prompt and optional parameters.
             *
             *     Text prompt (required): Description of the video to be generated using Chinese and English characters.
             *
             *     Parameters (optional): Add --[parameters] after the text prompt to control video specifications:
             *     - --resolution (--rs): 480p, 720p, 1080p (default: 720p)
             *     - --ratio (--rt): 21:9, 16:9, 4:3, 1:1, 3:4, 9:16, 9:21, adaptive (default: 16:9 or adaptive)
             *     - --duration (--dur): 3-12 seconds (default: 5)
             *     - --framepersecond (--fps): 24 (default: 24)
             *     - --watermark (--wm): true/false (default: false)
             *     - --seed (--seed): -1 to 2^32-1 (default: -1)
             *     - --camerafixed (--cf): true/false (default: false)
             *
             *     Example: "A beautiful landscape --ratio 16:9 --resolution 720p --duration 5"
             */
            text?: string;
            image_url?: {
                /**
                 * @description Image content for image-to-video generation (when type is "image")
                 *     Image URL: Make sure that the image URL is accessible.
                 *     Base64-encoded content: Format must be data:image/<format>;base64,<content>
                 */
                url?: string;
            };
        };
        BytePlusVideoGenerationResponse: {
            /** @description The ID of the video generation task */
            id: string;
        };
        BytePlusVideoGenerationQueryResponse: {
            /** @description The ID of the video generation task */
            id?: string;
            /** @description The name and version of the model used by the task */
            model?: string;
            /**
             * @description The state of the task
             * @enum {string}
             */
            status?: "queued" | "running" | "cancelled" | "succeeded" | "failed";
            /** @description The error information. If the task succeeds, null is returned. If the task fails, the error information is returned. */
            error?: {
                /** @description The error code */
                code?: string;
                /** @description The error message */
                message?: string;
            } | null;
            /** @description The time when the task was created. The value is a UNIX timestamp in seconds. */
            created_at?: number;
            /** @description The time when the task was last updated. The value is a UNIX timestamp in seconds. */
            updated_at?: number;
            /** @description The output after the video generation task is completed, which contains the download URL of the output video. */
            content?: {
                /** @description The URL of the output video. For security purposes, the output video is cleared after 24 hours. */
                video_url?: string;
            };
            /** @description The token usage for the request */
            usage?: {
                /** @description The number of tokens generated by the model */
                completion_tokens?: number;
                /** @description For the video generation model, the number of input tokens is not calculated and defaults to 0. Therefore, total_tokens = completion_tokens. */
                total_tokens?: number;
            };
        };
        WanVideoGenerationRequest: {
            /**
             * @description The ID of the model to call
             * @enum {string}
             */
            model: "wan2.5-t2v-preview" | "wan2.5-i2v-preview" | "wan2.6-t2v" | "wan2.6-i2v";
            /** @description Enter basic information, such as prompt words, etc. */
            input: {
                /**
                 * @description Text prompt words. Support Chinese and English, length not exceeding 800 characters.
                 *     For wan2.6-r2v with multiple reference videos, use 'character1', 'character2', etc. to refer to subjects
                 *     in the order of reference videos. Example: "Character1 sings on the roadside, Character2 dances beside it"
                 */
                prompt: string;
                /** @description Reverse prompt words are used to describe content that you do not want to see in the video screen */
                negative_prompt?: string;
                /** @description Audio file download URL. Supported formats: mp3 and wav. Cannot be used with reference_video_urls. */
                audio_url?: string;
                /** @description First frame image URL or Base64 encoded data. Required for I2V models. Image formats: JPEG, JPG, PNG, BMP, WEBP. Resolution: 360-2000 pixels. File size: max 10MB. */
                img_url?: string;
                /** @description Video effect template name. Optional. Currently supported: squish, flying, carousel. When used, prompt parameter is ignored. */
                template?: string;
                /**
                 * @description Reference video URLs for wan2.6-r2v model only. Array of 1-3 video URLs.
                 *     Input restrictions:
                 *     - Format: mp4, mov
                 *     - Quantity: 1-3 videos
                 *     - Single video length: 2-30 seconds
                 *     - Single file size: max 30MB
                 *     - Cannot be used with audio_url
                 *     Reference duration: Single video max 5s, two videos max 2.5s each, three videos proportionally less.
                 *     Billing: Based on actual reference duration used.
                 */
                reference_video_urls?: string[];
            };
            /** @description Video processing parameters */
            parameters?: {
                /**
                 * @description Video resolution in format width*height. Supported resolutions vary by model:
                 *     For wan2.5 T2V: 480P (480*832, 832*480, 624*624), 720P, 1080P sizes
                 *     For wan2.6 T2V/R2V (no 480P):
                 *       720P: 1280*720, 720*1280, 960*960, 1088*832, 832*1088
                 *       1080P: 1920*1080, 1080*1920, 1440*1440, 1632*1248, 1248*1632
                 */
                size?: string;
                /**
                 * @description Resolution level for I2V models. Supported values vary by model:
                 *     - wan2.5-i2v-preview: 480P, 720P, 1080P
                 *     - wan2.6-i2v: 720P, 1080P only (no 480P support)
                 * @enum {string}
                 */
                resolution?: "480P" | "720P" | "1080P";
                /**
                 * @description The duration of the video generated, in seconds:
                 *     - wan2.5 models: 5 or 10 seconds
                 *     - wan2.6-t2v, wan2.6-i2v: 5, 10, or 15 seconds
                 *     - wan2.6-r2v: 5 or 10 seconds only (no 15s support)
                 * @default 5
                 * @enum {integer}
                 */
                duration?: 5 | 10 | 15;
                /**
                 * @description Is it enabled prompt intelligent rewriting. Default is true
                 * @default true
                 */
                prompt_extend?: boolean;
                /**
                 * @description Intelligent multi-lens control. Only active when prompt_extend is enabled.
                 *     For wan2.6 models only.
                 *     - multi: Intelligent disassembly into multiple lenses (default)
                 *     - single: Single lens generation
                 * @default multi
                 * @enum {string}
                 */
                shot_type?: "multi" | "single";
                /** @description Random number seed, used to control the randomness of the model generated content */
                seed?: number;
                /**
                 * @description Whether to add a watermark logo, the watermark is located in the lower right corner
                 * @default false
                 */
                watermark?: boolean;
                /**
                 * @description Whether to add audio to the video
                 * @default true
                 */
                audio?: boolean;
            };
        };
        WanVideoGenerationResponse: {
            output: {
                /** @description Task ID */
                task_id: string;
                /**
                 * @description Task status
                 * @enum {string}
                 */
                task_status: "PENDING" | "RUNNING" | "SUCCEEDED" | "FAILED" | "CANCELED" | "UNKNOWN";
            };
            /** @description Unique request identifier */
            request_id: string;
            /** @description The error code for the failed request (not returned if request is successful) */
            code?: string;
            /** @description Detailed information about the failed request (not returned if request is successful) */
            message?: string;
        };
        WanTaskQueryResponse: {
            /** @description Unique request identifier */
            request_id: string;
            output: {
                /** @description Task ID */
                task_id: string;
                /**
                 * @description Task status
                 * @enum {string}
                 */
                task_status: "PENDING" | "RUNNING" | "SUCCEEDED" | "FAILED" | "CANCELED" | "UNKNOWN";
                /** @description Task submission time */
                submit_time?: string;
                /** @description Task execution time */
                scheduled_time?: string;
                /** @description Task completion time */
                end_time?: string;
                /** @description Video URL for completed video generation tasks. Link validity period 24 hours */
                video_url?: string;
                /** @description Audio URL for I2V tasks with audio generation */
                check_audio?: string;
                /** @description Original input prompt (for video tasks) */
                orig_prompt?: string;
                /** @description Actual prompt after intelligent rewriting (for video tasks) */
                actual_prompt?: string;
                /** @description List of task results for image generation tasks */
                results?: {
                    /** @description Original input prompt */
                    orig_prompt?: string;
                    /** @description Actual prompt after intelligent rewriting (if enabled) */
                    actual_prompt?: string;
                    /** @description Generated image URL address */
                    url?: string;
                    /** @description Image error code (returned when some tasks fail) */
                    code?: string;
                    /** @description Image error information (returned when some tasks fail) */
                    message?: string;
                }[];
                /** @description Task result statistics for image generation tasks */
                task_metrics?: {
                    /** @description Total number of tasks */
                    TOTAL?: number;
                    /** @description Number of successful tasks */
                    SUCCEEDED?: number;
                    /** @description Number of failed tasks */
                    FAILED?: number;
                };
                /** @description The error code for the failed request (not returned if request is successful) */
                code?: string;
                /** @description Detailed information about the failed request (not returned if request is successful) */
                message?: string;
            };
            /** @description Output information statistics. Only successful results are counted */
            usage?: {
                /** @description Duration of generated video in seconds (T2V tasks) */
                video_duration?: number;
                /** @description Video resolution ratio (T2V tasks) */
                video_ratio?: string;
                /** @description Number of generated videos (T2V tasks) */
                video_count?: number;
                /** @description Duration of generated video in seconds (I2V tasks) */
                duration?: number;
                /** @description Video resolution level (I2V tasks) */
                SR?: number;
                /** @description Image resolution (T2I tasks) */
                size?: string;
                /** @description Number of generated images (T2I tasks) */
                image_count?: number;
            };
        };
        WanImageGenerationRequest: {
            /**
             * @description The ID of the model to call for text-to-image generation
             * @enum {string}
             */
            model: "wan2.5-t2i-preview";
            /** @description Enter basic information, such as prompt words, etc. */
            input: {
                /** @description Positive prompt words to describe expected image elements and visual features. Support Chinese and English, length not exceeding 800 characters */
                prompt: string;
                /** @description Reverse prompt words to describe content that you do not want to see in the image */
                negative_prompt?: string;
            };
            /** @description Image processing parameters */
            parameters?: {
                /**
                 * @description Output image resolution. Default is 1024*1024. Pixel range [512, 1440], up to 200 megapixels
                 * @default 1024*1024
                 */
                size?: string;
                /**
                 * @description Number of generated images. Range 1-4, default is 4
                 * @default 4
                 */
                n?: number;
                /** @description Random number seed to control randomness. Range [0, 2147483647] */
                seed?: number;
                /**
                 * @description Enable prompt intelligent rewriting. Default is true
                 * @default true
                 */
                prompt_extend?: boolean;
                /**
                 * @description Whether to add watermark logo in lower right corner
                 * @default false
                 */
                watermark?: boolean;
            };
        };
        WanImageGenerationResponse: {
            output: {
                /** @description Task ID */
                task_id: string;
                /**
                 * @description Task status
                 * @enum {string}
                 */
                task_status: "PENDING" | "RUNNING" | "SUCCEEDED" | "FAILED" | "CANCELED" | "UNKNOWN";
            };
            /** @description Unique request identifier */
            request_id: string;
            /** @description The error code for the failed request (not returned if request is successful) */
            code?: string;
            /** @description Detailed information about the failed request (not returned if request is successful) */
            message?: string;
        };
        WanImage2ImageGenerationRequest: {
            /**
             * @description The ID of the model to call for image-to-image generation
             * @enum {string}
             */
            model: "wan2.5-i2i-preview";
            /** @description Enter basic information, such as prompt words, images, etc. */
            input: {
                /** @description Positive prompt words to describe expected image elements and visual features. Support Chinese and English, length not exceeding 2000 characters */
                prompt: string;
                /** @description Array of image URLs for image-to-image generation */
                images: string[];
                /** @description Reverse prompt words to describe content that you do not want to see in the image */
                negative_prompt?: string;
            };
            /** @description Image processing parameters */
            parameters?: {
                /**
                 * @description Output image resolution. Default is 1280*1280. Width and height must be between 384 and 5000 pixels.
                 * @default 1280*1280
                 */
                size?: string;
                /**
                 * @description Number of generated images. Range 1-4, default is 1
                 * @default 1
                 */
                n?: number;
                /** @description Random number seed to control randomness. Range [0, 2147483647] */
                seed?: number;
                /**
                 * @description Whether to add watermark logo in lower right corner
                 * @default false
                 */
                watermark?: boolean;
            };
        };
        WanImage2ImageGenerationResponse: {
            output: {
                /** @description Task ID */
                task_id: string;
                /**
                 * @description Task status
                 * @enum {string}
                 */
                task_status: "PENDING" | "RUNNING" | "SUCCEEDED" | "FAILED" | "CANCELED" | "UNKNOWN";
            };
            /** @description Unique request identifier */
            request_id: string;
            /** @description The error code for the failed request (not returned if request is successful) */
            code?: string;
            /** @description Detailed information about the failed request (not returned if request is successful) */
            message?: string;
        };
        TopazEnhanceGenRequest: {
            /**
             * @description The desired format of the output image
             * @default jpeg
             * @enum {string}
             */
            output_format: "jpeg" | "jpg" | "png" | "tiff" | "tif";
            /**
             * @description Specifies whether you want to detect all subjects in the image, only the foreground subject, or only the background for the AI model to run on
             * @default All
             * @enum {string}
             */
            subject_detection: "All" | "Foreground" | "Background";
            /**
             * @description By default, faces (if any) are enhanced during image processing as well. Set face_enhancement to false if you don't want this
             * @default true
             */
            face_enhancement: boolean;
            /**
             * @description Choose the level of creativity for face enhancement from 0 to 1. Defaults to 0, and is ignored if face_enhancement is false
             * @default 0
             */
            face_enhancement_creativity: number;
            /**
             * @description Control how sharp the enhanced faces are relative to the background from 0 to 1. Defaults to 0.8, and is ignored if face_enhancement is false
             * @default 0.8
             */
            face_enhancement_strength: number;
            /**
             * Format: binary
             * @description The image file to be processed. Supported formats - jpeg (or jpg), png, tiff (or tif)
             */
            image?: string;
            /**
             * @description Unique identifier of the source image
             * @example d7b3b3b3-7b3b-4b3b-8b3b-3b3b3b3b3b3b
             */
            source_id?: string;
            /**
             * @description The URL of the source image
             * @example https://example.com/image.jpg
             */
            source_url?: string;
            /**
             * @description The model to use for processing the image (Bloom - Creative Upscale)
             * @default Reimagine
             * @enum {string}
             */
            model: "Reimagine";
            /** @description The desired height of the output image in pixels */
            output_height?: number;
            /** @description The desired width of the output image in pixels */
            output_width?: number;
            /**
             * @description Default behavior is to letterbox the image if a differing aspect ratio is chosen. Enable crop_to_fill by setting this to true if you instead want to crop the image to fill the dimensions
             * @default false
             */
            crop_to_fill: boolean;
            /**
             * @description Text prompt for creative upscaling guidance - available for Reimagine only
             * @example enter-your-prompt-here
             */
            prompt?: string;
            /**
             * @description Creativity settings range from 1 to 9 -  - available for Reimagine only
             * @default 3
             */
            creativity: number;
            /**
             * @description To preserve the identity of characters - available for Reimagine only (must be string "true" or "false" due to Topaz API requirement)
             * @default true
             * @enum {string}
             */
            face_preservation: "true" | "false";
            /**
             * @description To preserve the original color - available for Reimagine only (must be string "true" or "false" due to Topaz API requirement)
             * @default true
             * @enum {string}
             */
            color_preservation: "true" | "false";
        };
        TopazEnhanceGenResponse: {
            /**
             * @description Unique identifier for the processing job
             * @example d7b3b3b3-7b3b-4b3b-8b3b-3b3b3b3b3b3b
             */
            process_id: string;
            /**
             * @description Unique identifier of the source image
             * @example d7b3b3b3-7b3b-4b3b-8b3b-3b3b3b3b3b3b
             */
            source_id?: string;
            /**
             * @description Expected completion time in Unix timestamp
             * @example 1617220000
             */
            eta: number;
        };
        TopazStatusResponse: {
            /** @description Unique identifier for the processing job */
            process_id: string;
            /** @description Unique identifier of the source image */
            source_id?: string;
            /** @description Original filename without extension */
            filename?: string;
            /** @description Format of the input image */
            input_format?: string;
            /** @description Height of the input image in pixels */
            input_height?: number;
            /** @description Width of the input image in pixels */
            input_width?: number;
            /** @description Format of the output image */
            output_format?: string;
            /** @description Height of the output image in pixels */
            output_height?: number;
            /** @description Width of the output image in pixels */
            output_width?: number;
            /** @description Processing category (e.g., "Enhance") */
            category?: string;
            /** @description Type of model used (e.g., "Generative") */
            model_type?: string;
            /** @description Specific model used (e.g., "Reimagine") */
            model?: string;
            /** @description Subject detection setting */
            subject_detection?: string;
            /** @description Whether face enhancement is enabled */
            face_enhancement?: boolean;
            /** @description Face enhancement creativity level */
            face_enhancement_creativity?: number;
            /** @description Face enhancement strength level */
            face_enhancement_strength?: number;
            /** @description Whether crop to fill is enabled */
            crop_to_fill?: boolean;
            /** @description JSON string containing additional options */
            options_json?: string;
            /** @description Whether this was a synchronous request */
            sync?: boolean;
            /**
             * @description Current status of the processing job
             * @enum {string}
             */
            status: "Pending" | "Processing" | "Completed" | "Failed" | "Cancelled";
            /** @description Progress percentage (0-100) */
            progress?: number;
            /** @description Expected completion time in Unix timestamp */
            eta?: number;
            /** @description Creation time in Unix timestamp */
            creation_time?: number;
            /** @description Last modification time in Unix timestamp */
            modification_time?: number;
            /** @description Credits consumed for this job */
            credits: number;
        };
        TopazDownloadResponse: {
            /**
             * @description Presigned URL to download the image
             * @example https://example.com/d7b3b3b3-7b3b-4b3b-8b3b-3b3b3b3b3b3b?presigned_headers
             */
            download_url: string;
            /**
             * @description Presigned URL to get image metadata
             * @example https://example.com/d7b3b3b3-7b3b-4b3b-8b3b-3b3b3b3b3b3b?presigned_headers
             */
            head_url?: string;
            /**
             * @description Expiration time of the presigned URLs in Unix timestamp
             * @example 1617220000
             */
            expiry: number;
        };
        TopazVideoSourceResolution: {
            /**
             * @description Width of the video in pixels
             * @example 1920
             */
            width: number;
            /**
             * @description Height of the video in pixels
             * @example 1080
             */
            height: number;
        };
        TopazVideoOutputResolution: {
            /**
             * @description Desired output width in pixels
             * @example 3840
             */
            width: number;
            /**
             * @description Desired output height in pixels
             * @example 2160
             */
            height: number;
        };
        TopazVideoEnhancementFilter: {
            /**
             * @description Short code name for AI model
             * @example prob-4
             * @enum {string}
             */
            model: "aaa-9" | "ahq-12" | "alq-13" | "alqs-2" | "amq-13" | "amqs-2" | "ddv-3" | "dtd-4" | "dtds-2" | "dtv-4" | "dtvs-2" | "gcg-5" | "ghq-5" | "iris-2" | "iris-3" | "nxf-1" | "nyx-3" | "prob-4" | "rhea-1" | "rxl-1" | "thd-3" | "thf-4" | "thm-2" | "slf-1" | "slc-1";
            /**
             * @description Frame/field type of the video
             * @example Progressive
             * @enum {string}
             */
            videoType?: "Progressive" | "Interlaced" | "ProgressiveInterlaced";
            /**
             * @description Parameter mode of the selected model
             * @example Auto
             * @enum {string}
             */
            auto?: "Auto" | "Manual" | "Relative";
            /**
             * @description Optional specification of field order for interlaced input videos
             * @example Auto
             * @enum {string}
             */
            fieldOrder?: "TopFirst" | "BottomFirst" | "Auto";
            /**
             * @description Downscales video input for stronger correction of blurred subjects
             * @example Normal
             * @enum {string}
             */
            focusFixLevel?: "None" | "Normal" | "Strong";
            /**
             * @description Adjust strength of compression recovery
             * @example 0.1
             */
            compression?: number;
            /**
             * @description Amount of detail reconstruction
             * @example 0.2
             */
            details?: number;
            /**
             * @description Adds noise to input to reduce over-smoothing
             * @example 0.01
             */
            prenoise?: number;
            /**
             * @description Amount of noise reduction
             * @example 0.3
             */
            noise?: number;
            /**
             * @description Amount of halo reduction
             * @example 0.4
             */
            halo?: number;
            /**
             * @description Adjust anti-aliasing and deblurring strength
             * @example 0.5
             */
            preblur?: number;
            /**
             * @description Amount of sharpness applied
             * @example 0.6
             */
            blur?: number;
            /**
             * @description Adds grain after AI model processing
             * @example 0.02
             */
            grain?: number;
            /**
             * @description Size of generated grain
             * @example 1
             */
            grainSize?: number;
            /**
             * @description Reintroduce source details into the output video
             * @example 0.7
             */
            recoverOriginalDetailValue?: number;
            /**
             * @description Creativity level for Starlight Creative (slc-1) only
             * @enum {string}
             */
            creativity?: "low" | "high";
            /** @description Set to true for Starlight Creative (slc-1) only */
            isOptimizedMode?: boolean;
        };
        TopazVideoFrameInterpolationFilter: {
            /**
             * @description Short code name for AI model
             * @example apo-8
             * @enum {string}
             */
            model: "aion-1" | "apf-2" | "apo-8" | "chf-3" | "chr-2";
            /**
             * @description Slow motion factor applied to input video
             * @example 2
             */
            slowmo?: number;
            /**
             * @description Output frame rate, does not increase duration
             * @example 60
             */
            fps?: number;
            /**
             * @description Analyze input for duplicate frames and remove them
             * @example true
             */
            duplicate?: boolean;
            /**
             * @description Sensitivity of detection for duplicate frames
             * @example 0.01
             */
            duplicateThreshold?: number;
        };
        TopazCombinedCreateRequest: components["schemas"]["TopazCreateRequestVideoSchema"] | components["schemas"]["TopazCreateRequestImageSequenceSchema"];
        /** Video AI */
        TopazCreateRequestVideoSchema: {
            /** @description Source details for the video */
            source: {
                /**
                 * @description The container format of the video file
                 * @example mp4
                 * @enum {string}
                 */
                container: "mp4" | "mov" | "mkv";
                /**
                 * @description Size of the video file in bytes
                 * @example 123456000
                 */
                size: number;
                /**
                 * @description Duration of the video file in seconds
                 * @example 600
                 */
                duration: number;
                /**
                 * @description Total number of frames in the video
                 * @example 18000
                 */
                frameCount: number;
                /**
                 * @description Frame rate of the video
                 * @example 30
                 */
                frameRate: number;
                /** @description Resolution details of the video */
                resolution: {
                    /**
                     * @description Width of the video in pixels
                     * @example 1920
                     */
                    width: number;
                    /**
                     * @description Height of the video in pixels
                     * @example 1080
                     */
                    height: number;
                };
                external?: components["schemas"]["TopazExternalStorage"];
            };
            filters: components["schemas"]["TopazInputFilters"];
            output: components["schemas"]["TopazOutputInformationVideo"];
            destination?: {
                external?: components["schemas"]["TopazExternalStorage"];
            };
            overrides?: {
                isPaidDiffusion?: boolean;
            };
        };
        /** Image Sequence */
        TopazCreateRequestImageSequenceSchema: {
            /** @description Source details for the video */
            source: {
                /**
                 * @description The container format of the image files
                 * @example TIFF
                 * @enum {string}
                 */
                container: "DPX" | "EXR" | "JPEG" | "PNG" | "TIFF";
                /**
                 * @description Total number of frames in the video, in this case, equal to the number of image files.
                 * @example 18000
                 */
                frameCount: number;
                /**
                 * @description Frame rate of the video
                 * @example 30
                 */
                frameRate: number;
                /** @description Resolution details of the image */
                resolution: {
                    /**
                     * @description Width of the image in pixels
                     * @example 1920
                     */
                    width: number;
                    /**
                     * @description Height of the image in pixels
                     * @example 1080
                     */
                    height: number;
                };
                /**
                 * @description Optional starting frame number for image sequences
                 * @example 120
                 */
                startNumber?: number;
                /**
                 * @description Optional ending frame number for image sequences
                 * @example 120
                 */
                endNumber?: number;
                external: components["schemas"]["TopazExternalStorage"];
            };
            filters: components["schemas"]["TopazInputFilters"];
            output: components["schemas"]["TopazOutputInformationImageSequence"];
            destination: {
                external?: components["schemas"]["TopazExternalStorage"];
            };
        };
        TopazExternalStorage: {
            /**
             * @example s3
             * @enum {string}
             */
            provider: "s3";
            credentials: components["schemas"]["TopazCredentialsS3"];
            /** @example galaxies */
            bucketName: string;
            /**
             * @description The example includes the standard specifier for image sequence requests, with optional directory path. It must begin with "%" and end with the integer specifier "d". The "0" in the example indicates left-padding with zeroes, and "6" indicates the number of digits in the file name.
             *     Keys for video requests must be valid characters supported by S3.
             * @example milky_way/%06d.tiff
             */
            key: string;
        };
        TopazCredentialsS3: {
            /**
             * @description AWS ARN of the role to assume
             * @example arn:aws:iam::123456789:role/topazlabs
             */
            roleArn: string;
            /**
             * @description Kind of like a secret string for extra layer of security
             * @example MSTnuGztXtTU25XKjVfMJCsujv6VtAGtv1TGSjtOL6M=
             */
            externalId: string;
        };
        /**
         * @description Array of EnhancementFilter or FrameInterpolationFilter objects
         * @example [
         *       {
         *         "model": "prob-4",
         *         "videoType": "Progressive",
         *         "auto": "Auto",
         *         "fieldOrder": "Auto",
         *         "focusFixLevel": "Normal",
         *         "compression": 0.1,
         *         "details": 0.2,
         *         "prenoise": 0.01,
         *         "noise": 0.3,
         *         "halo": 0.4,
         *         "preblur": 0.5,
         *         "blur": 0.6,
         *         "grain": 0.02,
         *         "grainSize": 1,
         *         "recoverOriginalDetailValue": 0.7
         *       },
         *       {
         *         "model": "apo-8",
         *         "slowmo": 2,
         *         "fps": 60,
         *         "duplicate": true,
         *         "duplicateThreshold": 0.01
         *       }
         *     ]
         */
        TopazInputFilters: (components["schemas"]["TopazVideoEnhancementFilter"] | components["schemas"]["TopazVideoFrameInterpolationFilter"])[];
        TopazOutputInformationVideo: {
            /** @description Desired output resolution */
            resolution: {
                /**
                 * @description Width in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>16384</td> <td>8192</td> </tr> </table>
                 * @example 7680
                 */
                width: number;
                /**
                 * @description Height in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>8704</td> <td>8192</td> </tr> </table>
                 * @example 4320
                 */
                height: number;
            };
            /**
             * @description Frame rate
             * @example 30
             */
            frameRate: number;
            /**
             * @description Audio bitrate, if audioTransfer is Copy or Convert. Default values for the codec are used if not provided.
             * @example 320
             */
            audioBitrate?: string;
            /**
             * @description __Required if audioTransfer is Copy or Convert.__
             * @example AAC
             * @enum {string}
             */
            audioCodec: "AAC" | "AC3" | "PCM";
            /**
             * @example Copy
             * @enum {string}
             */
            audioTransfer: "Copy" | "Convert" | "None";
            /**
             * @description Video codec ID, if known. Defaults to videoEncoder.
             * @example h265-main-win-nvidia
             */
            codecId?: string;
            /**
             * @example H265
             * @enum {string}
             */
            videoEncoder?: "AV1" | "FFV1" | "H264" | "H265" | "ProRes" | "QuickTime Animation" | "QuickTime R210" | "QuickTime V210" | "VP9";
            /**
             * @description __Required if dynamicCompressionLevel is not provided.__ Constant bitrate, suffixed with "k" for kilobits or "m" for megabits per second.
             * @example 1k
             */
            videoBitrate?: string;
            /**
             * @description __Required if videoBitrate is not provided.__ Automatic CQP selection.
             * @example Mid
             * @enum {string}
             */
            dynamicCompressionLevel?: "Low" | "Mid" | "High";
            /**
             * @description Codec profile specific to videoEncoder. The following are some combinations of available profiles based on the 'videoEncoder' selection <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>High</td> <td>Main, Main10</td> <td>422 Proxy, 422 LT, 422 Std, 422 HQ</td> <td>8-bit, 10-bit</td> <td>Good, Best</td> </tr> </table>
             * @example Main
             */
            videoProfile?: string;
            /**
             * @description Center cropping to fit the output dimensions
             * @example true
             */
            cropToFit?: boolean;
            /**
             * @description Desired output container
             * @example mp4
             * @enum {string}
             */
            container?: "mp4" | "mov" | "mkv";
        };
        TopazOutputInformationImageSequence: {
            /** @description Desired output resolution */
            resolution: {
                /**
                 * @description Width in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>16384</td> <td>8192</td> </tr> </table>
                 * @example 7680
                 */
                width: number;
                /**
                 * @description Height in pixels. The maximum size depends on the encoder and can be referenced using the table below <table> <tr> <td>H264</td> <td>H265</td> <td>ProRes <td>AV1 <td>VP9 </tr> <tr> <td>4096</td> <td>8192</td> <td>16386</td> <td>8704</td> <td>8192</td> </tr> </table>
                 * @example 4320
                 */
                height: number;
            };
            /**
             * @description Frame rate
             * @example 30
             */
            frameRate: number;
            /**
             * @description Video codec ID, if known. Defaults to videoEncoder.
             * @example h265-main-win-nvidia
             */
            codecId?: string;
            /**
             * @example TIFF
             * @enum {string}
             */
            videoEncoder?: "DPX" | "EXR" | "JPEG" | "PNG" | "TIFF";
            /**
             * @description Codec profile specific to videoEncoder
             * @example Main
             */
            videoProfile?: string;
            /**
             * @description Center cropping to fit the output dimensions
             * @example true
             */
            cropToFit?: boolean;
            /**
             * @description Desired output container, defaults to the input container
             * @example TIFF
             * @enum {string}
             */
            container?: "DPX" | "EXR" | "JPEG" | "PNG" | "TIFF";
        };
        TopazVideoCreateRequest: components["schemas"]["TopazCombinedCreateRequest"];
        /** @description Lower and upper bound estimates */
        TopazVideoRequestEstimates: {
            /**
             * @description Cost range in credits
             * @example [
             *       10,
             *       12
             *     ]
             */
            cost?: number[];
            /**
             * @description Time range in seconds
             * @example [
             *       600,
             *       700
             *     ]
             */
            time?: number[];
        };
        TopazVideoCreateResponse: {
            /**
             * Format: uuid
             * @description Unique identifier for the video processing request
             * @example c1f96dc2-c448-00e6-82ed-14ecb6403c62
             */
            requestId: string;
            estimates: components["schemas"]["TopazVideoRequestEstimates"];
        };
        TopazVideoAcceptResponse: {
            /**
             * @description Upload ID for completing multi-part upload
             * @example GDlWC7qIaE6okS41Xf/ktpuS5XzTRabg
             */
            uploadId: string;
            /**
             * @description URLs to PUT the parts to
             * @example [
             *       "https://videocloud.s3.amazonaws.com/source.mp4?uploadPart1",
             *       "https://videocloud.s3.amazonaws.com/source.mp4?uploadPart2"
             *     ]
             */
            urls: string[];
            /**
             * @description Response message
             * @example Accepted
             */
            message?: string;
        };
        TopazVideoCompleteUploadRequest: {
            /**
             * @description MD5 hash of the source video file in hex
             * @example 4d186321c1a7f0f354b297e8914ab240
             */
            md5Hash?: string;
            /** @description An array of part number and ETag pairs of the uploaded parts. ETags are returned by S3 upon upload of the part. */
            uploadResults: {
                /**
                 * @description Part number of the uploaded part, starting from 1
                 * @example 1
                 */
                partNum: number;
                /**
                 * @description eTag value returned by S3 upon upload of the part
                 * @example d41d8cd98f00b204e9800998ecf8427e
                 */
                eTag: string;
            }[];
        };
        TopazVideoCompleteUploadResponse: {
            /**
             * @description Confirmation message
             * @example Processing has been queued
             */
            message: string;
        };
        /** @description Signed download URL to the enhanced video file */
        TopazVideoEnhancedDownload: {
            /** @example https://videocloud.r2.cloudflarestorage.com/enhanced.mp4 */
            url?: string;
            /**
             * @description TTL in milliseconds
             * @example 86400000
             */
            expiresIn?: number;
            /**
             * @description Time in milliseconds since UTC epoch
             * @example 1727213400000
             */
            expiresAt?: number;
        };
        TopazVideoStatusResponse: {
            /**
             * @description Current status of the video processing
             * @example processing
             * @enum {string}
             */
            status: "requested" | "accepted" | "initializing" | "preprocessing" | "processing" | "postprocessing" | "complete" | "canceling" | "canceled" | "failed";
            /**
             * @description Total progress percentage
             * @example 82
             */
            progress?: number;
            estimates?: components["schemas"]["TopazVideoRequestEstimates"];
            /**
             * @description Size of output video
             * @example 10 GB
             */
            outputSize?: string;
            /**
             * @description Average processing speed of each node
             * @example 1.23
             */
            averageFps?: number;
            /**
             * @description Combined processing speed of all nodes
             * @example 12.34
             */
            combinedFps?: number;
            /** @example Processing */
            message?: string;
            download?: components["schemas"]["TopazVideoEnhancedDownload"];
        };
    };
    responses: never;
    parameters: {
        /** @description Unique UUID for each request. */
        PixverseAiTraceId: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["User"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    searchCustomers: {
        parameters: {
            query?: {
                /** @description Email address to search for */
                email?: string;
                /** @description Customer name to search for */
                name?: string;
                /** @description Stripe customer ID to search for */
                stripe_id?: string;
                /** @description Metronome customer ID to search for\ */
                metronome_id?: string;
                /** @description Page number to retrieve */
                page?: number;
                /** @description Number of customers to return per page */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customers matching the search criteria */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Current page number */
                        page?: number;
                        /** @description Number of customers per page */
                        limit?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                        customers?: components["schemas"]["Customer"][];
                        /** @description Total number of matching customers */
                        total?: number;
                    };
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - insufficient permissions */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createCustomer: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer already exists */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Customer created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Invalid request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getAuthenticatedCustomer: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer details retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Customer"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getCustomerById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer details retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        customer?: components["schemas"]["CustomerAdmin"];
                    };
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listCustomerAPIKeys: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of API keys */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        api_keys?: components["schemas"]["APIKey"][];
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createCustomerAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateAPIKeyRequest"];
            };
        };
        responses: {
            /** @description API key created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        api_key?: components["schemas"]["APIKeyWithPlaintext"];
                    };
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer or API key not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteCustomerAPIKey: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                api_key_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API key deleted */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer or API key not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    InitiateCreditPurchase: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * Format: int64
                     * @description the amount of the checkout transaction in micro value
                     */
                    amount_micros: number;
                    /** @description the currency used in the checkout transaction */
                    currency: string;
                };
            };
        };
        responses: {
            /** @description Customer Checkout created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description the url to redirect the customer */
                        checkout_url?: string;
                    };
                };
            };
            /** @description Bad request, invalid token or user already exists */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    AccessBillingPortal: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    /** @description Optional URL to redirect the customer after they're done with the billing portal */
                    return_url?: string;
                    /** @description Optional target subscription tier. When provided, creates a deep link directly to the subscription update confirmation screen with this tier pre-selected. */
                    target_tier?: "standard" | "creator" | "pro" | "standard-yearly" | "creator-yearly" | "pro-yearly";
                };
            };
        };
        responses: {
            /** @description Billing portal session created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The URL to redirect the customer to the billing portal */
                        billing_portal_url?: string;
                    };
                };
            };
            /** @description Bad request, invalid input */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createCloudSubscriptionCheckout: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Subscription checkout session created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The URL to redirect the customer to complete subscription */
                        checkout_url?: string;
                    };
                };
            };
            /** @description Bad request, invalid input */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createCloudSubscriptionCheckoutTier: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The subscription tier (standard, creator, or pro) with optional yearly billing (standard-yearly, creator-yearly, pro-yearly) */
                tier: "standard" | "creator" | "pro" | "standard-yearly" | "creator-yearly" | "pro-yearly";
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Subscription checkout session created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The URL to redirect the customer to complete subscription */
                        checkout_url?: string;
                    };
                };
            };
            /** @description Bad request, invalid input or tier */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetCloudSubscriptionStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Cloud subscription status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Whether the customer has an active cloud subscription */
                        is_active?: boolean;
                        /** @description The active subscription ID if one exists */
                        subscription_id?: string | null;
                        subscription_tier?: components["schemas"]["SubscriptionTier"] | null;
                        subscription_duration?: components["schemas"]["SubscriptionDuration"] | null;
                        /** @description Whether the customer has funds/credits available */
                        has_fund?: boolean;
                        /**
                         * Format: date-time
                         * @description The next renewal date for the subscription (ISO 8601 format)
                         */
                        renewal_date?: string | null;
                        /**
                         * Format: date-time
                         * @description The date when the subscription is set to end (ISO 8601 format)
                         */
                        end_date?: string | null;
                    };
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    VerifyApiKey: {
        parameters: {
            query?: never;
            header: {
                /** @description Admin API secret used to authorize this request */
                "X-Comfy-Admin-Secret": string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The ComfyUI API key to verify (e.g., comfy_xxx...) */
                    api_key: string;
                };
            };
        };
        responses: {
            /** @description API key is valid */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Whether the API key is valid */
                        valid: boolean;
                        /** @description The Firebase UID of the user */
                        firebase_uid: string;
                        /** @description The customer's email address */
                        email?: string;
                        /** @description The customer's name */
                        name?: string;
                        /** @description Whether the customer is an admin */
                        is_admin?: boolean;
                    };
                };
            };
            /** @description Unauthorized or missing admin API secret */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description API key not found or invalid */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetAdminCustomerCloudSubscriptionStatus: {
        parameters: {
            query?: never;
            header: {
                /** @description Admin API secret used to authorize this request */
                "X-Comfy-Admin-Secret": string;
            };
            path: {
                /** @description The ID of the customer whose subscription status to retrieve */
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Cloud subscription status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Whether the customer has an active cloud subscription */
                        is_active?: boolean;
                        /** @description The active subscription ID if one exists */
                        subscription_id?: string | null;
                        subscription_tier?: components["schemas"]["SubscriptionTier"] | null;
                        subscription_duration?: components["schemas"]["SubscriptionDuration"] | null;
                        /** @description Whether the customer has funds/credits available */
                        has_fund?: boolean;
                        /**
                         * Format: date-time
                         * @description The next renewal date for the subscription (ISO 8601 format)
                         */
                        renewal_date?: string | null;
                        /**
                         * Format: date-time
                         * @description The date when the subscription is set to end (ISO 8601 format)
                         */
                        end_date?: string | null;
                    };
                };
            };
            /** @description Unauthorized or missing admin API secret */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetCustomerUsage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The dashboard URL for the customer's usage */
                        url?: string;
                    };
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetCustomerBalance: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer balance retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: double
                         * @description The total remaining balance in microamount (1/1,000,000 of the currency unit)
                         */
                        amount_micros: number;
                        /**
                         * Format: double
                         * @description The remaining balance from prepaid commits in microamount
                         */
                        prepaid_balance_micros?: number;
                        /**
                         * Format: double
                         * @description The remaining balance from cloud credits in microamount
                         */
                        cloud_credit_balance_micros?: number;
                        /**
                         * Format: double
                         * @description The total amount of pending/unbilled charges from draft invoices in microamount. Only included when the show_negative_balances feature flag is enabled.
                         */
                        pending_charges_micros?: number;
                        /**
                         * Format: double
                         * @description The effective balance (total balance minus pending charges). Can be negative if pending charges exceed the balance. Only included when the show_negative_balances feature flag is enabled.
                         */
                        effective_balance_micros?: number;
                        /** @description The currency code (e.g., "usd") */
                        currency: string;
                    };
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetCustomerBalanceById: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the customer whose balance to retrieve */
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Customer balance retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * Format: double
                         * @description The total remaining balance in microamount (1/1,000,000 of the currency unit)
                         */
                        amount_micros: number;
                        /**
                         * Format: double
                         * @description The remaining balance from prepaid commits in microamount
                         */
                        prepaid_balance_micros?: number;
                        /**
                         * Format: double
                         * @description The remaining balance from cloud credits in microamount
                         */
                        cloud_credit_balance_micros?: number;
                        /**
                         * Format: double
                         * @description The total amount of pending/unbilled charges from draft invoices in microamount. Only included when the show_negative_balances feature flag is enabled.
                         */
                        pending_charges_micros?: number;
                        /**
                         * Format: double
                         * @description The effective balance (total balance minus pending charges). Can be negative if pending charges exceed the balance. Only included when the show_negative_balances feature flag is enabled.
                         */
                        effective_balance_micros?: number;
                        /** @description The currency code (e.g., "usd") */
                        currency: string;
                    };
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    TrackCustomerUsage: {
        parameters: {
            query?: never;
            header: {
                /** @description Admin API secret used to authorize this request */
                "X-Comfy-Admin-Secret": string;
            };
            path: {
                /** @description The ID of the customer to track usage for */
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /**
                     * Format: uuid
                     * @description Unique transaction ID for this usage event
                     */
                    transaction_id: string;
                    /**
                     * Format: date-time
                     * @description Timestamp of the usage event (RFC3339 format)
                     */
                    timestamp?: string;
                    /** @description Custom parameters for the usage event */
                    params: {
                        [key: string]: unknown;
                    };
                };
            };
        };
        responses: {
            /** @description Usage tracked successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Success message */
                        message?: string;
                    };
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized or invalid token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Customer not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createCustomerStorageResource: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The desired name of the file (e.g., 'profile.jpg') */
                    file_name: string;
                    /** @description The content type of the file (e.g., 'image/png') */
                    content_type?: string;
                    /** @description The hash of the file. If provided, an existing file with the same hash may be returned. */
                    file_hash?: string;
                };
            };
        };
        responses: {
            /** @description Signed URL generated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CustomerStorageResourceResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetCustomerEventsById: {
        parameters: {
            query?: {
                /** @description Page number of the nodes list */
                page?: number;
                /** @description Number of nodes to return per page */
                limit?: number;
                /** @description Event type to filter */
                filter?: string;
            };
            header?: never;
            path: {
                customer_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of nodes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total number of events available */
                        total?: number;
                        events?: components["schemas"]["AuditLog"][];
                        /** @description Current page number */
                        page?: number;
                        /** @description Maximum number of nodes per page */
                        limit?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                    };
                };
            };
            /** @description Invalid input, object invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetCustomerEvents: {
        parameters: {
            query?: {
                /** @description Page number of the nodes list */
                page?: number;
                /** @description Number of nodes to return per page */
                limit?: number;
                /** @description Event type to filter */
                filter?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of nodes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total number of events available */
                        total?: number;
                        events?: components["schemas"]["AuditLog"][];
                        /** @description Current page number */
                        page?: number;
                        /** @description Maximum number of nodes per page */
                        limit?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                    };
                };
            };
            /** @description Invalid input, object invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getWorkflowResult: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                workflowResultId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Commit details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ActionJobResult"];
                };
            };
            /** @description Commit not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listPublishersForUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of publishers */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Publisher"][];
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getPermissionOnPublisher: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of permissions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        canEdit?: boolean;
                    };
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    validatePublisher: {
        parameters: {
            query: {
                /** @description The publisher username to validate. */
                username: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Username validation result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description True if the username is available, false otherwise. */
                        isAvailable?: boolean;
                    };
                };
            };
            /** @description Invalid input, such as missing username in the query. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listPublishers: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of publishers */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Publisher"][];
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createPublisher: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Publisher"];
            };
        };
        responses: {
            /** @description Publisher created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Publisher"];
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getPublisher: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Publisher retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Publisher"];
                };
            };
            /** @description Publisher not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    updatePublisher: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Publisher"];
            };
        };
        responses: {
            /** @description Publisher updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Publisher"];
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Publisher not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deletePublisher: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Publisher deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Publisher not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    BanPublisher: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Publisher Banned Successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Publisher not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    claimMyNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ClaimMyNodeRequest"];
            };
        };
        responses: {
            /** @description Node claimed successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description Forbidden - various authorization and permission issues
             *     Includes:
             *     - The authenticated user does not have permission to claim the node
             *     - The node is already claimed by another publisher
             *     - The GH_TOKEN is invalid
             *     - The repository is not owned by the authenticated GitHub user
             */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Too many requests - GitHub API rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Service unavailable - GitHub API is currently unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listNodesForPublisherV2: {
        parameters: {
            query?: {
                /** @description Number of nodes to return per page */
                include_banned?: boolean;
                /** @description Page number of the nodes list */
                page?: number;
                /** @description Number of nodes to return per page */
                limit?: number;
            };
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of all nodes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total number of nodes available */
                        total?: number;
                        nodes?: components["schemas"]["Node"][];
                        /** @description Current page number */
                        page?: number;
                        /** @description Maximum number of nodes per page */
                        limit?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                    };
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listNodesForPublisher: {
        parameters: {
            query?: {
                /** @description Number of nodes to return per page */
                include_banned?: boolean;
            };
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of all nodes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"][];
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Node"];
            };
        };
        responses: {
            /** @description Node created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    updateNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Node"];
            };
        };
        responses: {
            /** @description Node updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getPermissionOnPublisherNodes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A list of permissions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        canEdit?: boolean;
                    };
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    publishNodeVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    personal_access_token: string;
                    node_version: components["schemas"]["NodeVersion"];
                    node: components["schemas"]["Node"];
                };
            };
        };
        responses: {
            /** @description New version published successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The signed URL to upload the node version token. */
                        signedUrl?: string;
                        node_version?: components["schemas"]["NodeVersion"];
                    };
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    updateNodeVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
                versionId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["NodeVersionUpdateRequest"];
            };
        };
        responses: {
            /** @description Version updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeVersion"];
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteNodeVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
                versionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Version unpublished (deleted) successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Version does not belong to the publisher */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Version not found */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    BanPublisherNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node Banned Successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Publisher or Node not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listPersonalAccessTokens: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of all personal access tokens */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PersonalAccessToken"][];
                };
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description No tokens found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createPersonalAccessToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PersonalAccessToken"];
            };
        };
        responses: {
            /** @description Token created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description The newly created personal access token. */
                        token?: string;
                    };
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deletePersonalAccessToken: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                publisherId: string;
                tokenId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Token deleted successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Token not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    searchNodes: {
        parameters: {
            query?: {
                /** @description Page number of the nodes list */
                page?: number;
                /** @description Number of nodes to return per page */
                limit?: number;
                /** @description Keyword to search the nodes */
                search?: string;
                /** @description Keyword to search the nodes by repository URL */
                repository_url_search?: string;
                /** @description Keyword to search the nodes by comfy node name */
                comfy_node_search?: string;
                /** @description Filter nodes by supported operating systems */
                supported_os?: string;
                /** @description Filter nodes by supported accelerator */
                supported_accelerator?: string;
                /** @description Number of nodes to return per page */
                include_banned?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of nodes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total number of nodes available */
                        total?: number;
                        nodes?: components["schemas"]["Node"][];
                        /** @description Current page number */
                        page?: number;
                        /** @description Maximum number of nodes per page */
                        limit?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                    };
                };
            };
            /** @description Invalid input, object invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    reindexNodes: {
        parameters: {
            query?: {
                /** @description Maximum number of nodes to send to algolia at a time */
                max_batch?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Reindex completed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad request. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    updateGithubStars: {
        parameters: {
            query?: {
                /** @description Maximum number of nodes to update in one batch */
                max_batch?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Update GithubStars request triggered successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad request. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listAllNodes: {
        parameters: {
            query?: {
                /** @description Page number of the nodes list */
                page?: number;
                /** @description Number of nodes to return per page */
                limit?: number;
                /** @description Filter nodes by supported operating systems */
                supported_os?: string;
                /** @description Filter nodes by supported accelerator */
                supported_accelerator?: string;
                /** @description Number of nodes to return per page */
                include_banned?: boolean;
                /** @description Retrieve nodes created or updated after this timestamp (ISO 8601 format) */
                timestamp?: string;
                /** @description Whether to fetch fresh result from database or use cached one if false */
                latest?: boolean;
                /** @description Database column to use as ascending ordering. Add `;desc` as suffix on each column for descending sort */
                sort?: string[];
                /** @description node_id to use as filter */
                node_id?: string[];
                /** @description Comfy UI version */
                comfyui_version?: string;
                /** @description The platform requesting the nodes */
                form_factor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description A paginated list of nodes */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total number of nodes available */
                        total?: number;
                        nodes?: components["schemas"]["Node"][];
                        /** @description Current page number */
                        page?: number;
                        /** @description Maximum number of nodes per page */
                        limit?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                    };
                };
            };
            /** @description Invalid input, object invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getNodeByComfyNodeName: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the ComfyUI node */
                comfyNodeName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description No node found containing the specified ComfyUI node name */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getNode: {
        parameters: {
            query?: {
                /** @description Whether to include the translation or not */
                include_translations?: boolean;
            };
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description Redirect to node with normalized name match */
            302: {
                headers: {
                    /** @description URL of the node with the correct ID */
                    Location?: string;
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    postNodeReview: {
        parameters: {
            query: {
                /** @description number of star given to the node version */
                star: number;
            };
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Detailed information about a specific node */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Node version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    installNode: {
        parameters: {
            query?: {
                /** @description Specific version of the node to retrieve. If omitted, the latest version is returned. */
                version?: string;
            };
            header?: never;
            path: {
                /** @description The unique identifier of the node. */
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Node data returned successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeVersion"];
                };
            };
            /** @description Invalid input, such as a bad version format. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    CreateNodeTranslations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The unique identifier of the node. */
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    data?: {
                        [key: string]: {
                            [key: string]: unknown;
                        };
                    };
                };
            };
        };
        responses: {
            /** @description Detailed information about a specific node */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Node version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listNodeVersions: {
        parameters: {
            query?: {
                statuses?: components["schemas"]["NodeVersionStatus"][];
                include_status_reason?: boolean;
            };
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of all node versions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeVersion"][];
                };
            };
            /** @description Node banned */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getNodeVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                /** @description The version of the node. (Not a UUID). */
                versionId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Detailed information about a specific node version */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeVersion"];
                };
            };
            /** @description Node version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getBulkNodeVersions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BulkNodeVersionsRequest"];
            };
        };
        responses: {
            /** @description Successfully retrieved node versions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BulkNodeVersionsResponse"];
                };
            };
            /** @description Bad request, invalid input */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listAllNodeVersions: {
        parameters: {
            query?: {
                nodeId?: string;
                statuses?: components["schemas"]["NodeVersionStatus"][];
                include_status_reason?: boolean;
                /** @description The page number to retrieve. */
                page?: number;
                /** @description The number of items to include per page. */
                pageSize?: number;
                /** @description search for status_reason, case insensitive */
                status_reason?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of all node versions */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Total number of node versions available */
                        total?: number;
                        versions?: components["schemas"]["NodeVersion"][];
                        /** @description Current page number */
                        page?: number;
                        /** @description Maximum number of node versions per page. Maximum is 100. */
                        pageSize?: number;
                        /** @description Total number of pages available */
                        totalPages?: number;
                    };
                };
            };
            /** @description Invalid input, object invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node banned */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateNode: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Node"];
            };
        };
        responses: {
            /** @description Node created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Duplicate error. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Node"];
            };
        };
        responses: {
            /** @description Node updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Node"];
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Node not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateNodeVersion: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                versionNumber: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    status?: components["schemas"]["NodeVersionStatus"];
                    /** @description The reason for the status change. */
                    status_reason?: string;
                    /** @description Supported versions of ComfyUI frontend */
                    supported_comfyui_frontend_version?: string;
                    /** @description Supported versions of ComfyUI */
                    supported_comfyui_version?: string;
                    /** @description List of operating systems that this node supports */
                    supported_os?: string[];
                    /** @description List of accelerators (e.g. CUDA, DirectML, ROCm) that this node supports */
                    supported_accelerators?: string[];
                };
            };
        };
        responses: {
            /** @description Version updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeVersion"];
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listCoupons: {
        parameters: {
            query?: {
                /** @description Number of coupons to return */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of coupons retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        coupons: components["schemas"]["CouponResponse"][];
                        /** @description Whether there are more results available */
                        has_more?: boolean;
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createCoupon: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateCouponRequest"];
            };
        };
        responses: {
            /** @description Coupon created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CouponResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getCoupon: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The Stripe coupon ID */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Coupon retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CouponResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Coupon not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteCoupon: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The Stripe coupon ID */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Coupon deleted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Success message */
                        message: string;
                        /** @description The deleted coupon ID */
                        coupon_id: string;
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Coupon not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    updateCoupon: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The Stripe coupon ID */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateCouponRequest"];
            };
        };
        responses: {
            /** @description Coupon updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CouponResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Coupon not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    listPromoCodes: {
        parameters: {
            query?: {
                /** @description Filter by active status */
                active?: boolean;
                /** @description Number of promo codes to return */
                limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of promo codes retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        promo_codes: components["schemas"]["PromoCodeResponse"][];
                        /** @description Whether there are more results available */
                        has_more?: boolean;
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createPromoCode: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreatePromoCodeRequest"];
            };
        };
        responses: {
            /** @description Promo code created successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromoCodeResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getPromoCode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The Stripe promotion code ID */
                promo_code_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Promo code retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromoCodeResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Promo code not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deletePromoCode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The Stripe promotion code ID */
                promo_code_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Promo code deactivated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @description Success message */
                        message: string;
                        /** @description The deactivated promo code ID */
                        promo_code_id: string;
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Promo code not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    updatePromoCode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The Stripe promotion code ID */
                promo_code_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePromoCodeRequest"];
            };
        };
        responses: {
            /** @description Promo code updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PromoCodeResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden - Admin access required */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Promo code not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getReleaseNotes: {
        parameters: {
            query: {
                /** @description The project to get release notes for */
                project: "comfyui" | "comfyui_frontend" | "desktop" | "cloud";
                /** @description The current version to filter release notes */
                current_version?: string;
                /** @description The locale for the release notes */
                locale?: "en" | "es" | "fr" | "ja" | "ko" | "ru" | "zh";
                /** @description The platform requesting the release notes */
                form_factor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Release notes retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ReleaseNote"][];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    processReleaseWebhook: {
        parameters: {
            query?: never;
            header: {
                /** @description The name of the event that triggered the delivery */
                "X-GitHub-Event": "release";
                /** @description A globally unique identifier (GUID) to identify the event */
                "X-GitHub-Delivery": string;
                /** @description The unique identifier of the webhook */
                "X-GitHub-Hook-ID": string;
                /** @description HMAC hex digest of the request body using SHA-256 hash function */
                "X-Hub-Signature-256"?: string;
                /** @description The type of resource where the webhook was created */
                "X-GitHub-Hook-Installation-Target-Type"?: string;
                /** @description The unique identifier of the resource where the webhook was created */
                "X-GitHub-Hook-Installation-Target-ID"?: string;
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GithubReleaseWebhook"];
            };
        };
        responses: {
            /** @description Webhook processed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation failed or endpoint has been spammed */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    securityScan: {
        parameters: {
            query?: {
                minAge?: string;
                minSecurityScanAge?: string;
                maxNodes?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Scan completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ListComfyNodes: {
        parameters: {
            query?: {
                /** @description The page number to retrieve. */
                page?: number;
                /** @description The number of items to include per page. */
                limit?: number;
            };
            header?: never;
            path: {
                nodeId: string;
                version: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Comy Nodes obtained successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        comfy_nodes?: components["schemas"]["ComfyNode"][];
                        totalNumberOfPages?: number;
                    };
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    CreateComfyNodes: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                version: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    success?: boolean;
                    status?: string;
                    reason?: string;
                    cloud_build_info?: components["schemas"]["ComfyNodeCloudBuildInfo"];
                    nodes?: {
                        [key: string]: components["schemas"]["ComfyNode"];
                    };
                };
            };
        };
        responses: {
            /** @description Comy Nodes created successfully */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Existing Comfy Nodes exists */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GetComfyNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                version: string;
                comfyNodeName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Comy Nodes created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ComfyNode"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Version not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    UpdateComfyNode: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                nodeId: string;
                version: string;
                comfyNodeName: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ComfyNodeUpdateRequest"];
            };
        };
        responses: {
            /** @description Comfy Node updated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ComfyNode"];
                };
            };
            /** @description Bad request, invalid input data */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description ComfyNode not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ListAllComfyNodes: {
        parameters: {
            query?: {
                pageSize?: number;
                /** @description Page number (1-based indexing) */
                page?: number;
                /** @description Filter by node ID */
                node_id?: string;
                /** @description Filter by node version */
                node_version?: string;
                /** @description Filter by ComfyUI node name */
                comfy_node_name?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        comfy_nodes?: components["schemas"]["ComfyNode"][];
                        /** @description Total number of comfy nodes */
                        total?: number;
                    };
                };
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ComfyNodesBackfill: {
        parameters: {
            query?: {
                max_node?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Backfill triggered */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad request, invalid input data. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    dummyProxy: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    message?: string;
                };
            };
        };
        responses: {
            /** @description Reindex completed successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    minimaxVideoGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MinimaxVideoGenerationRequest"];
            };
        };
        responses: {
            /** @description Successful response from Minimax proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MinimaxVideoGenerationResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or Minimax) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with Minimax) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (Minimax took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getMinimaxVideoGeneration: {
        parameters: {
            query: {
                /** @description The task ID to be queried */
                task_id: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response with task status */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MinimaxTaskResultResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or Minimax) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with Minimax) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (Minimax took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    retrieveMinimaxFile: {
        parameters: {
            query: {
                /** @description Unique identifier for the file, obtained from the generation response */
                file_id: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response with file download URL */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MinimaxFileRetrieveResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or Minimax) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with Minimax) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (Minimax took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ideogramGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdeogramGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from Ideogram proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or Ideogram) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with Ideogram) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (Ideogram took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ideogramV3Generate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Parameters for Ideogram V3 image generation */
        requestBody: {
            content: {
                "application/json": components["schemas"]["IdeogramV3Request"];
            };
        };
        responses: {
            /** @description Successful response from Ideogram proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramGenerateResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ideogramV3Edit: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Parameters for Ideogram V3 image editing */
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["IdeogramV3EditRequest"];
            };
        };
        responses: {
            /** @description Successful response from Ideogram proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Prompt or Initial Image failed the safety checks. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Rate limit exceeded (either from proxy or Ideogram) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ideogramV3Remix: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["IdeogramV3RemixRequest"];
            };
        };
        responses: {
            /** @description Remix generated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramV3IdeogramResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unprocessable Entity */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too Many Requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ideogramV3Reframe: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["IdeogramV3ReframeRequest"];
            };
        };
        responses: {
            /** @description Reframed image successfully returned */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramV3IdeogramResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unprocessable Entity */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too Many Requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ideogramV3ReplaceBackground: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["IdeogramV3ReplaceBackgroundRequest"];
            };
        };
        responses: {
            /** @description Background replaced successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramV3IdeogramResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unprocessable Entity */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Too Many Requests */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    klingQueryResourcePackages: {
        parameters: {
            query: {
                start_time: number;
                end_time: number;
                resource_pack_name?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingResourcePackageResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingText2VideoQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingText2VideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateVideoFromText: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating video from text */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingText2VideoRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingText2VideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingText2VideoQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID or external_task_id */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingText2VideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingImage2VideoQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingImage2VideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateVideoFromImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating video from image */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingImage2VideoRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingImage2VideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingImage2VideoQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID or external_task_id */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingImage2VideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingVideoExtendQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVideoExtendResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingExtendVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for extending video duration */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingVideoExtendRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVideoExtendResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingVideoExtendQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVideoExtendResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingLipSyncQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingLipSyncResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateLipSyncVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating lip-sync video */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingLipSyncRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingLipSyncResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingLipSyncQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID or external_task_id */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingLipSyncResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingVideoEffectsQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVideoEffectsResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateVideoEffects: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating video with effects */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingVideoEffectsRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVideoEffectsResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingVideoEffectsQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID or external_task_id */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVideoEffectsResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateOmniVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating omni-video */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingOmniVideoRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingOmniVideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingOmniVideoQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID or External Task ID. Can query by either task_id (generated by system) or external_task_id (customized task ID) */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingOmniVideoResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingImageGenerationsQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingImageGenerationsResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateImageGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating images */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingImageGenerationsRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingImageGenerationsResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingImageGenerationsQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingImageGenerationsResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateOmniImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for generating omni-image */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingOmniImageRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingOmniImageResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingOmniImageQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID or External Task ID. Can query by either task_id (generated by system) or external_task_id (customized task ID) */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingOmniImageResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingVirtualTryOnQueryTaskList: {
        parameters: {
            query?: {
                /** @description Page number */
                pageNum?: number;
                /** @description Data volume per page */
                pageSize?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVirtualTryOnResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingCreateVirtualTryOn: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create task for virtual try-on of clothing on human images */
        requestBody: {
            content: {
                "application/json": components["schemas"]["KlingVirtualTryOnRequest"];
            };
        };
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVirtualTryOnResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    klingVirtualTryOnQuerySingleTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Task ID */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response (Request successful) */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingVirtualTryOnResponse"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["KlingErrorResponse"];
                };
            };
        };
    };
    ltxCreateVideoFromText: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create video from text prompt */
        requestBody: {
            content: {
                "application/json": components["schemas"]["LTXText2VideoRequest"];
            };
        };
        responses: {
            /** @description Video generated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "video/mp4": string;
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ltxCreateVideoFromImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Create video from image */
        requestBody: {
            content: {
                "application/json": components["schemas"]["LTXImage2VideoRequest"];
            };
        };
        responses: {
            /** @description Video generated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "video/mp4": string;
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    bflFluxKontextProGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFluxKontextProGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from BFL Flux Kontext Pro proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLFluxKontextProGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or BFL) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with BFL) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (BFL took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    bflFluxKontextMaxGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFluxKontextMaxGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from BFL Flux Kontext Max proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLFluxKontextMaxGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or BFL) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with BFL) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (BFL took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    bflFluxPro1_1Generate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFluxPro1_1GenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from BFL Flux Pro proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLFluxPro1_1GenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or BFL) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with BFL) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (BFL took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    bflFluxProGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFluxProGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from BFL Flux Pro proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLFluxProGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or BFL) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with BFL) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (BFL took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    bflFlux2ProGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFlux2ProGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from BFL Flux 2 Pro proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLFluxProGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or BFL) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with BFL) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (BFL took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    bflFlux2MaxGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFlux2ProGenerateRequest"];
            };
        };
        responses: {
            /** @description Successful response from BFL Flux 2 Max proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLFluxProGenerateResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded (either from proxy or BFL) */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with BFL) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (BFL took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    BFLExpand_v1_flux_pro_1_0_expand_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFluxProExpandInputs"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLAsyncResponse"] | components["schemas"]["BFLAsyncWebhookResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLHTTPValidationError"];
                };
            };
        };
    };
    BFLFill_v1_flux_pro_1_0_fill_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLFluxProFillInputs"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLAsyncResponse"] | components["schemas"]["BFLAsyncWebhookResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLHTTPValidationError"];
                };
            };
        };
    };
    BFLPro_canny_v1_flux_pro_1_0_canny_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLCannyInputs"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLAsyncResponse"] | components["schemas"]["BFLAsyncWebhookResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLHTTPValidationError"];
                };
            };
        };
    };
    BFLPro_depth_v1_flux_pro_1_0_depth_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BFLDepthInputs"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLAsyncResponse"] | components["schemas"]["BFLAsyncWebhookResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BFLHTTPValidationError"];
                };
            };
        };
    };
    lumaCreateGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The generation request object */
        requestBody: {
            content: {
                "application/json": components["schemas"]["LumaGenerationRequest"];
            };
        };
        responses: {
            /** @description Generation created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LumaGeneration"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LumaError"];
                };
            };
        };
    };
    lumaGetGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the generation */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Generation found */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LumaGeneration"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LumaError"];
                };
            };
        };
    };
    lumaGenerateImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The image generation request object */
        requestBody: {
            content: {
                "application/json": components["schemas"]["LumaImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Image generated */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LumaGeneration"];
                };
            };
            /** @description Error */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LumaError"];
                };
            };
        };
    };
    PixverseGenerateTextVideo: {
        parameters: {
            query?: never;
            header: {
                /** @description Unique UUID for each request. */
                "Ai-trace-id": components["parameters"]["PixverseAiTraceId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PixverseTextVideoRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PixverseVideoResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    PixverseGenerateImageVideo: {
        parameters: {
            query?: never;
            header: {
                /** @description Unique UUID for each request. */
                "Ai-trace-id": components["parameters"]["PixverseAiTraceId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PixverseImageVideoRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PixverseVideoResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    PixverseGenerateTransitionVideo: {
        parameters: {
            query?: never;
            header: {
                /** @description Unique UUID for each request. */
                "Ai-trace-id": components["parameters"]["PixverseAiTraceId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["PixverseTransitionVideoRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PixverseVideoResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    PixverseUploadImage: {
        parameters: {
            query?: never;
            header: {
                /** @description Unique UUID for each request. */
                "Ai-trace-id": components["parameters"]["PixverseAiTraceId"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /** Format: binary */
                    image?: string;
                };
            };
        };
        responses: {
            /** @description Image uploaded */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PixverseImageUploadResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    PixverseGetVideoResult: {
        parameters: {
            query?: never;
            header: {
                /** @description Unique UUID for each request. */
                "Ai-trace-id": components["parameters"]["PixverseAiTraceId"];
            };
            path: {
                id: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Result fetched */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PixverseVideoResultResponse"];
                };
            };
        };
    };
    metronomeZeroBalance: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description the id of the webhook */
                    id: string;
                    /** @description the type of the webhook */
                    type: string;
                    properties: {
                        /** @description the metronome customer id */
                        customer_id?: string;
                        /** @description the customer remaining balance */
                        remaining_balance?: number;
                    };
                };
            };
        };
        responses: {
            /** @description Webhook processed succesfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["IdeogramGenerateResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    StripeInvoiceStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StripeEvent"];
            };
        };
        responses: {
            /** @description Webhook processed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    StripeSubscriptionWebhook: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": Record<string, never>;
            };
        };
        responses: {
            /** @description Webhook processed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    recraftImageGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RecraftImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Successful response from Recraft proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftImageGenerationResponse"];
                };
            };
            /** @description Bad Request (invalid input to proxy) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal Server Error (proxy or upstream issue) */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Bad Gateway (error communicating with Recraft) */
            502: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Gateway Timeout (Recraft took too long to respond) */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    recraftVectorize: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description Image file to process
                     */
                    file: string;
                };
            };
        };
        responses: {
            /** @description Background removed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftImageGenerationResponse"];
                };
            };
            /** @description Bad request - Invalid parameters or file */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Invalid or missing API token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    recraftCrispUpscale: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description Image file to process
                     */
                    file: string;
                };
            };
        };
        responses: {
            /** @description Background removed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftImageGenerationResponse"];
                };
            };
            /** @description Bad request - Invalid parameters or file */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Invalid or missing API token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    recraftRemoveBackground: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": {
                    /**
                     * Format: binary
                     * @description Image file to process
                     */
                    file: string;
                };
            };
        };
        responses: {
            /** @description Background removed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        image?: {
                            /**
                             * Format: uri
                             * @description URL of the processed image
                             */
                            url?: string;
                        };
                    };
                };
            };
            /** @description Bad request - Invalid parameters or file */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized - Invalid or missing API token */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    RecraftImageToImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["RecraftImageToImageRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftGenerateImageResponse"];
                };
            };
        };
    };
    RecraftInpaintImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["RecraftTransformImageWithMaskRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftGenerateImageResponse"];
                };
            };
        };
    };
    RecraftReplaceBackground: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["RecraftTransformImageWithMaskRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftGenerateImageResponse"];
                };
            };
        };
    };
    RecraftCreativeUpscale: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["RecraftProcessImageRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RecraftProcessImageResponse"];
                };
            };
        };
    };
    runwayImageToVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunwayImageToVideoRequest"];
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RunwayImageToVideoResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    runwayGetTaskStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the task to check */
                task_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RunwayTaskStatusResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Task not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    runwayTextToImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunwayTextToImageRequest"];
            };
        };
        responses: {
            /** @description Successful response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RunwayTextToImageResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    veoGenerate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Veo2GenVidRequest"];
            };
        };
        responses: {
            /** @description Video generation successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Veo2GenVidResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    veoPoll: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Veo2GenVidPollRequest"];
            };
        };
        responses: {
            /** @description Operation status and result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Veo2GenVidPollResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Operation not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    veoGenerateNew: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the model to use for generation */
                modelId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VeoGenVidRequest"];
            };
        };
        responses: {
            /** @description Video generation successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VeoGenVidResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    veoPollNew: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the model to use for generation */
                modelId: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["VeoGenVidPollRequest"];
            };
        };
        responses: {
            /** @description Operation status and result */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["VeoGenVidPollResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Operation not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    createOpenAIResponse: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OpenAICreateResponse"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenAIResponse"];
                    "text/event-stream": components["schemas"]["OpenAIResponseStreamEvent"];
                };
            };
        };
    };
    getOpenAIResponse: {
        parameters: {
            query?: {
                /**
                 * @description Additional fields to include in the response. See the `include`
                 *     parameter for Response creation above for more information.
                 */
                include?: components["schemas"]["Includable"][];
            };
            header?: never;
            path: {
                /** @description The ID of the response to retrieve. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenAIResponse"];
                };
            };
        };
    };
    openAIGenerateImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["OpenAIImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Image generated successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenAIImageGenerationResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    openAIEditImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["OpenAIImageEditRequest"];
            };
        };
        responses: {
            /** @description Image edited successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenAIImageGenerationResponse"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    openAICreateVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["OpenAIVideoCreateRequest"];
            };
        };
        responses: {
            /** @description Video generation job created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenAIVideoJob"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Payment Required */
            402: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    openAIGetVideo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier of the video to retrieve */
                video_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video job details */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["OpenAIVideoJob"];
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    openAIDownloadVideoContent: {
        parameters: {
            query?: {
                /** @description Which downloadable asset to return */
                variant?: string;
            };
            header?: never;
            path: {
                /** @description The identifier of the video whose media to download */
                video_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video content stream */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "video/mp4": string;
                };
            };
            /** @description Bad request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Video not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    PikaGenerate_pikadditions_generate_pikadditions_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["PikaBody_generate_pikadditions_generate_pikadditions_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGenerate_pikaswaps_generate_pikaswaps_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["PikaBody_generate_pikaswaps_generate_pikaswaps_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGenerate_pikaffects_generate_pikaffects_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["PikaBody_generate_pikaffects_generate_pikaffects_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGenerate_2_2_t2v_generate_2_2_t2v_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/x-www-form-urlencoded": components["schemas"]["PikaBody_generate_2_2_t2v_generate_2_2_t2v_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGenerate_2_2_keyframe_generate_2_2_pikaframes_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["PikaBody_generate_2_2_keyframe_generate_2_2_pikaframes_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGenerate_2_2_c2v_generate_2_2_pikascenes_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["PikaBody_generate_2_2_c2v_generate_2_2_pikascenes_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGenerate_2_2_i2v_generate_2_2_i2v_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["PikaBody_generate_2_2_i2v_generate_2_2_i2v_post"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaGenerateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    PikaGet_video_videos__video_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                video_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaVideoResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["PikaHTTPValidationError"];
                };
            };
        };
    };
    StabilityImageGenrationUltra: {
        parameters: {
            query?: never;
            header: {
                authorization: string;
                "content-type": string;
                accept?: "image/*" | "application/json";
                "stability-client-id"?: components["schemas"]["StabilityStabilityClientID"];
                "stability-client-user-id"?: components["schemas"]["StabilityStabilityClientUserID"];
                "stability-client-version"?: components["schemas"]["StabilityStabilityClientVersion"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** @description What you wish to see in the output image. A strong, descriptive prompt that clearly defines elements, colors, and subjects will lead to better results. To control the weight of a given word use the format `(word:weight)`, where `word` is the word you'd like to control the weight of and `weight` is a value between 0 and 1. For example: `The sky was a crisp (blue:0.3) and (green:0.8)` would convey a sky that was blue and green, but more green than blue. */
                    prompt: string;
                    /** @description A blurb of text describing what you **do not** wish to see in the output image. This is an advanced feature. */
                    negative_prompt?: string;
                    /**
                     * @description Controls the aspect ratio of the generated image.
                     * @default 1:1
                     * @enum {string}
                     */
                    aspect_ratio?: "21:9" | "16:9" | "3:2" | "5:4" | "1:1" | "4:5" | "2:3" | "9:16" | "9:21";
                    /**
                     * @description A specific value that is used to guide the 'randomness' of the generation. (Omit this parameter or pass `0` to use a random seed.)
                     * @default 0
                     */
                    seed?: number;
                    /**
                     * @description Dictates the `content-type` of the generated image.
                     * @default png
                     * @enum {string}
                     */
                    output_format?: "jpeg" | "png" | "webp";
                    /**
                     * Format: binary
                     * @description The image to use as the starting point for the generation. > **Important:** The `strength` parameter is required when `image` is provided. Supported Formats: - jpeg - png - webp Validation Rules: - Width must be between 64 and 16,384 pixels - Height must be between 64 and 16,384 pixels - Total pixel count must be at least 4,096 pixels
                     * @example ./some/image.png
                     */
                    image?: string;
                    /**
                     * @description Guides the image model towards a particular style.
                     * @enum {string}
                     */
                    style_preset?: "enhance" | "anime" | "photographic" | "digital-art" | "comic-book" | "fantasy-art" | "line-art" | "analog-film" | "neon-punk" | "isometric" | "low-poly" | "origami" | "modeling-compound" | "cinematic" | "3d-model" | "pixel-art" | "tile-texture";
                    /**
                     * @description Sometimes referred to as _denoising_, this parameter controls how much influence the
                     *     `image` parameter has on the generated image.  A value of 0 would yield an image that
                     *     is identical to the input.  A value of 1 would be as if you passed in no image at all.
                     *
                     *     > **Important:** This parameter is required when `image` is provided.
                     */
                    strength?: number;
                };
            };
        };
        responses: {
            /** @description Generation was successful. */
            200: {
                headers: {
                    /** @description A unique identifier for this request. */
                    "x-request-id"?: string;
                    /**
                     * @description The format of the generated image.
                     *       To receive the bytes of the image directly, specify `image/*` in the accept header. To receive the bytes base64 encoded inside of a JSON payload, specify `application/json`.
                     */
                    "content-type"?: string;
                    /** @description Indicates the reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result. > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `finish_reason`. */
                    "finish-reason"?: "SUCCESS" | "CONTENT_FILTERED";
                    /**
                     * @description The seed used as random noise for this generation. > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `seed`.
                     * @example 343940597
                     */
                    seed?: string;
                    [name: string]: unknown;
                };
                content: {
                    /** @example The bytes of the generated jpeg */
                    "image/jpeg": string;
                    "application/json; type=image/jpeg": {
                        /**
                         * @description The generated image, encoded to base64.
                         * @example AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
                         */
                        image: string;
                        /**
                         * @description The seed used as random noise for this generation.
                         * @default 0
                         * @example 343940597
                         */
                        seed: number;
                        /**
                         * @description The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
                         * @example SUCCESS
                         * @enum {string}
                         */
                        finish_reason: "SUCCESS" | "CONTENT_FILTERED";
                    };
                    /** @example The bytes of the generated png */
                    "image/png": string;
                    "application/json; type=image/png": {
                        /**
                         * @description The generated image, encoded to base64.
                         * @example AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
                         */
                        image: string;
                        /**
                         * @description The seed used as random noise for this generation.
                         * @default 0
                         * @example 343940597
                         */
                        seed: number;
                        /**
                         * @description The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
                         * @example SUCCESS
                         * @enum {string}
                         */
                        finish_reason: "SUCCESS" | "CONTENT_FILTERED";
                    };
                    /** @example The bytes of the generated webp */
                    "image/webp": string;
                    "application/json; type=image/webp": {
                        /**
                         * @description The generated image, encoded to base64.
                         * @example AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
                         */
                        image: string;
                        /**
                         * @description The seed used as random noise for this generation.
                         * @default 0
                         * @example 343940597
                         */
                        seed: number;
                        /**
                         * @description The reason the generation finished. - `SUCCESS` = successful generation. - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation policy and has been blurred as a result.
                         * @example SUCCESS
                         * @enum {string}
                         */
                        finish_reason: "SUCCESS" | "CONTENT_FILTERED";
                    };
                };
            };
            /** @description Invalid parameter(s), see the `errors` field for details. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
                         * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
                         */
                        id: string;
                        /**
                         * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
                         * @example bad_request
                         */
                        name: string;
                        /**
                         * @description One or more error messages indicating what went wrong.
                         * @example [
                         *       "some-field: is required"
                         *     ]
                         */
                        errors: string[];
                    };
                };
            };
            /** @description Your request was flagged by our content moderation system. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityContentModerationResponse"];
                };
            };
            /** @description Your request was larger than 10MiB. */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
                         * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
                         */
                        id: string;
                        /**
                         * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
                         * @example bad_request
                         */
                        name: string;
                        /**
                         * @description One or more error messages indicating what went wrong.
                         * @example [
                         *       "some-field: is required"
                         *     ]
                         */
                        errors: string[];
                    };
                };
            };
            /** @description Your request was well-formed, but rejected. See the `errors` field for details. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
                         * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
                         */
                        id: string;
                        /**
                         * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
                         * @example bad_request
                         */
                        name: string;
                        /**
                         * @description One or more error messages indicating what went wrong.
                         * @example [
                         *       "some-field: is required"
                         *     ]
                         */
                        errors: string[];
                    };
                };
            };
            /** @description You have made more than 150 requests in 10 seconds. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
                         * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
                         */
                        id: string;
                        /**
                         * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
                         * @example bad_request
                         */
                        name: string;
                        /**
                         * @description One or more error messages indicating what went wrong.
                         * @example [
                         *       "some-field: is required"
                         *     ]
                         */
                        errors: string[];
                    };
                };
            };
            /** @description An internal error occurred. If the problem persists [contact support](https://kb.stability.ai/knowledge-base/kb-tickets/new). */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /**
                         * @description A unique identifier associated with this error. Please include this in any [support tickets](https://kb.stability.ai/knowledge-base/kb-tickets/new) you file, as it will greatly assist us in diagnosing the root cause of the problem.
                         * @example a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4
                         */
                        id: string;
                        /**
                         * @description Short-hand name for an error, useful for discriminating between errors with the same status code.
                         * @example bad_request
                         */
                        name: string;
                        /**
                         * @description One or more error messages indicating what went wrong.
                         * @example [
                         *       "some-field: is required"
                         *     ]
                         */
                        errors: string[];
                    };
                };
            };
        };
    };
    StabilityImageGenrationSD3: {
        parameters: {
            query?: never;
            header: {
                authorization: string;
                "content-type": string;
                accept?: "image/*" | "application/json";
                "stability-client-id"?: components["schemas"]["StabilityStabilityClientID"];
                "stability-client-user-id"?: components["schemas"]["StabilityStabilityClientUserID"];
                "stability-client-version"?: components["schemas"]["StabilityStabilityClientVersion"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["StabilityImageGenerationSD3_Request"];
            };
        };
        responses: {
            /** @description Generation was successful. */
            200: {
                headers: {
                    /** @description A unique identifier for this request. */
                    "x-request-id"?: string;
                    /**
                     * @description The format of the generated image.
                     *
                     *      To receive the bytes of the image directly, specify `image/*` in the accept header. To receive the bytes base64 encoded inside of a JSON payload, specify `application/json`.
                     */
                    "content-type"?: string;
                    /**
                     * @description Indicates the reason the generation finished.
                     *
                     *     - `SUCCESS` = successful generation.
                     *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
                     *     policy and has been blurred as a result.
                     *
                     *     > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `finish_reason`.
                     */
                    "finish-reason"?: "SUCCESS" | "CONTENT_FILTERED";
                    /**
                     * @description The seed used as random noise for this generation.
                     *
                     *     > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `seed`.
                     * @example 343940597
                     */
                    seed?: string;
                    [name: string]: unknown;
                };
                content: {
                    /** @example The bytes of the generated png */
                    "image/png": string;
                    "application/json; type=image/png": components["schemas"]["StabilityImageGenrationSD3_Response_200"];
                    /** @example The bytes of the generated jpeg */
                    "image/jpeg": string;
                    "application/json; type=image/jpeg": components["schemas"]["StabilityImageGenrationSD3_Response_200"];
                };
            };
            /** @description Invalid parameter(s), see the `errors` field for details. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationSD3_Response_400"];
                };
            };
            /** @description Your request was flagged by our content moderation system. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityContentModerationResponse"];
                };
            };
            /** @description Your request was larger than 10MiB. */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationSD3_Response_413"];
                };
            };
            /** @description Your request was well-formed, but rejected. See the `errors` field for details. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationSD3_Response_422"];
                };
            };
            /** @description You have made more than 150 requests in 10 seconds. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationSD3_Response_429"];
                };
            };
            /** @description An internal error occurred. If the problem persists [contact support](https://kb.stability.ai/knowledge-base/kb-tickets/new). */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationSD3_Response_500"];
                };
            };
        };
    };
    StabilityImageGenrationUpscaleConservative: {
        parameters: {
            query?: never;
            header: {
                authorization: string;
                "content-type": string;
                accept?: "image/*" | "application/json";
                "stability-client-id"?: components["schemas"]["StabilityStabilityClientID"];
                "stability-client-user-id"?: components["schemas"]["StabilityStabilityClientUserID"];
                "stability-client-version"?: components["schemas"]["StabilityStabilityClientVersion"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["StabilityImageGenrationUpscaleConservative_Request"];
            };
        };
        responses: {
            /** @description Upscale was successful. */
            200: {
                headers: {
                    /** @description A unique identifier for this request. */
                    "x-request-id"?: string;
                    /**
                     * @description The format of the generated image.
                     *
                     *      To receive the bytes of the image directly, specify `image/*` in the accept header. To receive the bytes base64 encoded inside of a JSON payload, specify `application/json`.
                     */
                    "content-type"?: string;
                    /**
                     * @description Indicates the reason the generation finished.
                     *
                     *     - `SUCCESS` = successful generation.
                     *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
                     *     policy and has been blurred as a result.
                     *
                     *     > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `finish_reason`.
                     */
                    "finish-reason"?: "SUCCESS" | "CONTENT_FILTERED";
                    /**
                     * @description The seed used as random noise for this generation.
                     *
                     *     > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `seed`.
                     * @example 343940597
                     */
                    seed?: string;
                    [name: string]: unknown;
                };
                content: {
                    /** @example The bytes of the generated jpeg */
                    "image/jpeg": string;
                    "application/json; type=image/jpeg": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_200"];
                    /** @example The bytes of the generated png */
                    "image/png": string;
                    "application/json; type=image/png": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_200"];
                    /** @example The bytes of the generated webp */
                    "image/webp": string;
                    "application/json; type=image/webp": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_200"];
                };
            };
            /** @description Invalid parameter(s), see the `errors` field for details. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_400"];
                };
            };
            /** @description Your request was flagged by our content moderation system. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityContentModerationResponse"];
                };
            };
            /** @description Your request was larger than 10MiB. */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_413"];
                };
            };
            /** @description Your request was well-formed, but rejected. See the `errors` field for details. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_422"];
                };
            };
            /** @description You have made more than 150 requests in 10 seconds. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_429"];
                };
            };
            /** @description An internal error occurred. If the problem persists [contact support](https://kb.stability.ai/knowledge-base/kb-tickets/new). */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleConservative_Response_500"];
                };
            };
        };
    };
    StabilityImageGenrationUpscaleCreative: {
        parameters: {
            query?: never;
            header: {
                authorization: string;
                "content-type": string;
                "stability-client-id"?: components["schemas"]["StabilityStabilityClientID"];
                "stability-client-user-id"?: components["schemas"]["StabilityStabilityClientUserID"];
                "stability-client-version"?: components["schemas"]["StabilityStabilityClientVersion"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["StabilityImageGenrationUpscaleCreative_Request"];
            };
        };
        responses: {
            /** @description Upscale was started. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleCreative_Response_200"];
                };
            };
            /** @description Invalid parameter(s), see the `errors` field for details. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleCreative_Response_400"];
                };
            };
            /** @description Your request was flagged by our content moderation system. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityContentModerationResponse"];
                };
            };
            /** @description Your request was larger than 10MiB. */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleCreative_Response_413"];
                };
            };
            /** @description Your request was well-formed, but rejected. See the `errors` field for details. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleCreative_Response_422"];
                };
            };
            /** @description You have made more than 150 requests in 10 seconds. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleCreative_Response_429"];
                };
            };
            /** @description An internal error occurred. If the problem persists [contact support](https://kb.stability.ai/knowledge-base/kb-tickets/new). */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleCreative_Response_500"];
                };
            };
        };
    };
    StabilityImageGenerationUpscaleFast: {
        parameters: {
            query?: never;
            header: {
                authorization: string;
                "content-type": string;
                accept?: "image/*" | "application/json";
                "stability-client-id"?: components["schemas"]["StabilityStabilityClientID"];
                "stability-client-user-id"?: components["schemas"]["StabilityStabilityClientUserID"];
                "stability-client-version"?: components["schemas"]["StabilityStabilityClientVersion"];
            };
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": components["schemas"]["StabilityImageGenrationUpscaleFast_Request"];
            };
        };
        responses: {
            /** @description Upscale was successful. */
            200: {
                headers: {
                    /** @description A unique identifier for this request. */
                    "x-request-id"?: string;
                    /**
                     * @description The format of the generated image.
                     *
                     *      To receive the bytes of the image directly, specify `image/*` in the accept header. To receive the bytes base64 encoded inside of a JSON payload, specify `application/json`.
                     */
                    "content-type"?: string;
                    /**
                     * @description Indicates the reason the generation finished.
                     *
                     *     - `SUCCESS` = successful generation.
                     *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
                     *     policy and has been blurred as a result.
                     *
                     *     > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `finish_reason`.
                     */
                    "finish-reason"?: "SUCCESS" | "CONTENT_FILTERED";
                    /**
                     * @description The seed used as random noise for this generation.
                     *
                     *     > **NOTE:** This header is absent on JSON encoded responses because it is present in the body as `seed`.
                     * @example 343940597
                     */
                    seed?: string;
                    [name: string]: unknown;
                };
                content: {
                    /** @example The bytes of the generated jpeg */
                    "image/jpeg": string;
                    "application/json; type=image/jpeg": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_200"];
                    /** @example The bytes of the generated png */
                    "image/png": string;
                    "application/json; type=image/png": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_200"];
                    /** @example The bytes of the generated webp */
                    "image/webp": string;
                    "application/json; type=image/webp": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_200"];
                };
            };
            /** @description Invalid parameter(s), see the `errors` field for details. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_400"];
                };
            };
            /** @description Your request was flagged by our content moderation system. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityContentModerationResponse"];
                };
            };
            /** @description Your request was larger than 10MiB. */
            413: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_413"];
                };
            };
            /** @description Your request was well-formed, but rejected. See the `errors` field for details. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_422"];
                };
            };
            /** @description You have made more than 150 requests in 10 seconds. */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_429"];
                };
            };
            /** @description An internal error occurred. If the problem persists [contact support](https://kb.stability.ai/knowledge-base/kb-tickets/new). */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityImageGenrationUpscaleFast_Response_500"];
                };
            };
        };
    };
    StabilityGetResult: {
        parameters: {
            query?: never;
            header?: {
                /** @description Set to image/* to receive image bytes. */
                Accept?: string;
            };
            path: {
                /** @description The ID of the generation result to retrieve. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The generated image as JPEG bytes. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "image/jpeg": string;
                    "application/json; type=image/jpeg": {
                        /**
                         * @description The generated image, encoded to base64.
                         * @example AAAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
                         */
                        image: string;
                        /**
                         * @description The seed used as random noise for this generation.
                         * @default 0
                         * @example 343940597
                         */
                        seed: number;
                        /**
                         * @description The reason the generation finished.
                         *
                         *     - `SUCCESS` = successful generation.
                         *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
                         *       policy and has been blurred as a result.
                         * @example SUCCESS
                         * @enum {string}
                         */
                        finish_reason: "SUCCESS" | "CONTENT_FILTERED";
                    };
                    /** @example The bytes of the generated png */
                    "image/png": string;
                    "application/json; type=image/png": {
                        /**
                         * @description The generated image, encoded to base64.
                         * @example AAAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
                         */
                        image: string;
                        /**
                         * @description The seed used as random noise for this generation.
                         * @default 0
                         * @example 343940597
                         */
                        seed: number;
                        /**
                         * @description The reason the generation finished.
                         *
                         *     - `SUCCESS` = successful generation.
                         *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
                         *       policy and has been blurred as a result.
                         * @example SUCCESS
                         * @enum {string}
                         */
                        finish_reason: "SUCCESS" | "CONTENT_FILTERED";
                    };
                    /** @example The bytes of the generated webp */
                    "image/webp": string;
                    "application/json; type=image/webp": {
                        /**
                         * @description The generated image, encoded to base64.
                         * @example AAAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1...
                         */
                        image: string;
                        /**
                         * @description The seed used as random noise for this generation.
                         * @default 0
                         * @example 343940597
                         */
                        seed: number;
                        /**
                         * @description The reason the generation finished.
                         *
                         *     - `SUCCESS` = successful generation.
                         *     - `CONTENT_FILTERED` = successful generation, however the output violated our content moderation
                         *       policy and has been blurred as a result.
                         * @example SUCCESS
                         * @enum {string}
                         */
                        finish_reason: "SUCCESS" | "CONTENT_FILTERED";
                    };
                };
            };
            /** @description The generation is still in progress. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityGetResultResponse_202"];
                };
            };
            /** @description Invalid result ID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityError"];
                };
            };
            /** @description Result not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityError"];
                };
            };
            /** @description An internal error occurred. If the problem persists [contact support](https://kb.stability.ai/knowledge-base/kb-tickets/new). */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StabilityError"];
                };
            };
        };
    };
    stableAudio25TextToAudio: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["StableAudio25TextToAudioRequest"];
            };
        };
        responses: {
            /** @description Successful response from Stable Audio proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StableAudio25AudioResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    stableAudio25AudioToAudio: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["StableAudio25AudioToAudioRequest"];
            };
        };
        responses: {
            /** @description Successful response from Stable Audio proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StableAudio25AudioResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    stableAudio25Inpaint: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["StableAudio25InpaintRequest"];
            };
        };
        responses: {
            /** @description Successful response from Stable Audio proxy */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StableAudio25AudioResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    GeminiGenerateContent: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Full resource name of the model. */
                model: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["GeminiGenerateContentRequest"];
            };
        };
        responses: {
            /** @description Generated content response. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GeminiGenerateContentResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    ImagenGenerateImages: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description image generation model */
                model: "imagen-3.0-generate-002" | "imagen-3.0-generate-001" | "imagen-3.0-fast-generate-001" | "imagegeneration@006" | "imagegeneration@005" | "imagegeneration@002";
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ImagenGenerateImageRequest"];
            };
        };
        responses: {
            /** @description Successful image generation */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ImagenGenerateImageResponse"];
                };
            };
            /** @description Client error */
            "4XX": {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Server error */
            "5XX": {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    tripoGetTask: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                task_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Request successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        code: components["schemas"]["TripoResponseSuccessCode"];
                        data: components["schemas"]["TripoTask"];
                    };
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
        };
    };
    tripoUploadFile: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "multipart/form-data": {
                    /** Format: binary */
                    file: string;
                };
            };
        };
        responses: {
            /** @description Request successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        code: components["schemas"]["TripoResponseSuccessCode"];
                        data: {
                            image_token: string;
                        };
                    };
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
        };
    };
    tripoCreateTask: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": {
                    type: components["schemas"]["TripoTextToModel"];
                    prompt: string;
                    negative_prompt?: string;
                    model_version?: components["schemas"]["TripoModelVersion"];
                    face_limit?: number;
                    /** @default true */
                    texture?: boolean;
                    /** @default true */
                    pbr?: boolean;
                    text_seed?: number;
                    model_seed?: number;
                    texture_seed?: number;
                    /** @default standard */
                    texture_quality?: components["schemas"]["TripoTextureQuality"];
                    style?: components["schemas"]["TripoModelStyle"];
                    /** @default false */
                    auto_size?: boolean;
                    /** @default false */
                    quad?: boolean;
                    geometry_quality?: components["schemas"]["TripoGeometryQuality"];
                } | {
                    type: components["schemas"]["TripoImageToModel"];
                    file: {
                        type: string;
                        file_token: string;
                    };
                    model_version?: components["schemas"]["TripoModelVersion"];
                    face_limit?: number;
                    /** @default true */
                    texture?: boolean;
                    /** @default true */
                    pbr?: boolean;
                    model_seed?: number;
                    texture_seed?: number;
                    /** @default standard */
                    texture_quality?: components["schemas"]["TripoTextureQuality"];
                    /** @default original_image */
                    texture_alignment?: components["schemas"]["TripoTextureAlignment"];
                    style?: components["schemas"]["TripoModelStyle"];
                    /** @default false */
                    auto_size?: boolean;
                    /** @default default */
                    orientation?: components["schemas"]["TripoOrientation"];
                    /** @default false */
                    quad?: boolean;
                    geometry_quality?: components["schemas"]["TripoGeometryQuality"];
                } | {
                    type: components["schemas"]["TripoMultiviewToModel"];
                    files: {
                        type: string;
                        file_token: string;
                    }[];
                    mode?: components["schemas"]["TripoMultiviewMode"];
                    model_version?: components["schemas"]["TripoModelVersion"];
                    /** @default false */
                    orthographic_projection?: boolean;
                    face_limit?: number;
                    /** @default true */
                    texture?: boolean;
                    /** @default true */
                    pbr?: boolean;
                    model_seed?: number;
                    texture_seed?: number;
                    /** @default standard */
                    texture_quality?: components["schemas"]["TripoTextureQuality"];
                    /** @default original_image */
                    texture_alignment?: components["schemas"]["TripoTextureAlignment"];
                    /** @default false */
                    auto_size?: boolean;
                    /** @default default */
                    orientation?: components["schemas"]["TripoOrientation"];
                    /** @default false */
                    quad?: boolean;
                    geometry_quality?: components["schemas"]["TripoGeometryQuality"];
                } | {
                    type: components["schemas"]["TripoTypeTextureModel"];
                    /** @default true */
                    texture?: boolean;
                    /** @default true */
                    pbr?: boolean;
                    model_seed?: number;
                    texture_seed?: number;
                    texture_quality?: components["schemas"]["TripoTextureQuality"];
                    /** @default original_image */
                    texture_alignment?: components["schemas"]["TripoTextureAlignment"];
                    original_model_task_id: string;
                } | {
                    type: components["schemas"]["TripoTypeRefineModel"];
                    draft_model_task_id: string;
                } | {
                    type: components["schemas"]["TripoTypeAnimatePrerigcheck"];
                    original_model_task_id: string;
                } | {
                    type: components["schemas"]["TripoTypeAnimateRig"];
                    original_model_task_id: string;
                    /** @default glb */
                    out_format?: components["schemas"]["TripoStandardFormat"];
                    topology?: components["schemas"]["TripoTopology"];
                    /** @default tripo */
                    spec?: components["schemas"]["TripoSpec"];
                } | {
                    type: components["schemas"]["TripoTypeAnimateRetarget"];
                    original_model_task_id: string;
                    /** @default glb */
                    out_format?: components["schemas"]["TripoStandardFormat"];
                    animation: components["schemas"]["TripoAnimation"];
                    /** @default true */
                    bake_animation?: boolean;
                } | {
                    type: components["schemas"]["TripoTypeStylizeModel"];
                    style: components["schemas"]["TripoStylizeOptions"];
                    original_model_task_id: string;
                    /** @default 80 */
                    block_size?: number;
                } | {
                    type: components["schemas"]["TripoTypeConvertModel"];
                    format: components["schemas"]["TripoConvertFormat"];
                    original_model_task_id: string;
                    /** @default false */
                    quad?: boolean;
                    /** @default false */
                    force_symmetry?: boolean;
                    /** @default 10000 */
                    face_limit?: number;
                    /** @default false */
                    flatten_bottom?: boolean;
                    /** @default 0.01 */
                    flatten_bottom_threshold?: number;
                    /** @default 4096 */
                    texture_size?: number;
                    /** @default JPEG */
                    texture_format?: components["schemas"]["TripoTextureFormat"];
                    /** @default false */
                    pivot_to_center_bottom?: boolean;
                };
            };
        };
        responses: {
            /** @description Request successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoSuccessTask"];
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
        };
    };
    tripoGetBalance: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Request successful */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        code: components["schemas"]["TripoResponseSuccessCode"];
                        data: components["schemas"]["TripoBalance"];
                    };
                };
            };
            /** @description Invalid request parameters */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Authentication failed */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Unauthorized access to requested resource */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Resource not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Account exception or Rate limit exceeded */
            429: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Internal server error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Service temporarily unavailable */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
            /** @description Server timeout */
            504: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TripoErrorResponse"];
                };
            };
        };
    };
    rodinGenerate3DAsset: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Rodin3DGenerateRequest"];
            };
        };
        responses: {
            /** @description 3D generate Task submitted successfully. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Rodin3DGenerateResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    rodinCheckStatus: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Rodin3DCheckStatusRequest"];
            };
        };
        responses: {
            /** @description Get the status of the 3D Assets generation. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Rodin3DCheckStatusResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    rodinDownload: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["Rodin3DDownloadRequest"];
            };
        };
        responses: {
            /** @description Get the download list for the Rodin 3D Assets. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Rodin3DDownloadResponse"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Unauthorized */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Forbidden */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
        };
    };
    MoonvalleyGetPrompt: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                prompt_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Prompt details retrieved */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyPromptResponse"];
                };
            };
        };
    };
    MoonvalleyTextToVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoonvalleyTextToVideoRequest"];
            };
        };
        responses: {
            /** @description Prompt created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyPromptResponse"];
                };
            };
        };
    };
    MoonvalleyTextToImage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoonvalleyTextToImageRequest"];
            };
        };
        responses: {
            /** @description Prompt created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyPromptResponse"];
                };
            };
        };
    };
    MoonvalleyImageToVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoonvalleyImageToVideoRequest"];
            };
        };
        responses: {
            /** @description Prompt created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyPromptResponse"];
                };
            };
        };
    };
    MoonvalleyVideoToVideo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoonvalleyVideoToVideoRequest"];
            };
        };
        responses: {
            /** @description Prompt created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyPromptResponse"];
                };
            };
        };
    };
    MoonvalleyVideoToVideoResize: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MoonvalleyResizeVideoRequest"];
            };
        };
        responses: {
            /** @description Prompt created */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyPromptResponse"];
                };
            };
        };
    };
    MoonvalleyUpload: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["MoonvalleyUploadFileRequest"];
            };
        };
        responses: {
            /** @description File uploaded successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MoonvalleyUploadFileResponse"];
                };
            };
        };
    };
    ViduImg2Video: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViduTaskRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ViduTaskReply"];
                };
            };
            /** @description Error 4xx/5xx */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    ViduReference2Video: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViduTaskRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ViduTaskReply"];
                };
            };
            /** @description Error 4xx/5xx */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    ViduStartEnd2Video: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViduTaskRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ViduTaskReply"];
                };
            };
            /** @description Error 4xx/5xx */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    ViduText2Video: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ViduTaskRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ViduTaskReply"];
                };
            };
            /** @description Error 4xx/5xx */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    ViduGetCreations: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ViduGetCreationsReply"];
                };
            };
            /** @description Error 4xx/5xx */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    byteplusImageGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BytePlusImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Image generation completed successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BytePlusImageGenerationResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    byteplusVideoGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BytePlusVideoGenerationRequest"];
            };
        };
        responses: {
            /** @description Video generation task created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BytePlusVideoGenerationResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    byteplusVideoGenerationQuery: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the video generation task to query */
                task_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video generation task information retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BytePlusVideoGenerationQueryResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    wanVideoGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WanVideoGenerationRequest"];
            };
        };
        responses: {
            /** @description Video generation task created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WanVideoGenerationResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    wanImageGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WanImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Image generation task created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WanImageGenerationResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    wanImage2ImageGeneration: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["WanImage2ImageGenerationRequest"];
            };
        };
        responses: {
            /** @description Image-to-image generation task created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WanImage2ImageGenerationResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    wanTaskQueryProxy: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the generation task to query */
                task_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Generation task information retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WanTaskQueryResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topazEnhanceGenAsync: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["TopazEnhanceGenRequest"];
            };
        };
        responses: {
            /** @description Image processing request has been successfully created */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazEnhanceGenResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    topazGetStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The process ID returned from the enhance-gen request */
                process_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazStatusResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    topazDownloadResult: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The process ID returned from the enhance-gen request */
                process_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Presigned download URL for the processed image */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazDownloadResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    topazVideoCreate: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TopazVideoCreateRequest"];
            };
        };
        responses: {
            /** @description Video enhancement request created successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazVideoCreateResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    topazVideoAccept: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The request ID returned from the video create request */
                request_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video request accepted successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazVideoAcceptResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    topazVideoCompleteUpload: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The request ID returned from the video create request */
                request_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["TopazVideoCompleteUploadRequest"];
            };
        };
        responses: {
            /** @description Video upload completed successfully */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazVideoCompleteUploadResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    topazVideoGetStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The request ID returned from the video create request */
                request_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Video status retrieved successfully */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopazVideoStatusResponse"];
                };
            };
            /** @description Error 4xx/5xx */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Error"];
                };
            };
        };
    };
    getFeatures: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FeaturesResponse"];
                };
            };
        };
    };
}
