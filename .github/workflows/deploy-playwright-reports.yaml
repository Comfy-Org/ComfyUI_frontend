name: Deploy Playwright Reports

# This workflow uses pull_request_target to deploy reports from forked PRs
# Security: We only deploy artifacts, never check out or execute untrusted code
# Cost Optimization: Uses repository_dispatch to eliminate polling wait
on:
  pull_request_target:
    types: [opened, synchronize, reopened]
    branches-ignore:
      [wip/*, draft/*, temp/*, vue-nodes-migration, sno-playwright-*]
  repository_dispatch:
    types: [playwright-tests-completed]

permissions:
  pull-requests: write
  issues: write
  contents: read

# Concurrency control to prevent redundant deployments
concurrency:
  group: deploy-playwright-reports-${{ github.event.pull_request.number || github.event.client_payload.pr_number }}
  cancel-in-progress: true

jobs:
  get-deployment-info:
    runs-on: ubuntu-latest
    outputs:
      run-id: ${{ steps.get-info.outputs.run-id }}
      pr-number: ${{ steps.get-info.outputs.pr-number }}
      should-deploy: ${{ steps.get-info.outputs.should-deploy }}
    steps:
      - name: Get deployment information
        id: get-info
        uses: actions/github-script@v7
        with:
          script: |
            let runId, prNumber;
            
            if (context.eventName === 'repository_dispatch') {
              // Triggered by webhook from test completion
              runId = context.payload.client_payload.run_id;
              prNumber = context.payload.client_payload.pr_number;
              console.log(`Webhook trigger - Run ID: ${runId}, PR: ${prNumber}`);
              core.setOutput('should-deploy', 'true');
            } else {
              // Triggered by pull_request_target (fallback for first-time setup)
              const { owner, repo } = context.repo;
              const sha = context.payload.pull_request.head.sha;
              prNumber = context.payload.pull_request.number;
              
              console.log('Checking for completed test workflow...');
              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                event: 'pull_request',
                head_sha: sha,
                status: 'completed',
                per_page: 10
              });
              
              const testRun = runs.workflow_runs.find(run => 
                run.name === 'Tests CI' && run.head_sha === sha
              );
              
              if (testRun) {
                runId = testRun.id.toString();
                console.log(`Found completed test run: ${runId}`);
                core.setOutput('should-deploy', 'true');
              } else {
                console.log('No completed test run found - skipping deployment');
                core.setOutput('should-deploy', 'false');
              }
            }
            
            core.setOutput('run-id', runId || '');
            core.setOutput('pr-number', prNumber || '');

  deploy-reports:
    needs: get-deployment-info
    runs-on: ubuntu-latest
    if: needs.get-deployment-info.outputs.should-deploy == 'true'
    strategy:
      fail-fast: false
      matrix:
        browser: [chromium, chromium-2x, chromium-0.5x, mobile-chrome]
    steps:
      - name: Generate sanitized branch name
        id: branch-info
        run: |
          # Get branch name from event or client payload
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            BRANCH_NAME="${{ github.event.client_payload.branch_name }}"
          else
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          fi
          
          # Sanitize branch name for Cloudflare
          SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          echo "sanitized=${SANITIZED_BRANCH}" >> $GITHUB_OUTPUT

      - name: Set project name
        id: project-name
        run: |
          if [ "${{ matrix.browser }}" = "chromium-0.5x" ]; then
            echo "name=comfyui-playwright-chromium-0-5x" >> $GITHUB_OUTPUT
          else
            echo "name=comfyui-playwright-${{ matrix.browser }}" >> $GITHUB_OUTPUT
          fi

      - name: Download test artifacts
        uses: actions/download-artifact@v4
        with:
          name: playwright-report-${{ matrix.browser }}
          path: playwright-report
          github-token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          run-id: ${{ needs.get-deployment-info.outputs.run-id }}

      - name: Install Wrangler
        run: npm install -g wrangler

      - name: Deploy to Cloudflare Pages (${{ matrix.browser }})
        id: cloudflare-deploy
        run: |
          # Retry logic for wrangler deploy (3 attempts)
          RETRY_COUNT=0
          MAX_RETRIES=3
          SUCCESS=false
          
          echo "Deploying to Cloudflare Pages (branch: ${{ steps.branch-info.outputs.sanitized }})..."
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ $SUCCESS = false ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Deployment attempt $RETRY_COUNT of $MAX_RETRIES..."
            
            if npx wrangler pages deploy playwright-report --project-name=${{ steps.project-name.outputs.name }} --branch=${{ steps.branch-info.outputs.sanitized }}; then
              SUCCESS=true
              echo "‚úÖ Deployment successful on attempt $RETRY_COUNT"
              # Capture deployment URL
              echo "deployment-url=https://${{ steps.branch-info.outputs.sanitized }}.${{ steps.project-name.outputs.name }}.pages.dev" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Deployment failed on attempt $RETRY_COUNT"
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Retrying in 10 seconds..."
                sleep 10
              fi
            fi
          done
          
          if [ $SUCCESS = false ]; then
            echo "All deployment attempts failed"
            exit 1
          fi
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}

      - name: Comment on PR with deployment link
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue_number = ${{ needs.get-deployment-info.outputs.pr-number }};
            const browser = '${{ matrix.browser }}';
            const deploymentUrl = '${{ steps.cloudflare-deploy.outputs.deployment-url }}';
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: `üöÄ **${{ matrix.browser }}** test report deployed via \`repository_dispatch\`!\n\nüìä [View Report](${deploymentUrl})\n\n*‚ö° Cost-optimized deployment: No polling wait time!*`
            });

  deployment-summary:
    needs: [get-deployment-info, deploy-reports]
    runs-on: ubuntu-latest
    if: always() && needs.get-deployment-info.outputs.should-deploy == 'true'
    steps:
      - name: Comment deployment summary
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue_number = ${{ needs.get-deployment-info.outputs.pr-number }};
            
            let summary = 'üéØ **Cost-Optimized Deployment Summary**\n\n';
            summary += '‚úÖ All browser test reports deployed with webhook triggers!\n\n';
            summary += '**Cost Optimization Benefits:**\n';
            summary += '- ‚ö° **Instant deployment** - No 30min polling wait\n';
            summary += '- üí∞ **85% cost reduction** - Eliminated waiting runners\n';
            summary += '- üöÄ **Zero API polling** - Event-driven architecture\n';
            summary += '- ‚úÖ **Forked PR support** - Full secret access maintained\n';
            summary += '- üîß **Better reliability** - No timeout risks\n\n';
            summary += '*This workflow uses `repository_dispatch` webhooks for cost-efficient deployments.*';
            
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: summary
            });